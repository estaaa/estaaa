{"meta":{"title":"道法自然","subtitle":"记录精彩的人生, 留下永恒的脚印","description":"php教程 js教程 php博客 linux教程","author":"道法自然","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-04-20T09:02:01.000Z","updated":"2020-04-20T09:05:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"工厂模式","slug":"sheji02","date":"2020-04-20T12:19:23.000Z","updated":"2020-04-20T12:20:12.000Z","comments":true,"path":"2020/04/20/sheji02/","link":"","permalink":"http://yoursite.com/2020/04/20/sheji02/","excerpt":"","text":"工厂模式 工厂模式具体可分为三类模式：简单工厂模式，工厂方法模式，抽象工厂模式； ####1.简单工厂模式又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 角色： Factory类：负责创建具体产品的实例 Product类：抽象产品类，定义产品子类的公共接口 ConcreteProduct 类：具体产品类，实现Product父类的接口功能，也可添加自定义的功能 示例代码： 1234567891011121314151617181920212223242526272829&lt;?php //简单工厂模式class Cat&#123; function __construct() &#123; echo \"I am Cat class &lt;br&gt;\"; &#125;&#125;class Dog&#123; function __construct() &#123; echo \"I am Dog class &lt;br&gt;\"; &#125;&#125;class Factory&#123; public static function CreateAnimal($name)&#123; if ($name == 'cat') &#123; return new Cat(); &#125; elseif ($name == 'dog') &#123; return new Dog(); &#125; &#125;&#125;$cat = Factory::CreateAnimal('cat');$dog = Factory::CreateAnimal('dog'); 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 ###工厂方法模式此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品是，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，是系统的扩展性变得很好，符合面向对象编程的开闭原则; 角色： Product：抽象产品类 ConcreteProduct：具体产品类 Factory：抽象工厂类 ConcreteFactory：具体工厂类 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php interface Animal&#123; public function run(); public function say();&#125;class Cat implements Animal&#123; public function run()&#123; echo \"I ran slowly &lt;br&gt;\"; &#125; public function say()&#123; echo \"I am Cat class &lt;br&gt;\"; &#125;&#125;class Dog implements Animal&#123; public function run()&#123; echo \"I'm running fast &lt;br&gt;\"; &#125; public function say()&#123; echo \"I am Dog class &lt;br&gt;\"; &#125;&#125;abstract class Factory&#123; abstract static function createAnimal();&#125;class CatFactory extends Factory&#123; public static function createAnimal() &#123; return new Cat(); &#125;&#125;class DogFactory extends Factory&#123; public static function createAnimal() &#123; return new Dog(); &#125;&#125;$cat = CatFactory::createAnimal();$cat-&gt;say();$cat-&gt;run();$dog = DogFactory::createAnimal();$dog-&gt;say();$dog-&gt;run(); 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 ###抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。 为了便于理解此模式，这里介绍两个概念：产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 角色： 抽象工厂（AbstractFactory）：担任这个角色的是抽象工厂模式的核心，是与应用系统的商业逻辑无关的。 具体工厂（Factory）：这个角色直接在客户端的调用下创建产品的实例，这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统商业逻辑紧密相关的。 抽象产品（AbstractProduct）：担任这个角色的类是抽象工厂模式所创建的对象的父类，或它们共同拥有的接口 具体产品（Product）：抽象工厂模式所创建的任何产品对象都是一个具体的产品类的实例。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php interface TV&#123; public function open(); public function use();&#125;class HaierTv implements TV&#123; public function open() &#123; echo \"Open Haier TV &lt;br&gt;\"; &#125; public function use() &#123; echo \"I'm watching TV &lt;br&gt;\"; &#125;&#125;interface PC&#123; public function work(); public function play();&#125;class LenovoPc implements PC&#123; public function work() &#123; echo \"I'm working on a Lenovo computer &lt;br&gt;\"; &#125; public function play() &#123; echo \"Lenovo computers can be used to play games &lt;br&gt;\"; &#125;&#125;abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv();&#125;class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125;&#125;$newTv = ProductFactory::createTV();$newTv-&gt;open();$newTv-&gt;use();$newPc = ProductFactory::createPc();$newPc-&gt;work();$newPc-&gt;play();","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"策略模式","slug":"sheji01","date":"2020-04-20T12:14:44.000Z","updated":"2020-04-20T12:15:35.000Z","comments":true,"path":"2020/04/20/sheji01/","link":"","permalink":"http://yoursite.com/2020/04/20/sheji01/","excerpt":"","text":"策略模式 策略模式（Strategy Pattern）是对象的行为模式，是对一组算法的抽象封装，动态的选择算法使用。在我们的日常生活中，策略模式体现在方方面面：早上起床我去公司，可以坐公交，可以坐出租车，也可以步行，最终的目的都是到达公司，但是却使用了不同的资源。 策略模式的三个角色： 抽象策略角色具体策略角色环境角色（对抽象策略角色的引用）策略模式的实现步骤：定义抽象角色（类）或抽象方法（接口）（定义好各个实现的共同抽象方法）定义具体策略类（实现父类的共同方法）定义环境角色类（私有化声明抽象角色变量，重载构造方法，执行抽象方法）策略模式的示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/**** 策略模式 * */ interface wayToSchool &#123; //定义抽象策略 public function way();&#125; class wayWithCar implements wayToSchool &#123; //定义坐车去学校的具体策略 public function way() &#123; echo \"goes to school by CAR!\\n\"; &#125;&#125; class wayWithBicycle implements wayToSchool &#123; //定义骑车去学校的具体策略 public function way() &#123; echo \"goes to school by BICYCLE!\\n\"; &#125;&#125; class wayWithWalk implements wayToSchool &#123; //定义步行去学校的具体策略 public function way() &#123; echo \"goes to school by WALK!\\n\"; &#125;&#125; class Student &#123; //定义环境角色类（学生） private $_wayToSchool; private $_name; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function performance() &#123; echo $this-&gt;_name, \" \"; $this-&gt;_wayToSchool-&gt;way(); &#125; public function setWayToSchool(wayToSchool $_way) &#123; $this-&gt;_wayToSchool = $_way; &#125;&#125; $jerry = new Student(\"jerry\");$tom = new Student(\"tom\");$eggsy = new Student(\"eggsy\"); //实现不同策略$jerry-&gt;setWayToSchool(new wayWithCar);$jerry-&gt;performance(); $tom-&gt;setWayToSchool(new wayWithBicycle);$tom-&gt;performance(); $eggsy-&gt;setWayToSchool(new wayWithWalk);$eggsy-&gt;performance(); 优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"Nginx与Nginx-rtmp-module搭建hls源","slug":"hls","date":"2020-04-20T11:53:37.000Z","updated":"2020-04-20T11:55:02.000Z","comments":true,"path":"2020/04/20/hls/","link":"","permalink":"http://yoursite.com/2020/04/20/hls/","excerpt":"","text":"1.首先进行nginx配置 1234567891011121314151617181920212223242526272829303132333435rtmp &#123; server &#123; listen 1935; chunk_size 4000; application hls &#123; live on; hls on; hls_path &#x2F;tmp&#x2F;hls; #视频存放目录 hls_fragment 5s; &#125; &#125;&#125; http &#123; server &#123; #视频访问地址 listen 8080; location &#x2F;hls &#123; # Serve HLS fragments types &#123; application&#x2F;vnd.apple.mpegurl m3u8; video&#x2F;mp2t ts; &#125; root &#x2F;tmp; #视频存放路径 expires -1; &#125; &#125;&#125;比如推流地址是rtmp:&#x2F;&#x2F;localhost:1935&#x2F;hls 那么访问视频地址为http::&#x2F;&#x2F;localhost:8080&#x2F;hls","categories":[{"name":"linux_private","slug":"linux-private","permalink":"http://yoursite.com/categories/linux-private/"}],"tags":[]},{"title":"Nginx与Nginx-rtmp-module搭建RTMP视频直播和点播服务器","slug":"live","date":"2020-04-20T11:50:45.000Z","updated":"2020-04-20T11:52:55.000Z","comments":true,"path":"2020/04/20/live/","link":"","permalink":"http://yoursite.com/2020/04/20/live/","excerpt":"","text":"Nginx 本身是一个非常出色的 HTTP 服务器，FFMPEG 是非常好的音视频解决方案。这两个东西通过一个 nginx 的模块 nginx-rtmp-module,组合在一起即可以搭建一个功能相对比较完善的流媒体服务器。 这个流媒体服务器可以支持 RTMP 和 HLS(Live Http Stream)1.首先我们需要下载两款软件 OBS 和 VLC2.**点播视频服务器的配置打开配置文件 nginx.conf，添加 RTMP 的配置。 123456789101112131415161718192021222324252627282930313233worker_processes 1;events &#123; worker_connections 1024;&#125;rtmp &#123; #RTMP服务 注意哦 这里的rtmp服务不是在http里面哦 是不通的协议 server &#123; listen 1935; #&#x2F;&#x2F;服务端口 chunk_size 4096; #&#x2F;&#x2F;数据传输块的大小 application vod &#123; # 这里的vod是访问路径 play &#x2F;opt&#x2F;video&#x2F;vod; #&#x2F;&#x2F;这里是要点播的视频文件存放位置。 &#125; &#125;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location &#x2F; &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; &#125;&#125; 3.打开视频播放软件选用的是 VLC file-&gt; open network stream-&gt;network如图填写我们要点播的节目地址 rtmp: //localhost/vod/girl.mp4点击 play 就可以播放了。 4.直播视频服务器的配置接着我们就在点播服务器配置文件的基础之上添加直播服务器的配置。一共 2 个位置，第一处就是给 RTMP 服务添加一个 application 这个名字可以任意起，也可以起多个名字，由于是直播我就叫做它 live 吧，如果打算弄多个频道的直播就可以 live_cctv1、live_cctv2 名字任意。第二处就是添加两个 location 字段，字段的内容请直接看文件吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263worker_processes 1;events &#123; worker_connections 1024;&#125;rtmp &#123; server &#123; listen 1935; chunk_size 4096; on_publish http:&#x2F;&#x2F;localhost&#x2F;rtmp&#x2F;auth.php;#这里的鉴权php可以指向任何脚本 下面会贴出代码 application vod &#123; play &#x2F;opt&#x2F;video&#x2F;vod; &#125; application live&#123; #第一处添加的直播字段 访问直播是需要加上端口的 live on; &#125; &#125;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location &#x2F;stat &#123; #第二处添加的location字段。 rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location &#x2F;stat.xsl &#123; #第二处添加的location字段。 root &#x2F;etc&#x2F;rtmpServer&#x2F;nginx-rtmp-module&#x2F;; #这个目录指向的是你下载好的模块路径 &#125; location &#x2F; &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; &#125;&#125;PHP 鉴权&lt;?phpif ($_POST[&#39;key&#39;] &#x3D;&#x3D; &#39;root&#39;) &#123; header(&#39;HTTP&#x2F;1.1 200 OK&#39;); header(&#39;Status: 200 OK&#39;);&#125; else &#123; header(&#39;HTTP&#x2F;1.1 403 Forbidden&#39;); header(&#39;Status: 403 Forbidden&#39;);&#125;推流地址例子rtmp:&#x2F;&#x2F;服务器 ip 地址:1935&#x2F;live&#x2F;test?user&#x3D;user&amp;pass&#x3D;pass 添加完这两处之后，重新启动 nginx 打开浏览器看看，是否有如下图显示： 刚开始 live streams 是 0 这里由于我配置过了 所以是有一个的 配置 OBSOBS-&gt;preferences-&gt; 推流设置好之后选择要推送的视频源 视频源有很多种 可以使摄像头拍摄 和本地文件我们使用本地文件进行推流选择软甲下方的视频来源下的 ➕ 添加-&gt;vlc 视频源 添加好之后选择推流 再选择步骤 3 就 ok 了 12345678910111213141516171819202122232425262728293031html 拉流&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot;&gt; &lt;title&gt;video.js&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;video.js@6.11.0&#x2F;dist&#x2F;video-js.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;video.js@6.11.0&#x2F;dist&#x2F;video.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;videojs-flash&#x2F;dist&#x2F;videojs-flash.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;videojs-contrib-hls&#x2F;dist&#x2F;videojs-contrib-hls.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;video id&#x3D;&quot;my-player&quot; class&#x3D;&quot;video-js&quot; controls&gt; &lt;source src&#x3D;&quot;rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;test&quot; type&#x3D;&quot;rtmp&#x2F;flv&quot;&gt; &lt;p class&#x3D;&quot;vjs-no-js&quot;&gt; not support &lt;&#x2F;p&gt; &lt;&#x2F;video&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var player &#x3D; videojs(&#39;my-player&#39;,&#123; width:400, heigh:200 &#125;); &lt;&#x2F;script&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"linux_private","slug":"linux-private","permalink":"http://yoursite.com/categories/linux-private/"}],"tags":[]},{"title":"nginx 安装nginx-rtmp-module模块","slug":"nginx_rtmp_module","date":"2020-04-20T11:39:10.000Z","updated":"2020-04-20T11:49:13.000Z","comments":true,"path":"2020/04/20/nginx_rtmp_module/","link":"","permalink":"http://yoursite.com/2020/04/20/nginx_rtmp_module/","excerpt":"","text":"1、首先就是先下载 nginx-rtmp-module 官方 GitHub 地址：https://github.com/arut/nginx-rtmp-module 12cd &#x2F;tmpgit clone https:&#x2F;&#x2F;github.com&#x2F;arut&#x2F;nginx-rtmp-module 2.查看NGINX 安装配置 nginx -V 123456HailundeMacBook-Pro:nginx hailun$ nginx -Vnginx version: nginx&#x2F;1.17.3built by clang 11.0.3 (clang-1103.0.32.29)built with OpenSSL 1.1.1d 10 Sep 2019TLS SNI support enabledconfigure arguments: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.17.3_1 --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.17.3_1&#x2F;bin&#x2F;nginx --with-cc-opt&#x3D;&#39;-I&#x2F;usr&#x2F;local&#x2F;opt&#x2F;pcre&#x2F;include -I&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl@1.1&#x2F;include&#39; --with-ld-opt&#x3D;&#39;-L&#x2F;usr&#x2F;local&#x2F;opt&#x2F;pcre&#x2F;lib -L&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl@1.1&#x2F;lib&#39; --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx.lock --http-client-body-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;client_body_temp --http-proxy-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;proxy_temp --http-fastcgi-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;fastcgi_temp --http-uwsgi-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;uwsgi_temp --http-scgi-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;scgi_temp --http-log-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --error-log-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --with-compat --with-debug --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-ipv6 --with-mail --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module 看到nginx的版本是1.17.3 那么我们需要下载nginx对应版本的源码 12cd &#x2F;tmpwget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.17.3 .tar.gz 3.重新编译安装nginx 并添加模块nginx-rtmp-module ```cd /nginx-1.17.3./configure –prefix=/usr/local/Cellar/nginx/1.17.3_1 –add-module=../nginx-rtmp-module –sbin-path=/usr/local/Cellar/nginx/1.17.3_1/bin/nginx –with-cc-opt=’-I/usr/local/opt/pcre/include -I/usr/local/opt/openssl@1.1/include’ –with-ld-opt=’-L/usr/local/opt/pcre/lib -L/usr/local/opt/openssl@1.1/lib’ –conf-path=/usr/local/etc/nginx/nginx.conf –pid-path=/usr/local/var/run/nginx.pid –lock-path=/usr/local/var/run/nginx.lock –http-client-body-temp-path=/usr/local/var/run/nginx/client_body_temp –http-proxy-temp-path=/usr/local/var/run/nginx/proxy_temp –http-fastcgi-temp-path=/usr/local/var/run/nginx/fastcgi_temp –http-uwsgi-temp-path=/usr/local/var/run/nginx/uwsgi_temp –http-scgi-temp-path=/usr/local/var/run/nginx/scgi_temp –http-log-path=/usr/local/var/log/nginx/access.log –error-log-path=/usr/local/var/log/nginx/error.log –with-compat –with-debug –with-http_addition_module –with-http_auth_request_module –with-http_dav_module –with-http_degradation_module –with-http_flv_module –with-http_gunzip_module –with-http_gzip_static_module –with-http_mp4_module –with-http_random_index_module –with-http_realip_module –with-http_secure_link_module –with-http_slice_module –with-http_ssl_module –with-http_stub_status_module –with-http_sub_module –with-http_v2_module –with-ipv6 –with-mail –with-mail_ssl_module –with-pcre –with-pcre-jit –with-stream –with-stream_realip_module –with-stream_ssl_module –with-stream_ssl_preread_module注意上方的–add-module=../nginx-rtmp-module 是新添加的 路径要对应好make &amp;&amp; make install","categories":[{"name":"linux_private","slug":"linux-private","permalink":"http://yoursite.com/categories/linux-private/"}],"tags":[]},{"title":"PHP常用函数","slug":"php_base_function","date":"2020-04-20T11:35:17.000Z","updated":"2020-04-20T11:36:12.000Z","comments":true,"path":"2020/04/20/php_base_function/","link":"","permalink":"http://yoursite.com/2020/04/20/php_base_function/","excerpt":"","text":"123456789101112131415161718&#x2F;** * 获取请求header * @param null $param * @return array|mixed *&#x2F;function getallheaderss($param &#x3D; null)&#123; $headers &#x3D; array(); foreach ($_SERVER as $name &#x3D;&gt; $value) &#123; if (substr($name, 0, 5) &#x3D;&#x3D; &#39;HTTP_&#39;) &#123; $headers[str_replace(&#39; &#39;, &#39;-&#39;, ucwords(strtolower(str_replace(&#39;_&#39;, &#39; &#39;, substr($name, 5)))))] &#x3D; $value; &#125; &#125; if ($param !&#x3D; null) &#123; return $headers[$param]; &#125; return $headers;&#125; 1234567891011&#x2F;** * 运行日志 * @param string $key * @param $data *&#x2F;function Logger($key, $data)&#123; $nowtime &#x3D; time(); $str &#x3D; $nowtime . &#39;|&#39; . $key . &#39;|&#39; . json_encode($data) . &quot;\\n&quot;; error_log($str, 3, &#39;&#x2F;tmp&#x2F;php_&#39; . date(&#39;Ymd&#39;, $nowtime) . &#39;.log&#39;);&#125;","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"php 常用系统函数","slug":"php_function","date":"2020-04-20T11:34:23.000Z","updated":"2020-04-20T11:34:58.000Z","comments":true,"path":"2020/04/20/php_function/","link":"","permalink":"http://yoursite.com/2020/04/20/php_function/","excerpt":"","text":"123456789foreach ($_SERVER as $name &#x3D;&gt; $value) &#123; if (substr($name, 0, 5) &#x3D;&#x3D; &#39;HTTP_&#39;) &#123; $headers[str_replace(&#39; &#39;, &#39;-&#39;, ucwords(strtolower(str_replace(&#39;_&#39;, &#39; &#39;, substr($name, 5)))))] &#x3D; $value; &#125; &#125;这里的substr($name, 0, 5)是截取字段的前五个这里的substr($name, 5)是去除前五个这里的str_replace(&#39;_&#39;, &#39; &#39;, substr($name, 5)) 是把&#39;_&#39;替换为空格strtolower 转换小写 ucwords首字母大写 1234解决跨域问题header(&quot;Access-Control-Allow-Origin:*&quot;);header(&quot;Access-Control-Allow-Methods:GET, POST, OPTIONS, DELETE&quot;);header(&quot;Access-Control-Allow-Headers:*&quot;);","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"mysql 高级操作语句","slug":"mysql01","date":"2020-04-20T11:33:19.000Z","updated":"2020-04-20T11:33:57.000Z","comments":true,"path":"2020/04/20/mysql01/","link":"","permalink":"http://yoursite.com/2020/04/20/mysql01/","excerpt":"","text":"1.同时删除关联的多张表的数据 1delete cxc_member_address,cxc_member from cxc_member left join cxc_member_address on cxc_member.userid&#x3D;cxc_member_address.userid where cxc_member.userid&#x3D;252 2.统计表里面的数据之和 1select SUM(userid) from cxc_member where userid&gt;329","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[]},{"title":"php 语法大全","slug":"php_yufa","date":"2020-04-20T11:31:51.000Z","updated":"2020-04-20T11:32:48.000Z","comments":true,"path":"2020/04/20/php_yufa/","link":"","permalink":"http://yoursite.com/2020/04/20/php_yufa/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239&#x2F;&#x2F;语法错误（syntax error）在语法分析阶段，源代码并未被执行，故不会有任何输出。&#x2F;* 【命名规则】 *&#x2F;常量名 类常量建议全大写，单词间用下划线分隔 &#x2F;&#x2F; MIN_WIDTH变量名建议用下划线方式分隔 &#x2F;&#x2F; $var_name函数名建议用驼峰命名法 &#x2F;&#x2F; varName定界符建议全大写 &#x2F;&#x2F; &lt;&lt;&lt;DING, &lt;&lt;&lt;&#39;DING&#39;文件名建议全小写和下划线、数字 &#x2F;&#x2F; func_name.php私有属性名、方法名建议加下划线 &#x2F;&#x2F; private $_name _func接口名建议加I_ &#x2F;&#x2F; interface I_Name&#x2F;* 语言结构 *&#x2F;array(), echo(), empty(), eval(), exit(), isset(), list(), print(), unset()echo, print 可省略括号。&#x2F;* 预定义常量 *&#x2F;PATH_SEPARATOR &#x2F;&#x2F;路径分隔符(Windows为分号，类Unix为冒号)DIRECTORY_SEPARATOR &#x2F;&#x2F;目录分隔符PHP_EOL &#x2F;&#x2F;当前系统的换行符PHP_VERSION &#x2F;&#x2F;PHP版本号PHP_OS &#x2F;&#x2F;PHP服务操作系统PHP_SAPI &#x2F;&#x2F;用来判断是使用命令行还是浏览器执行的，如果 PHP_SAPI&#x3D;&#x3D;&#39;cli&#39; 表示是在命令行下执行PHP_INT_MAX INT最大值，32位平台时值为2147483647PHP_INT_SIZE INT字长，32位平台时值为4（4字节）M_PI &#x2F;&#x2F;圆周率值M_E &#x2F;&#x2F;自然数&#x2F;&#x2F;PHP运行环境检测函数php_sapi_name() &#x2F;&#x2F;返回一个PHP与WEB服务器接口类型的小写字符串该函数返回值与常量PHP_SAPI一致！接口类型：SAPI(the Server API, SAPI)可能值：aolserver、apache、apache2filter、apache2handler、caudium、cgi、cgi-fcgi、cli、 continuity、embed、isapi、litespeed milter、nsapi、phttpd、pi3web、roxen、thttpd、tux、webjames&#x2F;* 大小写问题 *&#x2F;- 类名、方法名、属性名、函数名：不区分大小写- 变量名、常量名、元素下标：区分大小写&#x2F;* 可变标识符 *&#x2F;可变变量 $i &#x3D; 3; $k &#x3D; &#39;i&#39;; echo $$k; &#x2F;&#x2F;输出3可变函数 function func() &#123;echo &#39;hello!&#39;;&#125; $i &#x3D; &#39;func&#39;; $i(); &#x2F;&#x2F;输出hello可变下标 $i &#x3D; &#39;1234&#39;; $k &#x3D; 3; echo $i[$k]; &#x2F;&#x2F;输出4可变类名 class CLS&#123;public $k &#x3D; &#39;hello&#39;;&#125; $i &#x3D; &#39;CLS&#39;; $j &#x3D; new $i; echo $j-&gt;k;可变属性 class CLS&#123;public $k &#x3D; &#39;hello&#39;;&#125; $i &#x3D; &#39;k&#39;; $j &#x3D; new CLS; echo $j-&gt;$i;可变方法 class CLS&#123;public function k()&#123;echo &#39;hello&#39;;&#125;&#125; $i&#x3D;&#39;k&#39;; $j&#x3D;new CLS; $j-&gt;$i();&#x2F;* 可变变量 *&#x2F;* 用于业务逻辑判断得到某些具体信息 $var_name &#x3D; &quot;class_name&quot;; $$var_name &#x3D; &quot;PHP0913&quot;; &#x2F;&#x2F; $class_name &#x3D; &quot;PHP0913&quot;;$class_name已存入内存中 var_dump($class_name); &#x2F;&#x2F; var_dump($$var_name);&#x2F;* 变量函数 *&#x2F;get_defined_vars &#x2F;&#x2F;返回由所有已定义变量所组成的数组(包括环境变量、服务器变量和用户定义的变量)&#x2F;* unset() *&#x2F;* unset()仅删除当前变量名和引用，其值并未被删除* 引用传递中，删除一个变量及其引用，其他变量及引用均存在，且值依然存在 echo &quot;&lt;br &#x2F;&gt;&quot;; $v3 &#x3D; &#39;值&#39;; $v4 &#x3D; &amp;$v3; unset($v4); var_dump($v3, $v4);&#x2F;* 变量的最长有效期 *&#x2F;* 当前脚本的执行周期，脚本执行结束，变量即消失&#x2F;* 预定义变量&#x2F;超全局变量 *&#x2F;$GLOBALS$_COOKIE$_ENV$_FILES$_GET$_POST$_REQUEST$_SERVER$_SESSION&#x2F;* 常量定义 *&#x2F;define(常量名, 常量值, [区分大小写参数]) &#x2F;&#x2F;true表示不区分&#x2F;false表示区分大小写const 常量名 &#x3D; 常量值 &#x2F;&#x2F; 新，建议常量名可以使用特殊字符constant($name) &#x2F;&#x2F; 获取常量名 &#x2F;&#x2F; 例：echo constant(&#39;-_-&#39;);&#x2F;* 常量相关函数 *&#x2F;definedget_defined_constants&#x2F;* 预定义常量 *&#x2F;__FILE__ 所在文件的绝对路径__LINE__ 文件中的当前行号__DIR__ 文件所在目录__FUNCTION__ 函数名称__CLASS__ 类的名称__METHOD__ 类的方法名__NAMESPACE__ 当前命名空间的名称&#x2F;* 整型 *&#x2F;整型占用4字节，共4*8&#x3D;32位，最大值为2147483647，最小值为-2147483648，最小值的绝对值比最大值的大1最高为表示正负，1表示负，0表示正&#x2F;* 进制转换函数 *&#x2F;只能十进制与其他进制进行转换，只有六种转换时，参数应是字符串（即不可含八进制的“0”或十六进制的“0x”）10 dec2 bin8 oct16 hexhexdec() 十六进制转十进制 也可写hex2dec()dechex() 十进制转十六进制 也可写dec2hex()bindec() 二进制转十进制 也可写bin2dec()decbin() 十进制转二进制 也可写dex2bin()octdec() 八进制转十进制 也可写oct2dec()decoct() 十进制转八进制 也可写dec2oct()&#x2F;* 浮点数 *&#x2F;浮点数不能比较大小 ！！！几乎所有小数，在保存时都是近似值而不是精确值！最大值：+&#x2F;- 1.8E308PHP所能保存的最长小数位：14位&#x2F;* 单引号字符串 *&#x2F;单引号字符串中，只能转义反斜杠和单引号&#x2F;* 双引号字符串 *&#x2F;只解析字符串一次 ！！！eval 把字符串作为PHP代码执行大括号包裹变量，可确定变量名界限。如：&quot;aaa&#123;$bbb&#125;ccc&quot;双引号中可以将ASCII码转换为字符&quot;\\x61&quot; -&gt; a &#x2F;&#x2F; 字符串中不需0，整型中才是0x前导&quot;\\x49\\x54\\x43\\x41\\x53\\x54&quot; -&gt; ITCAST将ASCII转成字符函数chr()将字符转成ASCII函数ord()#双引号转义列表\\n 换行\\r 回车\\t 水平制表符\\\\ 反斜线\\$ 美元标记\\v 垂直制表符\\e Escape\\f 换页\\&quot; 双引号&quot;\\[0-7]&#123;1,3&#125; 符合该正则表达式序列的是一个以八进制方式来表达的字符 \\x[0-9A-Fa-f]&#123;1,2&#125; 符合该正则表达式序列的是一个以十六进制方式来表达的字符 &#x2F;* 定界符 *&#x2F;herodoc - 功能同双引号，能解析$str &#x3D; &lt;&lt;&lt;AAA字符串内容AAA;nowdoc - 功能同单引号，不能解析只在开始位置有单引号$str &#x3D; &lt;&lt;&lt;&#39;AAA&#39;字符串内容AAA;&#x2F;* 字符串的使用 *&#x2F;可将字符串当作一个字符的集合来使用，可独立访问每个字符。仅适用于单字节字符（字母、数字、半角标点符号），像中文等不可用$str &#x3D; &quot;abcd&quot;;echo $str[3]; &#x2F;&#x2F; decho $str&#123;0&#125;; &#x2F;&#x2F; a&#x2F;* 【类型操作函数】 *&#x2F;&#x2F;&#x2F;获取&#x2F;设置类型gettype($var) &#x2F;&#x2F;获取变量的数据类型settype($var, $type) &#x2F;&#x2F;设置变量的数据类型&#x2F;&#x2F;类型判断is_intis_floatis_nullis_stringis_resourceis_arrayis_boolis_object is_numeric 检测变量是否为数字或数字字符串&#x2F;&#x2F;转换成指定的数据类型boolvalfloatvalintvalstrval&#x2F;&#x2F;强制转换类型(int)(float)(string)(bool)(array)(object)(unset) &#x2F;&#x2F;转换为NULL(binary) 转换和 b前缀转换 &#x2F;&#x2F;转换成二进制var_dump 打印变量的相关信息。 显示关于一个或多个表达式的结构信息，包括表达式的类型与值。 数组将递归展开值，通过缩进显示其结构。var_export($var [,bool $return]) &#x2F;&#x2F;输出或返回一个变量的字符串表示 $return：为true，则返回变量执行后的结果print_r 打印关于变量的易于理解的信息empty 检查一个变量是否为空isset 检测变量是否存在&#x2F;* 【流程控制】 *&#x2F;&#x2F;&#x2F;if语句的替代语法if (条件判断) : 语句块;elseif (条件判断) : 语句块;else : 语句块;endif;&#x2F;&#x2F;流程控制的替代语法在嵌入HTML时常用将 &#123; 换成 : , 将 &#125; 换成 endif; 等endifendwhileendforendforeachendswitch&#x2F;* 【switch】 *&#x2F;switch (条件) &#123; case 状态值1: 语句块; [break;] case 状态值2: 语句块; [break;] case 状态值3: case 状态值4: 语句块; [break;] default: 语句块; [break;]&#125;switch是状态分支，特殊的循环先计算出状态值，再去与判断数作比较break退出流程&#x2F;* 【for循环】 *&#x2F;for (条件初始化表达式; 条件判断表达式; 条件变化表达式) &#123;循环体&#125;假设循环体被执行了N次，则条件初始化表达式被执行1次条件判断表达式被执行N+1次条件变化表达式被执行N次注意： 1. 循环变量在for语句结束后还可以继续使用，值为第一次失败的值 2. 循环变量在for循环体内可以使用 3. 任何条件表达式均可省略，但分号不能省略 a. 条件初始化表达式被省略时，循环变量被赋值为null，在与条件判断时， 进行类型转换后再比较。也可以在for语句外进行初始化。 b. 条件判断表达式被省略时，表示循环为真，进入死循环 c. 条件变化表达式被省略时，可以在循环体内完成 4. 每个表达式均可由多条语句组成，每条语句之间使用逗号分割 如果条件判断表达式由多条语句组成，都会执行，但只有最后一条语句才作为判断条件 5. for只能遍历数值型索引下标数组 数组长度函数：count() 6. 应该将可以初始化的语句均放在条件初始化表达式内，这样可以省去很多执行次数&#x2F;* 【goto】5.3+ 版本 *&#x2F;用来跳转到程序中的某一指定位置该目标位置可以用目标名称 加上冒号来标记。PHP中的goto有一定限制，只能在同一个文件和作用域中跳转， 也就是说你无法跳出一个函数或类方法，也无法跳入到另一个函数。 你也无法跳入到任何循环或者switch结构中。 常见的用法是用来跳出循环或者switch，可以代替多层的break。 可以从循环(switch)中跳出来，但不能从外部跳转进去。而函数或类方法，向外向内均不可。goto a;echo &#39;Foo&#39;;a:echo &#39;Bar&#39;;&#x2F;* 【文件加载】 *&#x2F;require &#x2F; include &#x2F; require_once &#x2F; include_once文件载入只是载入目标文件内的代码并执行，与载入的文件类型无关文件载入属于执行阶段，当执行到require等语句时，才载入该文件的代码， 编译并执行，然后回到require等语句位置继续执行下面的语句【注意】 在载入开始时，先退出PHP模式； 再载入目标文件代码，执行该代码； 结束时，再进入PHP模式。require：处理失败，产生 E_COMPILE_ERROR 错误，脚本中止。include：处理失败，产生 E_WARNING 错误，脚本继续执行。#不建议使用require_once&#x2F;include_once&#x2F;* 【相对路径】 *&#x2F;当前浏览器请求的哪个脚本，当前位置就是属于哪个脚本。.&#x2F;file 和 file 都表示当前目录下的file文件file情况（嵌套载入文件时）：如果当前目录没找到该文件就在代码文件所在目录中继续找。如果当前目录找到有该文件，则不会再在代码文件所在目录去找也不会再加载。__DIR__ 脚本文件所在目录__FILE__ 脚本文件路径include_path 加载文件查找目录 set_include_path() 设置include_path，可多个，用字符串作参数 该函数设置的path只针对该当前文件有效 该设置只针对查找未直接写文件路径方式有效 设置新的include_path会覆盖原来的 get_include_path() 获取当前include_path设置项，无参数 路径分隔符，在Windows下是分号，在Linux下是冒号 利用预定义常量 PATH_SEPARATOR 来获得当前的分隔符如果直接写文件名： 1. include_path所设置的 2. 当前目录 3. 代码所在文件的目录如果文件名前带有路径，则会直接根据路径查找，include_path直接被忽略&#x2F;* 【return】 *&#x2F;return与require结合，可返回文件的内容，return写在被载入的文件内return可以终止所在脚本的执行，作为普通脚本语句return可以返回函数的相应值&#x2F;* 【终止和延迟脚本执行】 *&#x2F;die &#x2F; exit 终止return是终止所在脚本的执行die和exit会立即终止脚本执行die(&quot;到此为止&quot;); 该函数内的字符串可被输出sleep() 延迟(单位：秒) 默认最多可延迟30秒，PHP配置可以修改 max_execution_time 例：sleep(12);usleep() 以指定的微秒数延迟执行time_sleep_until 使脚本睡眠到指定的时间为止&#x2F;* 【函数】 *&#x2F;1. 函数的声明是在编译时，故先定义再调用，定义与调用无先后关系！2. 文件只是代码的载体，程序均在内存中执行！3. 如果函数的定义在需要载入的文件内，则需要先载入该文件，否则调用出错！4. 函数的定义可以出现在其他的代码段中，此时函数不会在编译阶段被执行 只有被执行到时才会被定义！只有独立定义时才会被编译在内存中！ 如果出现在其他函数体内，也需要外层函数被调用时才被定义并生效！5. 函数名不区分大小写6. 不允许重名，包括系统函数7. 【可变函数】 函数名可以用其他变量代替 $func_name &#x3D; &quot;sayHello&quot;; $func_name(); &#x2F;&#x2F;此时调用sayHello()函数 注意：只有在调用时才能使用变量，定义时不允许！8. 变量可作为函数名调用函数，数组元素值也可以！9. 形式参数parameter，实际参数argument 可以对参数传递 null，表示该形参不想传递值 形参与实参之间既可值传递，也可引用传递。 引用传递参数，应该在定义函数时就在形式参数前加上 &amp; 符号，而此时调用函数实参必须为变量 如何选择使用哪种传递方式？ a. 是否需要保证原始数据的完整性 b. 是否需要增加效率 c. 对大数据引用传递可节省内存10. 参数默认值 a. 函数的参数默认值必须是已经确定的值，不能是变量！ 只要在调用之前定义该常量，则可以使用常量作为参数默认值 b. 函数默认值可以有多个，建议将有默认值的参数放在参数列表的最后面 这样可以在调用函数时，不赋予后面有默认值的参数值，否则会出错 c. 默认参数可以是非标量类型，比如数组、null d. 任何默认参数必须放在任何非默认参数的右侧11. 参数数量 a. 形参数量多于实参数量 报告警告级别错误，并以NULL代替 b. 实参多于形参 不报告错误，依次为形参赋值 c. 不确定参数数量 1) 一个形参都不定义，永远都是实参多于形参 2) 【可变数量参数】 func_get_args() 获取当前函数被调用时所有实参的值，返回一个所有实参值组成的数组 func_get_arg() 获取某个实参的值，通过索引值标识，e.g: func_get_arg(0) func_num_args() 获取所有实参的数量12. 【return】返回值 a. 函数只有一个返回值，可以通过返回一个数组来得到类似的结果，但可以有多条return语句 b. return语句会立即中止函数的运行，并将控制权交回调用该函数的代码行 c. 可以返回包括数组和对象的任意类型 d. 函数的返回也分值传递和引用传递（返回的是一个变量才可） 1) 默认是值传递方式 2) 引用传递方式： - 定义函数时，函数名前加上&amp; 表示该函数可以返回引用 - 调用函数时，函数名前加上&amp; 表示取得函数返回的引用 此时，函数外修改返回值，会修改函数内的该返回变量的值 - 如果函数需返回引用，则需要返回一个变量才可以 - 从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用操作符&amp; function &amp;returns_reference()&#123;return $someref;&#125; $newref &#x3D;&amp; returns_reference(); 3) 返回引用的作用&#x2F;* 【变量作用域】 *&#x2F;a. 全局变量和局部变量 1) 作用域之间不重叠，即不同作用域的变量，之间不可访问 2) 全局作用域 - 函数之外的区域 3) 局部作用域 - 函数内的区域，每个函数都是一个独立的作用域b. 超全局变量，既可以在全局也可在局部使用，仅能用系统自带的，均是数组变量。 $GLOBALS $_COOKIE $_ENV $_FILES $_GET $_POST $_REQUEST $_SERVER $_SESSIONc. $GLOBALS 1) 不能存在超全局变量，但可以有超全局的数据！ 2) 将需要的数据放到超全局变量的数组内，但统一使用$GLOBALS 3) $GLOBALS 特征 - 每个全局变量就是对应$GLOBALS内的一个元素！ 每当增加一个全局，则自动在$GLOBALS内增加一个同名元素！ 同理，每当增加元素，也会增加一个全局变量，一般在函数内增加 - 做的任何修改，也会映射到另一个，包括更新和删除 在函数内访问全局变量，只需使用$GLOBALS - 出现过的全局变量，就可以通过$GLOBALS这个数组取得 4) PHP生命周期中，定义在函数体外部的所谓全局变量，函数内部是不能直接获得的4) global关键字（不建议使用） 将局部变量声明为同名全局变量的一个&#39;引用&#39;！相当于常量的引用传递 global $var; &#x2F;&#x2F; $var &#x3D; &amp;$GLOBALS[&#39;var&#39;]; 不同于$GLOBALS！！！ global在函数产生一个指向函数外部变量的别名变量，而不是真正的函数外部变量。 $GLOBALS确确实实调用是外部的变量，函数内外会始终保持一致。 global的作用是定义全局变量，但是这个全局变量不是应用于整个网站，而是应用于当前页面，包括include或require的所有文件。d. 1) 作用域只针对变量，对常量无效 2) 被载入文件中定义的变量作用域取决于被载入的位置。 函数外被载入就是全局，函数内被载入就是局部！&#x2F;* 【变量生命周期】 *&#x2F;1. 脚本结束时，全局变量消失2. 函数执行完时，局部变量消失3. 静态变量 static关键字 静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。 静态变量仅会被初始化一次，其他局部变量每次被调用时都会被重新赋值。 static声明的静态变量的生命周期会被一直延续。&#x2F;* 【迭代和递归】 *&#x2F;迭代比递归效率高！迭代是一种思想（算法），结构和使用上如同循环！递归是一种思想（算法），将大问题拆分成小问题，逐一解决小问题以解决大问题 要求大问题和小问题的解决方案是一致的！ 递归的结构和语法体现如图函数。函数体内调用函数本身！ 递归出口：当该问题可以解决时，则不用再递归&#x2F;* 【匿名函数&#x2F;闭包函数】 *&#x2F;匿名函数，也叫闭包函数(closures)，允许临时创建一个没有指定名称的函数。1. 定义匿名函数时，不需增加函数名。2. PHP对匿名函数的管理，以一个对象的方式进行处理。3. 匿名函数应该存放到变量内。4. 匿名函数通过Closure类来实现5. 可以使用函数作为函数的参数和返回值6. 声明函数时可以使用 use($param) 来向函数中传入函数外的变量，结合变量引用来实现闭包7. 可以用变量引用函数$func &#x3D; function ($e) &#123; echo $e;&#125;; &#x2F;&#x2F;结束时，需分号结束，如同变量赋值var_dump($func); &#x2F;&#x2F;使用匿名函数$func(&#39;ITCAST&#39;); &#x2F;&#x2F;函数的调用 这不是可变函数，而是对象。Closure闭包类&#x2F;&#x2F;use语法匿名函数倾向于值的概念，可能出现在任何地方。use可以使得匿名函数使用其外部作用域的变量。非全局！use与全局的区别： use使用其外部作用域的变量function out() &#123; $v &#x3D; &quot;in out&quot;; $func &#x3D; function () use (&amp; $v) &#123; var_dump($v); &#125;&#125; use类似参数的自动传递，也支持值与引用的传递方式。&#x2F;&#x2F;作用 常作为&#39;临时函数&#39;被调用（只在某个地方被调用的函数） 例如： PHP存在一个array_map()函数，功能是针对一个函数内每个元素，去调用某个函数 操作结果(array) &#x3D; array_map(操作函数, 操作数组); $result_arr &#x3D; array_map(function ($v) &#123;return $v3&#125;, $arr);&#x2F;&#x2F;闭包用法实例function closureCreater() &#123; $x &#x3D; 1; return function($fun &#x3D; null) use(&amp;$x) &#123;&#x2F;&#x2F;按引用传值 echo &quot;&lt;br &#x2F;&gt;&quot; . $x++; $fun and $fun(); &#125;;&#125;$x &#x3D; &quot;hello world&quot;;$test &#x3D; closureCreater();$test();$test(function()&#123; echo &quot;closure test one&quot;; &#125;);$test(function()&#123; echo &quot;closure test two&quot;; &#125;);$test(function() use($x)&#123; echo &quot;&lt;br &#x2F;&gt;&quot;.$x;&#125;);&#x2F;&#x2F;将函数保存为数组元素$x &#x3D; &#39;outer param.&#39;;$arr &#x3D; array();$arr[] &#x3D; function($str)use($x)&#123; return $str.$x; &#125;;echo $arr[0](&#39;test fun in arr,&#39;);&#x2F;* 【数组】 *&#x2F;关联数组：键和值有关联，键表示值的逻辑含义。索引数组：键和值无关联，键表示值的位置。通常下标从0开始，递增元素count($var [,$mode]) &#x2F;&#x2F;统计数组元素个数 $mode可选，设为1或true时则递归统计 $var非数组，返回1；$var未初始化或等于null或空数组，返回0&#x2F;&#x2F;键名的使用整型数字键不需加引号($arr[1])字符串数字键也不需加引号($arr &#x3D; array(&#39;1&#39;&#x3D;&gt;&#39;abc&#39;); $arr[1])关联数组，字符串键需加引号($arr &#x3D; array(&#39;a&#39;&#x3D;&gt;&#39;aaa&#39;); $arr[&#39;a&#39;])关联数组，双引号中解析变量，可不加引号($arr &#x3D; array(&#39;a&#39;&#x3D;&gt;&#39;aaa&#39;); &quot;$arr[a]&quot;)&#x2F;* 【指针】 *&#x2F;current&#x2F;pos 返回当前被内部指针指向的数组单元的值，并不移动指针。key 返回数组中当前单元的键名，并不移动指针next 将数组中的内部指针向前移动一位，并返回移动后当前单元的值。先移动，再取值。prev 将数组的内部指针倒回一位，并返回移动后当前单元的值先移动，再取值。end 将数组的内部指针指向最后一个单元，并返回最后一个单元的值reset 将数组的内部指针指向第一个单元，并返回第一个数组单元的值each 返回数组中当前的键&#x2F;值对并将数组指针向前移动一步。 返回的是一个由键和值组成的长度为4的数组，下标0和key表示键，下标1和value表示值 在执行each()之后，数组指针将停留在数组中的下一个单元 或者当碰到数组结尾时停留在最后一个单元。 如果要再用 each 遍历数组，必须使用 reset()。 1. 以上指针操作函数，除了key()，若指针移出数组，则返回false。而key()移出则返回null。 2. 若指针非法，不能进行next&#x2F;prev操作，能进行reset&#x2F;end操作 3. current&#x2F;next&#x2F;prev 若遇到包含空单元（0或&quot;&quot;）也会返回false。而each不会！list 把数组中的值赋给一些变量。list()是语言结构，不是函数 仅能用于数字索引的数组并假定数字索引从0开始 &#x2F;* 可用于交换多个变量的值 *&#x2F; list($a, $b) &#x3D; array($b, $a); 例：list($drink, , $power) &#x3D; array(&#39;coffee&#39;, &#39;brown&#39;, &#39;caffeine&#39;);1. 复制数组，其指针位置也会被复制。 特例：如果数组指针非法，则拷贝的数组指针会重置，而原数组的指针不变。 【指针问题】 谁第一个进行写操作，就会开辟一个新的值空间。与变量(数组变量)值传递给谁无关。 数组函数current()被定义为写操作，故会出现问题。 foreach遍历的是数组的拷贝，当被写时，才会开辟一个新的值空间。 即，foreach循环体对原数组进行写操作时，才会出现指针问题。 如果开辟新空间时指针非法，则会初始化指针。2. 如果指针位置出现问题，则reset()初始化一下就可解决。&#x2F;* 【遍历数组】 *&#x2F;* 先找到元素，再获取键和值foreach foreach (array_expression as [$key &#x3D;&gt;] &amp; $value) 当foreach开始执行时，数组内部的指针会自动指向第一个单元。 获取元素信息后，移动指针，再执行循环体 1. foreach本身循环结构，break和continue适用于foreach 2. foreach支持循环的替代语法。 3. $value是保存元素值的变量，对其修改不会改变数组的元素值 4. $value支持元素值的引用拷贝，在$value前加上&amp;即可 5. $key不支持引用传递 6. foreach遍历的是原数组的拷贝，而在循环体对数组的操作是操作原数组 即循环体对数组的操作，对原数组生效，对遍历不生效。 先拷贝一份数组用作遍历while...list...eachwhile (list($key, $val) &#x3D; mysql_fetch_row($result)) &#x3D; each($arr) &#123; echo &quot;$key &#x3D;&gt; $val\\n&quot;;&#125;&#x2F;* 【数组函数】 *&#x2F;&#x2F;&#x2F;统计计算count 计算数组中的单元数目或对象中的属性个数array_count_values 统计数组中所有的值出现的次数array_product 计算数组中所有值的乘积array_sum 计算数组中所有值的和range 建立一个包含指定范围单元的数组&#x2F;&#x2F;获取数组内容array_chunk 将一个数组分割成多个 array array_chunk(array $input, int $size[, bool $preserve_keys]) array_filter 用回调函数过滤数组中的单元array_slice 从数组中取出一段 array array_slice($arr, $offset [,$len [,$preserve_keys]])array_keys 返回数组中所有的键名 array array_keys(array $input[, mixed $search_value[, bool $strict]] ) 如果指定了可选参数 search_value，则只返回该值的键名。否则input数组中的所有键名都会被返回。array_values 返回数组中所有的值，并建立数字索引array_merge 合并一个或多个数组 一个数组中的值附加在前一个数组的后面。 如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。 如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。 如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。 array_merge_recursive 递归地合并一个或多个数组&#x2F;&#x2F;搜索in_array 检查数组中是否存在某个值 bool in_array(mixed $needle, array $haystack[, bool $strict])array_key_exists 检查给定的键名或索引是否存在于数组中 isset()对于数组中为NULL的值不会返回TRUE，而 array_key_exists()会array_search 在数组中搜索给定的值，如果成功则返回相应的键名array_combine 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值 如果两个数组的单元数不同或者数组为空时返回FALSE。array_rand 从数组中随机取出一个或多个单元，返回键名或键名组成的数组，下标是自然排序的array_fill 用给定的值填充数组 array_fill($start, $num, $value)array_flip 交换数组中的键和值array_pad 用值将数组填补到指定长度array_reverse 返回一个单元顺序相反的数组array_unique 移除数组中重复的值array_splice 把数组中的一部分去掉并用其它值取代implode 将数组元素值用某个字符串连接成字符串explode($delimiter, $str [,$limit]) &#x2F;&#x2F;使用一个字符串分割另一个字符串 $delimiter不能为空字符串&quot;&quot;array_map 将回调函数作用到给定数组的单元上，只能处理元素值，可以处理多个数组 如果callback参数设为null，则合并多个数组为一个多维数组array_walk 对数组中的每个成员应用用户函数，只能处理一个数组，键和值均可处理，与foreach功能相同 bool array_walk ( array &amp;$array , callback $funcname [, mixed $userdata ] )&#x2F;&#x2F;栈：后进先出入栈和出栈会重新分配索引下标array_push 将一个或多个单元压入数组的末尾（入栈）array_pop 将数组最后一个单元弹出（出栈） 使用此函数后会重置(reset())array 指针。&#x2F;&#x2F;队列：先进先出队列函数会重新分配索引下标array_unshift 在数组开头插入一个或多个单元array_shift 将数组开头的单元移出数组 使用此函数后会重置(reset())array 指针。&#x2F;&#x2F;排序函数sort 对数组排序rsort 对数组逆向排序asort 对数组进行排序并保持索引关系arsort 对数组进行逆向排序并保持索引关系ksort 对数组按照键名排序krsort 对数组按照键名逆向排序usort 使用用户自定义的比较函数对数组中的值进行排序uksort 使用用户自定义的比较函数对数组中的键名进行排序uasort 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联natsort 用用“自然排序”算法对数组排序natcasesort 用“自然排序”算法对数组进行不区分大小写字母的排序array_multisort 对多个数组或多维数组进行排序shuffle 将数组打乱 引用传递参数，返回bool值。 重新赋予索引键名，删除原有键名&#x2F;&#x2F;差集array_udiff_assoc 带索引检查计算数组的差集，用回调函数比较数据array_udiff_uassoc 带索引检查计算数组的差集，用回调函数比较数据和索引array_udiff 用回调函数比较数据来计算数组的差集array_diff_assoc 带索引检查计算数组的差集array_diff_key 使用键名比较计算数组的差集array_diff_uassoc 用用户提供的回调函数做索引检查来计算数组的差集array_diff_ukey 用回调函数对键名比较计算数组的差集array_diff 计算数组的差集&#x2F;&#x2F;交集array_intersect_assoc 带索引检查计算数组的交集array_intersect_key 使用键名比较计算数组的交集array_intersect_uassoc 带索引检查计算数组的交集，用回调函数比较索引array_intersect_ukey 用回调函数比较键名来计算数组的交集array_intersect 计算数组的交集array_key_exists 用回调函数比较键名来计算数组的交集array_uintersect_assoc 带索引检查计算数组的交集，用回调函数比较数据array_uintersect 计算数组的交集，用回调函数比较数据extract($arr [,$type [,$prefix]]) 从数组中将变量导入到当前的符号表(接受结合数组$arr作为参数并将键名当作变量名，值作为变量的值)compact($var [,...]) 建立一个数组，包括变量名和它们的值(变量名成为键名而变量的内容成为该键的值)&#x2F;* 【伪类型】 *&#x2F;mixed 说明一个参数可以接受多种不同的（但并不必须是所有的）类型。number 说明一个参数可以是 integer 或者 float。callback 回调函数void void作为返回类型意味着函数的返回值是无用的。 void作为参数列表意味着函数不接受任何参数。&#x2F;* 【数据库操作】 *&#x2F;#连接认证mysql_connect 连接并认证数据库#发送SQL语句，接收执行结果mysql_query 发送SQL语句 仅对select, show, explain, describe语句执行成功返回一个资源标识符，其他语句成功返回true。执行失败均返回false。#处理结果mysql_fetch_assoc 从结果集中取得一行作为关联数组 每次只取回一条，类似each 结果集中记录指针mysql_fetch_row 从结果集中取得一行作为枚举数组mysql_fetch_array 从结果集中取得一行作为关联数组，或数字数组，或二者兼有 array mysql_fetch_array ( resource $result [, int $ result_type ] ) 可选参数result_type可选值为：MYSQL_ASSOC，MYSQL_NUM 和 MYSQL_BOTH(默认)mysql_free_result 释放结果内存#关闭链接mysql_close 关闭连接&#x2F;* 【类和对象】 *&#x2F;# 成员： 类成员：类常量、静态属性、静态方法 对象成员：非静态属性、非静态方法 # 除此外，类不能包含任何其他东西！！！# 类名、方法名、属性名均不区分大小写# $this代表本对象，self代表本类，parent代表父类# 类和函数均可被事先编译（仅作为最外层时）# 类的定义必须在单一的PHP区块内，不能被多个PHP标签分割&#x2F;&#x2F; 构造方法- 具有构造函数的类会在每次创建新对象时先调用此方法void __construct([ mixed $args [, $... ]] )- 构造方法所需参数由new实例化对象时，给类增加参数值。- 构造方法也可以被手动调用。- 5.3.3版本以前，支持于类名同名的方法作为构造方法。- 两种冲突时，__construct 优先&#x2F;&#x2F; 析构方法- 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。void __destruct( void )# 作用：释放对象所占用的资源# 调用的时机 - 脚本结束时所有资源均被释放，包括对象 - 手动删除对象时 - 保存对象的变量被赋予新值时(任何值，包括null) - 在使用exit()终止脚本运行时也会被调用&#x2F;&#x2F; 静态成员(static关键字) - 声明类成员或方法为static，就可以不实例化类而直接访问。 - 静态成员（属性或方法）均属于类，故不能通过$this或-&gt;访问。 - 静态成员是所有对象共享，属于类。 - 静态成员用类调用，非静态成员用对象调用。# 静态属性 - 静态属性不可以由对象通过-&gt;操作符来访问。 - 静态属性只能被初始化为一个字符值或一个常量，不能使用表达式。 所以你可以把静态属性初始化为整型或数组，但不能指向另一个变量或函数返回值，也不能指向一个对象。# 静态方法 - 由于静态方法不需要通过对象即可调用，所以伪变量$this在静态方法中不可用。 - 用::方式调用一个非静态方法会导致一个E_STRICT级别的错误。&#x2F;&#x2F; 访问解析操作符(::) - 可以用于访问静态成员、方法和常量，还可以用于覆盖类中的成员和方法。 - 当在类的外部访问这些静态成员、方法和常量时，必须使用类的名字。 - self 和 parent 这两个特殊的关键字是用于在类的内部对成员或方法进行访问的。&#x2F;&#x2F; 访问辨析- 对象成员，内部通过$this指定，外部通过对象名指定，均用-&gt;访问，访问属性时不需加$。 对象名-&gt;属性名 对象名-&gt;方法名() $this-&gt;属性名 $this-&gt;方法名()- 类成员，内部通过self或parent指定，外部通过类名指定，均用::访问，访问属性时需加$。 类名::$属性名 类名::方法名() self::$属性名 self::方法名()- 特殊：也可以通过对象访问类成员。（不建议） 对象名::$类属性名 $this::$类属性名 对象名::$类方法名() $this::类方法名()# 对象成员访问用-&gt;，类成员访问用::- 无论是静态方法还是非静态方法，均可通过类或对象进行访问。- 静态属性通过类访问，静态方法通过对象访问。- 只有使用对象调用非静态方法时，$this才可以使用！- 静态方法不可使用$this。- 类可以调用对象方法，但注意方法内不能有$this。- 非静态方法可以调用静态属性或静态方法，反之不可以。&#x2F;&#x2F; 类常量- 常量的值将始终保持不变。- 在定义和使用常量的时候不需要使用$符号。- 常量的值必须是一个定值，不能是变量，类属性或其它操作（如函数调用）的结果。# 定义：const 常量名 &#x3D; 常量值;- 不需要加public等访问修饰限定符- 类常量属于类，使用类访问，类名::类常量 或 self::类常量&#x2F;&#x2F; 自动加载对象- 在试图使用尚未被定义的类时自动调用 __autoload 函数- 自动加载使用到的类名文件（根据类名找相应名称的文件，故需类名与类文件名一致）- 每个需要加载类的文件都需要存在__autoload函数- 将__autoload函数写入单独的文件，每个需要用到类的文件再require该函数文件- __autoload 参数是类名function __autoload($class_name) &#123; require_once $_SERVER[&quot;DOCUMENT_ROOT&quot;] . &quot;&#x2F;class&#x2F;$class_name.php&quot;;&#125; &#x2F;&#x2F; $_SERVER[&quot;DOCUMENT_ROOT&quot;] 当前运行脚本所在的文档根目录- 可以通过类名，来推导出类所在的文件名！- 如果一个项目存在多个自动加载函数时，定义一个可以完成加载的普通函数，并在函数之前使用spl_autoload_register注册该函数。# spl_autoload_register- 注册__autoload()函数bool spl_autoload_register ([ callback $autoload_function ] )- 可以注册多个自动加载函数，先注册的先执行- 一旦注册自动加载函数，__autoload就失效。- 注册函数时，参数为函数名（注意加引号）；注册方法时，参数为数组# 注册类或对象的方法为自动加载方法时，参数需为数组：spl_autoload_register(array(__CLASS__, &#39;__autoload&#39;));__CLASS__表示当前类名，若是对象可用$this，详细见手册&#x2F;&#x2F; 序列化（串行化）# 数据传输均是字符串类型# 除了资源类型，均可序列化# 序列化在存放数据时，会存放数据本身，也会存放数据类型作用：1.在网络传输数据时；2.为了将数组或对象放在磁盘时# 序列化serialize 产生一个可存储的值的表示string serialize ( mixed $value )- 返回字符串，此字符串包含了表示value的字节流，可以存储于任何地方。- 有利于存储或传递 PHP 的值，同时不丢失其类型和结构。# 反序列化unserialize 从已存储的表示中创建PHP的值mixed unserialize ( string $str [, string $callback ] )- 对单一的已序列化的变量进行操作，将其转换回PHP的值。# 文件的读写操作- file_put_contents 将一个字符串写入文件int file_put_contents($file, $data [,$flags]) $flags：FILE_USE_INCLUDE_PATH(覆盖)，FILE_APPEND(追加)- file_get_contents 将整个文件读入一个字符串string file_get_contents($file [, bool $use_include_path [,int $offset [,int $maxlen]]])# 对象序列化- 只能序列化对象内部的数据，即非静态属性。# 需在反序列化对象之前加载类，也可以触发自动加载机制。__sleep 序列化需序列化的属性。 - 提交未提交的数据，或类似的清理操作，部分串行化对象。 - 返回一个包含对象中所有应被序列化的变量名称的数组__wakeup 反序列化时，预先准备对象需要的资源 - 重新建立数据库连接，或执行其它初始化操作 public function __sleep() &#123; return array(&#39;server&#39;, &#39;username&#39;, &#39;password&#39;, &#39;db&#39;); &#125; public function __wakeup() &#123; $this-&gt;connect(); &#125;&#x2F;&#x2F; 对象继承class 子类名 extends 父类 &#123;&#125;如果一个对象是子类的对象，那么同时也是父类的对象。单继承：一个类只能继承一个父类，不能同时继承多个类。但一个父类可以被多个子类继承。instanceof 判断某对象是否为某类的对象 对象名 instanceof 类名&#x2F;&#x2F; 访问控制public 公有的（继承链、本类、外部均可访问）protected 保护的（仅继承链、本类可访问）private 私有的（仅本类可访问）根据成员定义位置、访问位置判断。# 兼容性问题- 声明属性时，var关键字声明的默认为public权限- 声明方法时，省略访问修饰符，默认为public权限&#x2F;&#x2F; 重写 override$this代表本对象，被谁调用，就代表哪个对象。- 继承时，子类成员名于父类成员名发生冲突，则子类成员会重写父类成员。- 属性和方法均可被子类重写。- 当父类的方法或属性已经不满足子类的需求，则需要重写。- 也可能因为命名不规范导致重写。私有属性不能被重写，每个私有属性都会被记录。在记录属性名的同时，还会记录类。如果有内置函数被重写，则可调用父类方法。如调用父类构造方法parent::__construct()# 重写限制访问限制： 子类的成员的访问控制必须相等或弱于父类。方法参数限制： 参数数量必须相同，参数名可不同。# $this确定原则$this为调用该方法的对象，表示该方法的执行环境对象。 - 对象调用 - 环境的传递。如果当前调用时，不能确定$this的值(静态调用)，此时静态调用所处对象环境会传递到被调用的方法内。$this并非永远代表本对象，而是由方法的执行环境决定。# final如果父类中的方法被声明为final，则子类无法覆盖（重写）该方法。如果一个类被声明为final，则不能被继承。但加有final关键字的类依旧能被实例化！# 抽象类关键字：abstract抽象类不能直接被实例化，必须先继承该抽象类，然后再实例化子类。抽象类中至少要包含一个抽象方法。非抽象类不能包含抽象方法。如果类方法被声明为抽象的，那么其中就不能包括具体的功能实现。抽象方法不能包含大括号及方法体。继承一个抽象类的时候，子类必须实现抽象类中的所有抽象方法。 即，子类必须重写抽象父类中的所有抽象方法。另外，这些方法的可见性必须和抽象类中一样（或者更为宽松）。 即，如果抽象类中某个抽象方法被声明为protected，那么子类中实现的方法就应该声明为protected或者public，而不能定义为private。- 抽象类的子类中的普通方法执行方式和其他类相同。- 作用： 1. 继承，为扩展类，统一公共操作。 2. 限制结构（规范）。规范子类的结构。&#x2F;&#x2F; 接口关键字：interface- 对象提供的与对象交互的方式就是接口。- 使用接口可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。- 通过interface来定义一个接口，就像定义一个标准的类一样，但其中定义所有的方法都是空的。 - 接口中定义的所有属性和方法都必须是public，可省略public关键字。- 接口中也可以定义常量(const)。接口常量和类常量的使用完全相同。 可以用::访问。接口名::常量名，实现类::常量名。 它们都是定值，可以被子类或子接口使用，但不能修改。- 接口不能定义属性！# 定义接口interface 接口名 &#123; 接口内容（公共方法声明的集合）&#125;# 接口实现- 要实现一个接口，可以使用implements操作符。- 类中必须实现接口中定义的所有方法，否则会报一个fatal错误。- 如果要实现多个接口，可以用逗号来分隔多个接口的名称。- 实现多个接口时，接口中的方法不能有重名。- 接口也可以继承，通过使用extends操作符。class 类名 implements 接口名 &#123; 接口方法的实现&#125;# 注意 1. 类与抽象类之间是继承关系，类与接口之间是实现关系。 2. 类与抽象类是单继承，类与接口是多实现。 3. 接口不是类，限制类的结构。 4. 接口与接口之间是多继承。用extends关键字。 interface I_C extends I_A, I_B &#123;&#125;&#x2F;&#x2F; 静态延迟绑定self::，代表本类(当前代码所在类) 永远代表本类，因为在类编译时已经被确定。 即，子类调用父类方法，self却不代表调用的子类。static::，代表本类(调用该方法的类) 用于在继承范围内引用静态调用的类。 运行时，才确定代表的类。 static::不再被解析为定义当前方法所在的类，而是在实际运行时计算的。&#x2F;&#x2F; 对象的遍历（迭代）- 对象通过属性保存数据，故遍历对象的属性。- foreach语言结构，获得属性名和属性值。 foreach ($obj as $p_name &#x3D;&gt; $p_value) &#123;&#125;# 自定义遍历(迭代器Iterator)Iterator - 可在内部迭代自己的外部迭代器或类的接口Iterator::current — 返回当前元素Iterator::key — 返回当前元素的键Iterator::next — 向前移动到下一个元素Iterator::rewind — 返回到迭代器的第一个元素Iterator::valid — 检查当前位置是否有效# 对象的克隆&#x2F;&#x2F;对象之间的传值是[引用]传递。克隆：新对象 &#x3D; clone 旧对象 - 所有的引用属性仍然会是一个指向原来的变量的引用。 __clone()方法在对象被克隆时自动调用。注意：构造方法对应实例化(new)，克隆方法对应克隆(clone)。&#x2F;&#x2F; 单例模式#三私一公单例模式（Singleton）用于为一个类生成一个唯一的对象。最常用的地方是数据库连接。使用单例模式生成一个对象后，该对象可以被其它众多对象所使用。# 防止一个类被实例化多次class MySQLDB &#123; private static $instance &#x3D; null; &#x2F;&#x2F; 存类实例在此属性中 &#x2F;&#x2F; 构造方法声明为private，防止直接创建对象 private function __construct() &#123;&#125; public static function getInstance() &#123; if(! self::$instance instanceof static) &#123; self::$instance &#x3D; new static; &#125; return self::$instance; &#125; private function __clone() &#123;&#125; &#x2F;&#x2F; 阻止用户复制对象实例&#125;&#x2F;&#x2F; 魔术方法__construct 构造方法__destruct 析构方法__clone 克隆对象__sleep 序列化对象__wakeup 反序列化对象__autoload 自动加载，使用类但未找到时__toString 对象被当作字符串使用时__invoke 当尝试以调用函数的方式调用一个对象时# 重载 overload指动态地&quot;创建&quot;类属性和方法用户可以自由的为对象添加额外的属性，该特性就是重载。所有的重载方法都必须被声明为public。当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。重载相关魔术方法的参数都不能通过引用传递。# 属性重载- 处理不可访问的属性属性重载只能在对象中进行。# 属性重载对于静态属性无效在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被声明为static。__set 在给不可访问的属性赋值时 public void __set(string $name, mixed $value) 作用：批量管理私有属性，间接保护对象结构__get 读取不可访问的属性的值时 public mixed __get(string $name)__isset 当对不可访问的属性调用isset()或empty()时 public bool __isset(string $name)__unset 当对不可访问的属性调用unset()时 public void __unset(string $name)# 方法重载- 处理不可访问的方法__call 当调用一个不可访问的非静态方法（如未定义，或者不可见）时自动被调用 public mixed __call(string $name, array $arguments)__callStatic 当在调用一个不可访问的静态方法（如未定义，或者不可见）时自动被调用 public static mixed __callStatic(string $name, array $arguments)# $name参数是要调用的方法名称。$arguments参数是一个数组，包含着要传递给方法的参数。&#x2F;&#x2F; 类型约束函数的参数可以指定只能为对象或数组限定为对象则在形参前加类名，限定为数组则在形参前加array类型约束允许NULL值类型约束不只是用在类的成员方法里，也能使用在函数里。 &#x2F;&#x2F; 三大特性封装：隐藏内部是吸纳，仅开发接口。继承：一个对象的成员被另一个对象所使用。语法上体现为代码的共用。多态：多种形态。&#x2F;&#x2F; 类与对象·关键字this 代表本对象public 公有的（继承链、本类、外部均可访问）protected 保护的（仅继承链、本类可访问）private 私有的（仅本类可访问）parent:: 代表父类self:: 代表本类(当前代码所在类)static:: 代表本类(调用该方法的类)static 静态成员（属性、方法），所有对象均可使用，外部也可直接使用或修改，静态方法不可访问非静态成员final 方法用final不可被子类重载，类用final不可被继承（方法、类）const 类常量（属性）abstract 抽象类interface 接口extends 类继承(子接口继承接口、其他普通类继承)implements 接口实现（类实现接口、抽象类实现借口）（对接口的实现和继承均可有多个）Iterator 内置接口（迭代）clone 克隆instance 实例instanceof 某对象是否属于某类&#x2F;* 【类与对象相关函数】 *&#x2F;class_alias([$original [,$alias]]) 给类取别名class_exists($class [,$autoload]) 检查类是否已定义interface_exists($interface [,$autoload]) 检查接口是否已被定义method_exists($obj, $method)检查类的方法是否存在property_exists($class, $property) 检查对象或类是否具有该属性get_declared_classes(void) 返回由已定义类的名字所组成的数组get_declared_interfaces(void) 返回一个数组包含所有已声明的接口get_class([$obj]) 返回对象的类名get_parent_class([$obj]) 返回对象或类的父类名get_class_methods($class) 返回由类的方法名组成的数组get_object_vars($obj) 返回由对象属性组成的关联数组get_class_vars($class) 返回由类的默认属性组成的数组is_a($obj, $class) 如果对象属于该类或该类是此对象的父类则返回TRUEis_subclass_of($obj, $class) 如果此对象是该类的子类，则返回TRUEget_object_vars($obj) 返回由对象属性组成的关联数组&#x2F;&#x2F; 常用类# PHP手册 -&gt; 预定义类Closure 闭包类，匿名函数对象的final类stdClass 标准类，通常用于对象类保存集合数据__PHP_Incomplete_Class 不完整类，当只有对象而没有找到类时，则该对象被认为是该类的对象Exception 异常类PDO 数据对象类&#x2F;&#x2F; 魔术常量__DIR__ 文件所在的目录__LINE__ 文件中的当前行号 __FILE__ 文件的完整路径（绝对路径）和文件名__CLASS__ 类的名称__METHOD__ 类的方法名，包含类名和方法名__FUNCTION__ 函数名称，用在方法内只表示方法名&#x2F;&#x2F; 反射机制 Reflection作用：1. 获取结构信息 2. 代理执行ReflectionClass 报告一个类的有关信息ReflectionMethod 报告一个方法的有关信息ReflectionClass::export 输出类结构报告# 代理执行实例化 ReflectionFunction 类的对象 $f &#x3D; new ReflectionFunction(&#39;func&#39;); &#x2F;&#x2F; func为函数func($p) $f-&gt;invoke(&#39;param&#39;);&#x2F;* 页面跳转 *&#x2F;&#x2F;&#x2F; PHPheader(&#39;Loacation: url&#39;)header()执行完毕后，后面的代码也会继续执行，故需在该语句后加die结束无法给出提示，直接跳转&#x2F;&#x2F; JS方法location.href &#x3D; url&#x2F;&#x2F; HTML&lt;meta http-equiv&#x3D;&quot;Refresh&quot; content&#x3D;&quot;表示时间的数值; url&#x3D;要跳转的URI&quot;&gt; &#x2F;* 【Cookie】 *&#x2F;cookie是一种在远程浏览器端储存数据并以此来跟踪和识别用户的机制。cookie是HTTP标头的一部分，因此setcookie()函数必须在其它信息被输出到浏览器前调用，这和对header()函数的限制类似。可以使用输出缓冲函数来延迟脚本的输出，直到按需要设置好了所有的cookie或者其它HTTP标头。&#x2F;&#x2F; 新增setcookie 新增一条cookie信息setcookie($name [,$value [,$expire [,$path [,$domain [,$secure [,$httponly]]]]]])#注意：setcookie()函数前不能有输出！除非开启ob缓存！# 参数说明$name - cookie的识别名称 使用$_COOKIE[&#39;name&#39;]抵用名为name的cookie$value - cookie值，可以为数值或字符串，此值保存在客户端，不要用来保存敏感数据 假定$name参数的值为&#39;name&#39;，则$_COOKIE[&#39;name&#39;]就可取得该$value值$expire - cookie的生存期限（Unix时间戳，秒数） 如果$expire参数的值为time()+60*60*24*7则可设定cookie在一周后失效。如果未设定该参数，则会话后立即失效。$path - cookie在服务器端的指定路径。当设定该值时，服务器中只有指定路径下的网页或程序可以存取该cookie。 如果该参数值为&#39;&#x2F;&#39;，则cookie在整个domain内有效。 如果设为&#39;&#x2F;foo&#x2F;&#39;，则cookie就在domain下的&#x2F;foo&#x2F;目录及其子目录内有效。 默认值为设定cookie的当前目录及其子目录。$domain - 指定此cookie所属服务器的网址名称，预设是建立此cookie服务器的网址。 要是cookie能在如abc.com域名下的所有子域都有效，则该参赛应设为&#39;.abc.com&#39;。$secure - 指明cookie是否仅通过安全的HTTPS连接传送中的cookie的安全识别常数，如果设定该值则代表只有在某种情况下才能在客户端与服务端之间传递。 当设成true时，cookie仅在安全的连接中被设置。默认值为false。&#x2F;&#x2F; 读取- 浏览器请求时会携带当前域名下的所有cookie信息到服务器。- 任何从客户端发送的cookie都会被自动存入$_COOKIE全局数组。- 如果希望对一个cookie变量设置多个值，则需在cookie的名称后加[]符号。即以数组形态保存多条数据到同一变量。 &#x2F;&#x2F;设置为$_COOKIE[&#39;user&#39;][&#39;name&#39;]，注意user[name]的name没有引号 setcookie(&#39;user[name]&#39;, &#39;shocker&#39;);- $_COOKIE也可以为索引数组&#x2F;&#x2F; 删除方法1：将其值设置为空字符串 setcookie(&#39;user[name]&#39;, &#39;&#39;);方法2：将目标cookie设为“已过期”状态。 &#x2F;&#x2F;将cookie的生存时间设置为过期，则生存期限与浏览器一样，当浏览器关闭时就会被删除。 setcookie(&#39;usr[name]&#39;, &#39;&#39;, time()-1);# 注意：1. cookie只能保存字符串数据2. $_COOKIE只用于接收cookie数据，不用于设置或管理cookie数据。 对$_COOKIE进行操作不会影响cookie数据。 $_COOKIE只会保存浏览器在请求时所携带的cookie数据。3. cookie生命周期： 临时cookie：浏览器关闭时被删除 持久cookie：$expire参数为时间戳，表示失效时间。4. 有效目录 cookie只在指定的目录有效。默认是当前目录及其子目录。 子目录的cookie在其父目录或同级目录不可获取。5. cookie区分域名 默认是当前域名及其子域名有效。6. js中通过document.cookie获得，类型为字符串7. 浏览器对COOKIE总数没有限制，但对每个域名的COOKIE数量和每个COOKIE的大小有限，而且不同浏览器的限制不同。&#x2F;* 【session】 *&#x2F;1. 开启session机制 session_start() 注意：session_start()函数前不能有输出！除非开启ob缓存。2. 操作数据 对$_SESSION数组进行操作3. 浏览器端保存SessionID，默认为当前域名下的所有目录及其子目录生效。即默认设置cookie的path值为&#39;&#x2F;&#39;4. 服务器保存session数据 默认保存方式：每个会话都会生成一个session数据文件，文件名为：sess_加SessionID5. session可以存储除了资源以外的任何类型数据。 数据被序列化后再保存到文件中。6. $_SESSION的元素下标不能为整型！ 因为只对元素值进行序列化。 元素内的数组下标无此要求。7. 生存周期 默认是浏览器关闭 因为浏览器保存的cookie变量SessionID是临时的 但是服务器端的session数据文件不一定消失（需要等待session的垃圾回收机制来处理） 可以延长cookie中PHPSESSID变量的生命周期。（不推荐） php.ini配置session.gc_maxlifetime8. 删除数据 $_SESSION变量在脚本结束时依然会消失。开启session机制时会造出$_SESSION变量。 $_SESSION与保存session数据的文件是两个空间。 unset($_SESSION[&#39;key&#39;])只是删除数组内的该元素，不会立即相应到保存session数据的文件上。 等到脚本结束，才会将$_SESSION的数据写入到该文件中。 session_destroy() 销毁保存session数据的文件，也不会对该文件写入内容。 并不删除$_SESSION变量，unset或脚本结束才会删除该变量。 如何完全删除一个session？需删除3部分 unset($_SESSION); 删除$_SESSION变量后，数据文件并未被改动。如果单独使用unset，则需先置空$_SESSION &#x3D; array() session_destroy(); setcookie(&#39;PHPSESSID&#39;, &#39;&#39;, time()-1); &#x2F;&#x2F;保险做法是将其生命周期失效 整个脚本周期内，只对数据文件读一次、写一次。&#x2F;&#x2F; 重写session的存储机制# session存储方式session.save_handler &#x3D; user|files|memcache# 因数据文件过多导致的问题，可通过分子目录保存进行解决PHP配置文件下session.save_path选项，并需手动创建数据存放目录。在该配置选项前加层级。分布子目录的原则，利用会话ID的相应字母来分配子目录。仍需手动创建子目录。session.save_path &#x3D; &quot;2; F:&#x2F;PHPJob&#x2F;Temp&quot;# 多服务器数据共享问题# 数据存储操作： 初始化$open、释放资源$close、读$read、写$write、销毁存储介质$destroy(调用session_destroy时触发该操作)、垃圾回收$gc# 会话ID的长度可变。不同的设置方式导致不同长度的会话ID。session.hash_function 允许用户指定生成会话ID的散列算法。 &#39;0&#39; 表示MD5（128 位），&#39;1&#39; 表示SHA-1（160 位）。session.hash_bits_per_character 允许用户定义将二进制散列数据转换为可读的格式时每个字符存放多少个比特。 可能值为 &#39;4&#39;（0-9，a-f），&#39;5&#39;（0-9，a-v），以及 &#39;6&#39;（0-9，a-z，A-Z，&quot;-&quot;，&quot;,&quot;）。 总hash长度为128bit，会话ID长度为128&#x2F;可能值，4-&gt;32, 5-&gt;26, 6-&gt;22# 自定义数据存储操作方法# 注意：不用关心PHP如何序列化、反序列化、如何得到数据和写入数据，只做与数据存储相关的操作session_set_save_handler 设置用户自定义的会话数据存储函数 bool session_set_save_handler(callable $open, callable $close, callable $read, callable $write, callable $destroy, callable $gc)执行顺序：open, close, read, write, destroy, gc# 先设置处理器，再开启会话# 常用函数session_start 开启或恢复会话机制session_id 获取或设置当前会话IDsession_destroy 销毁当前会话的所有数据（销毁数据文件）session_name 获取或设置当前会话名称（cookie变量名，默认为PHPSESSID）session_save_path 获取或设置当前会话数据文件保存路径session_set_save_handler 设置用户自定义的会话数据存储函数session_unset 释放所有会话变量(清空$_SESSION数组元素)session_encode 将当前会话数据编码为一个字符串session_decode 将字符串解译为会话数据session_write_close 写入会话数据并关闭会话session_register_shutdown 关闭会话session_set_cookie_params 设置会话cookie变量，必须在session_start()前使用。 session_set_cookie_params(0,&quot;&#x2F;webapp&#x2F;&quot;); &#x2F;&#x2F;设置session生存时间session_get_cookie_params 获取会话cookie变量。返回包含当前会话cookie信息的数组# 配置php.iniini_set($varname, $newvalue); &#x2F;&#x2F;该函数的配置只对当前脚本生效 &#x2F;&#x2F;并非所有php.ini设置均可用该函数设置ini_get($varname) &#x2F;&#x2F;获取某配置项信息ini_get_all([str $extension]) &#x2F;&#x2F;返回所有配置项信息的数组# session扩展配置session.name 指定会话名以用作cookie的名字。只能由字母数字组成，默认为PHPSESSID。session.save_path 定义了传递给存储处理器的参数。 如果选择了默认的files文件处理器，则此值是创建文件的路径。默认为&#x2F;tmp。 可选的N参数来决定会话文件分布的目录深度。 要使用N参数，必须在使用前先创建好这些目录。在ext&#x2F;session目录下有个小的shell脚本名叫mod_files.sh可以用来做这件事。 如果使用了N参数并且N大于0，那么将不会执行自动垃圾回收。session.save_handler 定义了来存储和获取与会话关联的数据的处理器的名字。默认为files。 如果用户自定义存储器，则该值改为user。 ini_set(&#39;session.save_handler&#39;, &#39;user&#39;);&#x2F;&#x2F;此设置只针对当前脚本生效。session.auto_start 指定会话模块是否在请求开始时自动启动一个会话。默认为 0（不启动）。session.gc_probability与session.gc_divisor合起来定义了在每个会话初始化时启动gc（garbage collection 垃圾回收）进程的概率。此概率用 gc_probability&#x2F;gc_divisor 计算得来。例如 1&#x2F;100 意味着在每个请求中有 1% 的概率启动gc进程。session.gc_divisor默认为100。session.gc_probability默认为1。&#x2F;* 【图片生成与处理】 *&#x2F;GD库&#x2F;&#x2F; 画布生成# 新建画布imagecreate 新建一个基于调色板的图像 resource imagecreate(int $x_size, int $y_size)imagecreatetruecolor 新建一个真彩色图像# 基于已有文件或URL创建画布imagecreatefromgd2 从GD2文件或URL新建一图像imagecreatefromgd2part 从给定的GD2文件或URL中的部分新建一图像imagecreatefromgd 从GD文件或URL新建一图像imagecreatefromgif 由文件或URL创建一个新图象imagecreatefromjpeg 由文件或URL创建一个新图象imagecreatefrompng 由文件或URL创建一个新图象imagecreatefromstring 从字符串中的图像流新建一图像imagecreatefromwbmp 由文件或URL创建一个新图象imagecreatefromxbm 由文件或URL创建一个新图象imagecreatefromxpm 由文件或URL创建一个新图象&#x2F;&#x2F; 颜色分配imagecolorallocate 为一幅图像分配颜色 int imagecolorallocate(resource $image, int $red, int $green, int $blue)imagecolorallocatealpha 为一幅图像分配颜色 + alphaimagecolordeallocate 取消图像颜色的分配imagecolortransparent 将某个颜色定义为透明色imagecolorat 取得某像素的颜色索引值imagecolorclosest 取得与指定的颜色最接近的颜色的索引值imagecolorclosestalpha 取得与指定的颜色加透明度最接近的颜色imagecolorclosesthwb 取得与给定颜色最接近的色度的黑白色的索引imagecolorexact 取得指定颜色的索引值imagecolorexactalpha 取得指定的颜色加透明度的索引值imagecolormatch 使一个图像中调色板版本的颜色与真彩色版本更能匹配imagecolorresolve 取得指定颜色的索引值或有可能得到的最接近的替代值imagecolorresolvealpha 取得指定颜色 + alpha 的索引值或有可能得到的最接近的替代值imagecolorset 给指定调色板索引设定颜色imagecolorsforindex 取得某索引的颜色imagecolorstotal 取得一幅图像的调色板中颜色的数目&#x2F;&#x2F; 区域填充imagefill 区域填充 bool imagefill(resource $image, int $x, int $y, int $color)imagefilledarc 画一椭圆弧且填充imagefilledellipse 画一椭圆并填充imagefilledpolygon 画一多边形并填充imagefilledrectangle 画一矩形并填充imagefilltoborder 区域填充到指定颜色的边界为止imagesettile 设定用于填充的贴图&#x2F;&#x2F; 图形创建imagearc 画椭圆弧imagechar 水平地画一个字符imagecharup 垂直地画一个字符imagedashedline 画一虚线imageellipse 画一个椭圆imageline 画一条线段imagepolygon 画一个多边形imagerectangle 画一个矩形imagesetpixel 画一个单一像素imagesx 取得图像宽度imagesy 取得图像高度&#x2F;&#x2F; 画笔设置imagesetbrush 设定画线用的画笔图像imagesetstyle 设定画线的风格imagesetthickness 设定画线的宽度&#x2F;&#x2F; 图形拷贝imagecopy 拷贝图像的一部分imagecopymerge 拷贝并合并图像的一部分imagecopymergegray 用灰度拷贝并合并图像的一部分imagecopyresampled 重采样拷贝部分图像并调整大小imagecopyresized 拷贝部分图像并调整大小&#x2F;&#x2F; 字符创建imagestring 水平地画一行字符串imagestringup 垂直地画一行字符串imagepsslantfont 倾斜某字体imagefontheight 取得字体高度imagefontwidth 取得字体宽度imagettfbbox 取得使用 TrueType 字体的文本的范围imageloadfont 载入一新字体imagepsencodefont 改变字体中的字符编码矢量imagepsextendfont 扩充或精简字体&#x2F;&#x2F; 导出画布为图片imagegif 以GIF格式将图像输出到浏览器或文件imagepng 以PNG格式将图像输出到浏览器或文件imagejpeg 以JPEG格式将图像输出到浏览器或文件imagewbmp 以WBMP格式将图像输出到浏览器或文件通过header()发送 &quot;Content-type: image&#x2F;图片格式&quot; 可以使PHP脚本直接输出图像。 header(&quot;Content-type: image&#x2F;gif&quot;); imagegif($im);imagegd 将 GD 图像输出到浏览器或文件imagegd2 将 GD2 图像输出到浏览器或文件&#x2F;&#x2F; 释放画布资源imagedestroy 销毁图像&#x2F;&#x2F; 图像信息image_type_to_extension 取得图像类型的文件后缀getimagesize 取得图像大小imagesx 取得图像宽度imagesy 取得图像高度imageistruecolor 检查图像是否为真彩色图像imagetypes 返回当前 PHP 版本所支持的图像类型&#x2F;&#x2F; 图像设置imagerotate 用给定角度旋转图像imagealphablending 设定图像的混色模式imageantialias 是否使用抗锯齿（antialias）功能imagefilter 对图像使用过滤器imagegammacorrect 对 GD 图像应用 gamma 修正imageinterlace 激活或禁止隔行扫描&#x2F;* 【缩略图】【水印】 *&#x2F;imagecopyresampled 重采样拷贝部分图像并调整大小 bool imagecopyresampled ( resource $dst_image , resource $src_image , int $dst_x , int $dst_y , int $src_x , int $src_y , int $dst_w , int $dst_h , int $src_w , int $src_h )imagecopymerge 拷贝并合并图像的一部分 bool imagecopymerge ( resource $dst_im , resource $src_im , int $dst_x , int $dst_y , int $src_x , int $src_y , int $src_w , int $src_h , int $pct )getimagesize 取得图像大小 array getimagesize ( string $filename [, array &amp;$imageinfo ] )&#x2F;* 【URL函数】 *&#x2F;get_headers — 取得服务器响应一个 HTTP 请求所发送的所有标头get_meta_tags — 从一个文件中提取所有的 meta 标签 content 属性，返回一个数组http_build_query — 生成 URL-encode 之后的请求字符串urldecode — 解码已编码的URL字符串urlencode — 编码URL字符串parse_url — 解析URL，返回其组成部分 &#39;http:&#x2F;&#x2F;username:password@hostname&#x2F;path?arg&#x3D;value#anchor&#39; scheme(如http), host, port, user, pass, path, query(在问号?之后), fragment(在散列符号#之后)&#x2F;&#x2F;编码可用于交换多个变量$a &#x3D; &#39;中国&#39;;$b &#x3D; &#39;四川&#39;;$a &#x3D; urlencode($a);$b &#x3D; urlencode($b);$a &#x3D; $a.&#39;&amp;&#39;.$b;$b &#x3D; explode(&#39;&amp;&#39;, $a);$a &#x3D; urldecode($b[1]);$b &#x3D; urldecode($b[0]);echo $a, $b;&#x2F;&#x2F;list()函数用于交换变量list($a, $b) &#x3D; array($b, $a);&#x2F;* 【文件、目录】 *&#x2F;dirname($path) 返回路径中的目录部分basename($path [,$suffix]) 返回路径中的文件名部分pathinfo($path [,$options]) 返回文件路径的信息(数组元素：dirname,basename,extension)realpath($path) 返回规范化的绝对路径名copy($source, $dest) 拷贝文件unlink($file) 删除文件rename($old, $new) 重命名或移动一个文件或目录mkdir($path [,$mode [,$recursive]]) 新建目录 $mode表示权限，默认0777 $recursive表示可创建多级目录，默认falsermdir($dir) 删除目录(目录必须为空，且具有权限)file_exists($file) 检查文件或目录是否存在is_file($file) 判断文件是否存在且为正常的文件is_dir($file) 判断文件名是否存在且为目录is_readable($file) 判断文件或目录是否可读is_writable($file) 判断文件或目录是否可写is_executable($file) 判断给定文件名是否可执行is_link($file) 判断给定文件名是否为一个符号连接tmpfile(void) 建立一个临时文件tempnam($dir, $prefix) 在指定目录中建立一个具有唯一文件名的文件file($file) 把整个文件读入一个数组中fopen($filename, $mode [,$use_include_path]) $mode参数：(加入&#39;b&#39;标记解决移植性) &#39;r&#39; 只读方式打开，将文件指针指向文件头。 &#39;r+&#39; 读写方式打开，将文件指针指向文件头。 &#39;w&#39; 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 &#39;w+&#39; 读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 &#39;a&#39; 写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 &#39;a+&#39; 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 &#39;x&#39; 创建并以写入方式打开，将文件指针指向文件头。 &#39;x+&#39; 创建并以读写方式打开，将文件指针指向文件头。fclose($handle) 关闭一个已打开的文件指针fread($handle, $length) 读取文件（可安全用于二进制文件）fwrite($handle, $string [,$length]) 写入文件（可安全用于二进制文件）rewind($handle) 倒回文件指针的位置ftell($handle) 返回文件指针读&#x2F;写的位置fseek($handle, $offset [,$whence]) 在文件指针中定位feof($handle) 测试文件指针是否到了文件结束的位置fgets 从文件指针中读取一行fgetss 从文件指针中读取一行并过滤掉HTML标记flock($handle, $opt) 轻便的咨询文件锁定 $opt：LOCK_SH 取得共享锁定（读取的程序）；LOCK_EX 取得独占锁定（写入的程序）；LOCK_UN 释放锁定（无论共享或独占）readfile($file) 读入一个文件并写入到输出缓冲fflush($handle) 将缓冲内容输出到文件touch($file [,$time [,$atime]]) 设定文件的访问和修改时间fileatime 取得文件的上次访问时间filectime 取得文件的inode修改时间filegroup 取得文件的组fileinode 取得文件的inodefilemtime 取得文件修改时间fileowner 取得文件的所有者fileperms 取得文件的权限filesize 取得文件大小filetype 取得文件类型&#x2F;* fileinfo *&#x2F; 获取&#x2F;设置文件信息#扩展Fileinfo，配置php.ini#extension&#x3D;php_fileinfo.dllfinfo_open([$opt]) &#x2F;&#x2F;创建一个文件信息资源finfo_file($finfo, $file [,$opt]) &#x2F;&#x2F;获取文件信息finfo_set_flags($finfo, $opt) &#x2F;&#x2F;设置文件信息项finfo_close($finfo) &#x2F;&#x2F;关闭文件信息资源mime_content_type($file) &#x2F;&#x2F;获取文件的MIME类型$opt参数选项：FILEINFO_MIME_ENCODING 文件编码类型FILEINFO_MIME_TYPE 文件MIME类型&#x2F;&#x2F;目录chdir($dir) 改变当前目录chroot($dir) 将当前目录改变为当前进程的根目录closedir($handle) 关闭目录句柄dir($dir) 返回一个目录的实例对象getcwd() 取得当前工作目录opendir($path) 打开目录句柄readdir($handle) 从目录句柄中读取条目rewinddir($handle) 倒回目录句柄scandir($dir [,$order]) 列出指定路径中的文件和目录glob($pattern [,$flags]) 寻找与模式匹配的文件路径 $flags： GLOB_MARK - 在每个返回的项目中加一个斜线 GLOB_NOSORT - 按照文件在目录中出现的原始顺序返回（不排序） GLOB_NOCHECK - 如果没有文件匹配则返回用于搜索的模式 GLOB_NOESCAPE - 反斜线不转义元字符 GLOB_BRACE - 扩充 &#123;a,b,c&#125; 来匹配 &#39;a&#39;，&#39;b&#39; 或 &#39;c&#39; GLOB_ONLYDIR - 仅返回与模式匹配的目录项 查找多种后缀名文件：glob(&#39;*.&#123;php,txt&#125;&#39;, GLOB_BRACE);&#x2F;* 解压缩 *&#x2F;&#x2F;&#x2F;新建ZipArchive对象$zip &#x3D; new ZipArchive;&#x2F;&#x2F;打开ZIP文件$zip-&gt;open($file [,$flags]); $flags： ZIPARCHIVE::OVERWRITE 覆盖(不存在会自动创建) ZIPARCHIVE::CREATE 添加(不存在会自动创建) ZIPARCHIVE::EXCL ZIPARCHIVE::CHECKCONS&#x2F;&#x2F;关闭正在处理的ZIP文件&#x2F;&#x2F;解压缩ZIP文件$zip-&gt;extractTo($dest, [$entries]); $dest：解压到的文件夹，$entries：解压的条目&#x2F;&#x2F;添加文件到ZIP文件$zip-&gt;addFile($file, [$newname]); $newname可以为&quot;dir&#x2F;file&quot;，这样可以将文件添加到压缩文件中的某个目录下。其他函数也如此。&#x2F;&#x2F;添加文件到ZIP文件，而内容来自字符串$zip-&gt;addFromString($file, $str);&#x2F;&#x2F;添加空文件夹到ZIP文件$zip-&gt;addEmptyDir($dir);&#x2F;&#x2F;通过索引删除ZIP中的文件或文件夹$zip-&gt;deleteIndex($index);&#x2F;&#x2F;通过名称删除ZIP中的文件或文件夹$zip-&gt;deleteName($name);&#x2F;&#x2F;设置ZIP文件注释$zip-&gt;setArchiveComment($str);&#x2F;&#x2F;获取ZIP文件注释$zip-&gt;getArchiveComment();&#x2F;&#x2F;通过索引获取文件内容$zip-&gt;getFromIndex($index);&#x2F;&#x2F;通过名称获取文件内容$zip-&gt;getFromName($name);&#x2F;&#x2F;获取索引文件的文件名称$zip-&gt;getNameIndex($index);&#x2F;&#x2F;通过索引重命名文件$zip-&gt;renameIndex($index, $newname);&#x2F;&#x2F;通过名称重命名文件$zip-&gt;renameName($name, $newname);&#x2F;&#x2F;若将文件夹内容打包成ZIP文件，需循环文件夹的所有目录及文件function addFileToZip($path, $zip) &#123; &#x2F;&#x2F;打开当前文件夹$path $handle &#x3D; opendir($path); &#x2F;&#x2F;循环读取子文件夹及文件 &#x2F;&#x2F;为防止文件名本身可被转换为false的情况(比如为&quot;0&quot;)，则需用不全等!&#x3D;&#x3D; while ($file &#x3D; readdir($handle) !&#x3D;&#x3D; false) &#123; &#x2F;&#x2F;过滤假文件夹 if ($file !&#x3D; &#39;.&#39; &amp;&amp; $file !&#x3D; &#39;..&#39;) &#123; &#x2F;&#x2F;对于子文件夹则递归调用本函数 if (is_dir($path . &#39;&#x2F;&#39; . $file)) &#123; addFileToZip($path.&#39;&#x2F;&#39;.$file, $zip); &#125; else &#123; &#x2F;&#x2F;将文件添加到ZIP对象 $zip-&gt;addFile($path . &#39;&#x2F;&#39; . $file); &#125; &#125; &#125; &#x2F;&#x2F;关闭文件夹$path closedir($path);&#125;&#x2F;&#x2F; ----- END 解压缩 ----- &#x2F;&#x2F;&#x2F;* 【文件上传】 *&#x2F;enctype&#x3D;&quot;multipart&#x2F;form-data&quot; &#x2F;&#x2F;FORM标签必须的属性$_FILES 上传文件信息数组变量error 上传错误信息 0 无错误 1 文件大小超过php.ini配置 1) upload_max_filesize 允许上传的最大文件大小 2) post_max_size 最大的POST数据大小 3) memory_limit 每个脚本能够使用的最大内存数量(默认128MB) 2 文件大小超过浏览器表单配置 MAX_FILE_SIZE 表示表单数据最大文件大小，该元素需在文件上传域之前。(默认2M) &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;MAX_FILE_SIZE&quot; value&#x3D;&quot;102400&quot;&gt; 3 文件只有部分被上传 4 文件没有被上传 6,7 临时文件写入时失败 6 找不到临时文件 7 文件写入失败name 文件名type 文件类型tmp_name 上传文件临时路径size 文件大小move_uploaded_file($path, $newpath); &#x2F;&#x2F;将上传的文件移动到新位置is_uploaded_file($file) &#x2F;&#x2F;判断是否为POST上传的文件&#x2F;&#x2F;多文件上传&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;updfile[]&quot; &#x2F;&gt; &#x2F;&#x2F;HTML中以数组提交$_FILES[&#39;updfile&#39;][&#39;tmp_name&#39;][0] &#x2F;&#x2F;服务器端可访问第一个文件的临时路径，其他属性类似&#x2F;&#x2F;php.ini配置file_uploads &#x3D; On 是否允许HTTP上传文件upload_max_filesize 上传文件大小限制，默认为2Mpost_max_size post方式表单数据总大小限制，默认为8Mupload_tmp_dir 上传文件临时目录，默认是系统临时目录 需设置上传文件临时目录，给其最小权限GET方式的最大传输量为2K&#x2F;* 【批量提交】 *&#x2F;FORM表单中的name值可用名称加中括号的形式，在$_POST获取表单数据时，可多项提交形成数组。比如多文件上传file，复选框提交checkbox等。&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;id[]&quot; value&#x3D;&quot;值1&quot; &#x2F;&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;id[]&quot; value&#x3D;&quot;值2&quot; &#x2F;&gt;$id &#x3D; $_POST[&#39;id&#39;]; &#x2F;&#x2F;则可获得全部被选中的复选框值，形成索引数组如果name值为：&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;id[one]&quot; value&#x3D;&quot;值1&quot; &#x2F;&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;id[two]&quot; value&#x3D;&quot;值2&quot; &#x2F;&gt;$id &#x3D; $_POST[&#39;id&#39;]; &#x2F;&#x2F;则可获取所有name为id[...]的值，形成管理数组&#x2F;* iconv *&#x2F;&#x2F;&#x2F;php.ini配置iconv[iconv];iconv.input_encoding &#x3D; ISO-8859-1;iconv.output_encoding &#x3D; ISO-8859-1;iconv.internal_encoding &#x3D; ISO-8859-1iconv_set_encoding($type, $charset); $type：input_encoding，output_encoding，internal_encodingiconv_get_encoding([$type &#x3D; &quot;all&quot;]) $type：all，input_encoding，output_encoding，internal_encodingiconv($in_charset, $out_charset, $str) &#x2F;&#x2F;将字符串转换为目标编码指定编码，可解决中文字符的统计、查询、截取等！iconv_strlen($str [,$charset]) &#x2F;&#x2F;统计字符串的字符数iconv_strpos($str, $needle, $offset [,$charset]) &#x2F;&#x2F;查找子串首次出现的位置iconv_strrpos($str, $needle [,$charset]) &#x2F;&#x2F;查找子串最后一次出现的位置iconv_substr($str, $offset [,$len [,$charset]]) &#x2F;&#x2F;截取子串&#x2F;* 【字符串函数】*&#x2F;addslashes($str) &#x2F;&#x2F;使用反斜线转移字符串stripcslashes($str) &#x2F;&#x2F;反引用一个使用addcslashes转义的字符串stripslashes($str) &#x2F;&#x2F;反引用一个引用字符串chr($ascii) &#x2F;&#x2F;返回ASCII码的字符ord($char) &#x2F;&#x2F;返回字符的ASCII码substr_count($haystack, $needle) &#x2F;&#x2F;计算子串出现的次数count_chars($str [,$mode]) 统计每个字节值出现的次数 &#x2F;&#x2F;0 - 以所有的每个字节值作为键名，出现次数作为值的数组。 &#x2F;&#x2F;1 - 与0相同，但只列出出现次数大于零的字节值。 &#x2F;&#x2F;2 - 与0相同，但只列出出现次数等于零的字节值。 &#x2F;&#x2F;3 - 返回由所有使用了的字节值组成的字符串。 &#x2F;&#x2F;4 - 返回由所有未使用的字节值组成的字符串。 crypt($str, [$salt]) &#x2F;&#x2F;单向字符串散列str_split($str [,$len]) &#x2F;&#x2F;将字符串按长度分割为数组explode($separ, $str) &#x2F;&#x2F;使用一个字符串分割另一个字符串implode([$glue,] $arr) &#x2F;&#x2F;将数组元素的值根据$glue连接成字符串chunk_split($str [,$len [,$end]]) &#x2F;&#x2F;将字符串分割成小块 $len：每段字符串的长度，$end：每段字符串末尾加的字符串(如&quot;\\r\\n&quot;)html_entity_decode($str [,$flags [,$encoding]]) &#x2F;&#x2F;将HTML实体转成字符信息htmlentities($str [,$flags [,$encoding]]) &#x2F;&#x2F;将字符信息转成HTML实体htmlspecialchars_decode($str) &#x2F;&#x2F;将特殊HTML实体转成字符信息htmlspecialchars($str [,$flags [,$encoding]]) &#x2F;&#x2F;将字符信息转成特殊HTML实体lcfirst($str) &#x2F;&#x2F;将字符串首字母转成小写ucfirst($str) &#x2F;&#x2F;将字符串首字母转成大写ucwords($str) &#x2F;&#x2F;将字符串中每个单词的首字母转换为大写strtolower($str) &#x2F;&#x2F;将字符串转化为小写strtoupper($str) &#x2F;&#x2F;将字符串转化为大写trim($str [,$charlist]) &#x2F;&#x2F;去除字符串首尾处的空白字符（或者其他字符）ltrim($str [,$charlist]) &#x2F;&#x2F;去除字符串首段的空白字符（或者其他字符）rtrim($str [,$charlist]) &#x2F;&#x2F;去除字符串末端的空白字符（或者其他字符）md5_file($file) &#x2F;&#x2F;计算指定文件的MD5散列值md5($str) &#x2F;&#x2F;计算字符串的MD5散列值money_format($format, $num) &#x2F;&#x2F;将数字格式化为货币形式number_format($num) &#x2F;&#x2F;格式化数字nl2br($str) &#x2F;&#x2F;在字符串所有新行之前插入HTML换行标记&lt;br &#x2F;&gt;parse_str($str, [$arr]) &#x2F;&#x2F;解析字符串print($str) &#x2F;&#x2F;输出字符串printf &#x2F;&#x2F;输出格式化字符串sprintf($format [,$args...]) &#x2F;&#x2F;格式化字符串sha1_file &#x2F;&#x2F;计算文件的sha1散列值sha1 &#x2F;&#x2F;计算字符串的sha1散列值similar_text($first, $second [,$percent]) &#x2F;&#x2F;计算两个字符串的相似度 返回在两个字符串中匹配字符的数目，$percent存储相似度百分比str_replace($search, $replace, $str [,$count [,$type]]) &#x2F;&#x2F;子字符串替换str_ireplace &#x2F;&#x2F;字符串替换(忽略大小写)str_pad($str, $len [,$pad [,$type]]) &#x2F;&#x2F;使用另一个字符串填充字符串为指定长度 $type：在何处填充。STR_PAD_RIGHT，STR_PAD_LEFT 或 STR_PAD_BOTHstr_repeat($str, $num) &#x2F;&#x2F;重复一个字符串str_shuffle($str) &#x2F;&#x2F;随机打乱一个字符串str_word_count($str [,$format [,$charlist]]) &#x2F;&#x2F;返回字符串中单词的使用情况strcasecmp($str1, $str2) &#x2F;&#x2F;二进制安全比较字符串（不区分大小写） 如果str1小于str2，返回负数；如果str1大于str2，返回正数；二者相等则返回0。strcmp($str1, $str2) &#x2F;&#x2F;二进制安全字符串比较strcoll($str1, $str1) &#x2F;&#x2F;基于区域设置的字符串比较(区分大小写，非二进制安全)strcspn($str1, $str1 [,$start [,$len]]) &#x2F;&#x2F;获取不匹配遮罩的起始子字符串的长度strip_tags($str) &#x2F;&#x2F;从字符串中去除HTML和PHP标记strpos($haystack, $needle [,$offset]) &#x2F;&#x2F;查找字符串首次出现的位置stripos($haystack, $needle [,$offset]) &#x2F;&#x2F;查找字符串首次出现的位置（不区分大小写）strripos($haystack, $needle [,$offset]) &#x2F;&#x2F;计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）strrpos($haystack, $needle [,$offset]) &#x2F;&#x2F;计算指定字符串在目标字符串中最后一次出现的位置strlen($str) &#x2F;&#x2F;获取字符串长度strpbrk($haystack, $str) &#x2F;&#x2F;在字符串中查找一组字符的任何一个字符strrev($str) &#x2F;&#x2F;反转字符串 join(&#39;&#39;, array_reverse(preg_split(&quot;&#x2F;&#x2F;u&quot;, $str))); &#x2F;&#x2F;实现对UTF-8字符串的反转strspn$subject, $mask) &#x2F;&#x2F;计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。strstr($haystack, $needle) &#x2F;&#x2F;查找字符串的首次出现stristr($haystack, $needle) &#x2F;&#x2F;查找字符串的首次出现(不区分大小写)strrchr($haystack, $needle) &#x2F;&#x2F;查找指定字符在字符串中的最后一次出现strtok($str, $token) &#x2F;&#x2F;标记分割字符串substr_compare($main_str, $str, $offset [,$len) &#x2F;&#x2F;二进制安全比较字符串（从偏移位置比较指定长度）substr_replace$str, $replace, $start [,$len] &#x2F;&#x2F;替换字符串的子串strtr($str, $from, $to) &#x2F;&#x2F;转换指定字符substr($str, $start [,$len]) &#x2F;&#x2F;返回字符串的子串vfprintf$handle, $format, $args) &#x2F;&#x2F;将格式化字符串写入流vprintf($format, $args) &#x2F;&#x2F;输出格式化字符串vsprintf($format, $args) &#x2F;&#x2F;返回格式化字符串wordwrap($str [,$width&#x3D;75 [,$break&#x3D;&#39;\\n&#39;]]) &#x2F;&#x2F;打断字符串为指定数量的字串crc32($str) &#x2F;&#x2F;计算一个字符串的crc32多项式 crc32算法[循环冗余校验算法] 生成str的32位循环冗余校验码多项式。将数据转换成整数。&#x2F;* mbstring(多字节字符串) *&#x2F;&#x2F;&#x2F;需开启mbstring扩展mb_strimwidth($str, $start, $width [,$trim [,$encoding]]) &#x2F;&#x2F;保留指定的子串(并补充)mb_stripos($str, $needle [,$offset [,$encoding]]) &#x2F;&#x2F;查找子串首次出现的位置(忽略大小写)mb_strpos($str, $needle [,$offset [,$encoding]]) &#x2F;&#x2F;查找子串首次出现的位置mb_strripos($str, $needle [,$offset [,$encoding]]) &#x2F;&#x2F;查找子串最后一次出现的位置(忽略大小写)mb_strrpos($str, $needle [,$offset [,$encoding]]) &#x2F;&#x2F;查找子串最后一次出现的位置mb_strstr($str, $needle [,$before [,$encoding]]) &#x2F;&#x2F;返回子串首次出现位置之后(前)的字符串mb_stristr($str, $needle [,$before [,$encoding]]) &#x2F;&#x2F;返回子串首次出现位置之后(前)的字符串(忽略大小写)mb_strrchr($str, $needle [,$before [,$encoding]]) &#x2F;&#x2F;返回字符最后一次出现位置之后(前)的字符串mb_strrichr($str, $needle [,$before [,$encoding]]) &#x2F;&#x2F;返回字符最后一次出现位置之后(前)的字符串(忽略大小写)mb_strtoupper($str [,$encoding]) &#x2F;&#x2F;转换成大写mb_strtolower($str [,$encoding]) &#x2F;&#x2F;转换成小写mb_strlen($str [,$encoding]) &#x2F;&#x2F;获取字符串长度mb_split($pattern, $str [,$limit]) &#x2F;&#x2F;将字符串分割成数组mb_substr($str, $start [,$len [,$encoding]]) &#x2F;&#x2F;获取字符串的子串mb_strcut($str, $start [,$len [,$encoding]]) &#x2F;&#x2F;获取字符串的子串mb_strwidth($str [,$encoding]) &#x2F;&#x2F;获取字符串的宽度mb_substr_count($str, $needle [,$encoding]) &#x2F;&#x2F;子串在字符串中出现的次数&#x2F;* PCRE函数 *&#x2F;preg_filter($pattern, $replace, $subject [,$limit [,&amp;$count]]) 执行一个正则表达式搜索和替换preg_replace($pattern, $replace, $subject [,$limit [,&amp;$count]]) 执行一个正则表达式搜索和替换preg_replace_callback($pattern, $callback, $subject [,$limit [,&amp;$count]]) 执行一个正则表达式搜索并且使用一个回调进行替换preg_grep($pattern, $input [,$flags]) 返回匹配模式的数组条目preg_match($pattern, $subject [,&amp;$matches [,$flags [,$offset]]]) 执行一个正则表达式匹配preg_match_all($pattern, $subject [,&amp;$matches [,$flags [,$offset]]]) 执行一个全局正则表达式匹配 $matches存放返回的结果 $matches[0][n] (n&gt;&#x3D;0) 表示存放第n+1个匹配到的结果 $matches[m][n] (m&gt;&#x3D;1, n&gt;&#x3D;0) 表示存放第n+1个匹配到结果的第m个表达式的内容preg_split($pattern, $subject [,$limit [,$flags]]) 通过一个正则表达式分隔字符串 $limit表示限制分隔得到的子串最多只有limit个，-1表示不限制 $flags参数： PREG_SPLIT_NO_EMPTY：将返回分隔后的非空部分 PREG_SPLIT_DELIM_CAPTURE：用于分隔的模式中的括号表达式将被捕获并返回 PREG_SPLIT_OFFSET_CAPTURE：对于每一个出现的匹配返回时将会附加字符串偏移量preg_quote($str [,$delimiter]) 转义正则表达式字符preg_last_error() 返回最后一个PCRE正则执行产生的错误代码&#x2F;* Math函数 *&#x2F;base_convert($number, $frombase, $tobase) &#x2F;&#x2F;在任意进制之间转换数字ceil($float) &#x2F;&#x2F;向上取整floor($float) &#x2F;&#x2F;向下取整exp($float) &#x2F;&#x2F;计算e的指数hypot($x, $y) &#x2F;&#x2F;计算直角三角形的斜边长is_nan($val) &#x2F;&#x2F;判断是否为合法数值log($arg [,$base&#x3D;e]) &#x2F;&#x2F;自然对数max($num1, $num2, ...) &#x2F;&#x2F;找出最大值 max($arr) &#x2F;&#x2F;找出数组中的最大值min($num1, $num2, ...) &#x2F;&#x2F;找出最小值rand([$min], $max) &#x2F;&#x2F;产生一个随机整数srand([$seed]) &#x2F;&#x2F;播下随机数发生器种子mt_rand([$min], $max) &#x2F;&#x2F;生成更好的随机数mt_srand($seed) &#x2F;&#x2F;播下一个更好的随机数发生器种子pi() &#x2F;&#x2F;得到圆周率值pow($base, $exp) &#x2F;&#x2F;指数表达式sqrt($float) &#x2F;&#x2F;求平方根deg2rad($float) &#x2F;&#x2F;将角度转换为弧度rad2deg($float) &#x2F;&#x2F;将弧度数转换为相应的角度数round($val [,$pre&#x3D;0]) &#x2F;&#x2F;对浮点数进行四舍五入fmod($x, $y) &#x2F;&#x2F;返回除法的浮点数余数&#x2F;* 【MySQL函数】 *&#x2F;mysql_client_encoding([$link]) &#x2F;&#x2F;返回字符集的名称mysql_set_charset($charset [,$link]) &#x2F;&#x2F;设置客户端字符集编码mysql_connect($host, $user, $pass) &#x2F;&#x2F;打开一个到MySQL服务器的连接mysql_create_db($db [,$link]) &#x2F;&#x2F;新建一个MySQL数据库mysql_pconnect($host, $user, $pass) &#x2F;&#x2F;打开一个到MySQL服务器的持久连接mysql_ping([$link]) &#x2F;&#x2F;Ping一个服务器连接，如果没有连接则重新连接mysql_close([$link]) &#x2F;&#x2F;关闭MySQL连接mysql_data_seek($result, $row) &#x2F;&#x2F;移动内部结果的指针mysql_errno([$link]) &#x2F;&#x2F;返回上一个MySQL操作中的错误信息的数字编码mysql_error([$link]) &#x2F;&#x2F;返回上一个MySQL操作产生的文本错误信息mysql_affected_rows([$link]) &#x2F;&#x2F;取得前一次MySQL操作所影响的记录行数mysql_info([$link]) &#x2F;&#x2F;取得最近一条查询的信息mysql_insert_id([$link]) &#x2F;&#x2F;取得上一步INSERT操作产生的IDmysql_query($sql [,$link]) &#x2F;&#x2F;发送一条MySQL查询mysql_unbuffered_query($sql [,$link]) &#x2F;&#x2F;向MySQL发送一条SQL查询，并不获取和缓存结果的行mysql_db_query($db, $sql [,$link]) &#x2F;&#x2F;发送一条MySQL查询mysql_escape_string($str) &#x2F;&#x2F;转义一个字符串用于mysql_querymysql_real_escape_string($str) &#x2F;&#x2F;转义SQL语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集mysql_fetch_array($result [,$type]) &#x2F;&#x2F;从结果集中取得一行作为关联数组，或数字数组，或二者兼有mysql_fetch_assoc($result) &#x2F;&#x2F;从结果集中取得一行作为关联数组mysql_fetch_object($result) &#x2F;&#x2F;从结果集中取得一行作为对象mysql_fetch_row($result) &#x2F;&#x2F;从结果集中取得一行作为枚举数组mysql_fetch_field($result) &#x2F;&#x2F;从结果集中取得列信息并作为对象返回mysql_num_fields($result) &#x2F;&#x2F;取得结果集中字段的数目mysql_num_rows($result) &#x2F;&#x2F;取得结果集中行的数目mysql_fetch_lengths($result) &#x2F;&#x2F;取得结果集中每个输出的长度mysql_field_flags($result, $field_offset) &#x2F;&#x2F;从结果中取得和指定字段关联的标志mysql_field_len($result, $field_offset) &#x2F;&#x2F;返回指定字段的长度mysql_field_name($result, $field_offset) &#x2F;&#x2F;取得结果中指定字段的字段名mysql_field_seek($result, $field_offset) &#x2F;&#x2F;将结果集中的指针设定为制定的字段偏移量mysql_field_table($result, $field_offset) &#x2F;&#x2F;取得指定字段所在的表名mysql_field_type($result, $field_offset) &#x2F;&#x2F;取得结果集中指定字段的类型mysql_free_result($result) &#x2F;&#x2F;释放结果内存mysql_list_dbs([$link]) &#x2F;&#x2F;列出MySQL服务器中所有的数据库mysql_list_fields($db, $table [,$link]) &#x2F;&#x2F;列出MySQL结果中的字段mysql_list_processes([$link]) &#x2F;&#x2F;列出MySQL进程mysql_list_tables($db [,$link]) &#x2F;&#x2F;列出MySQL数据库中的表mysql_result($result, $row [$field]) &#x2F;&#x2F;取得结果数据mysql_select_db($db [,$link]) &#x2F;&#x2F;选择MySQL数据库mysql_tablename($result, $i) &#x2F;&#x2F;取得表名mysql_db_name($result, $row [,$field]) &#x2F;&#x2F;取得mysql_list_dbs()调用所返回的数据库名mysql_stat([$link]) &#x2F;&#x2F;取得当前系统状态mysql_thread_id([$link]) &#x2F;&#x2F;返回当前线程的IDmysql_get_client_info() &#x2F;&#x2F;取得MySQL客户端信息mysql_get_host_info() &#x2F;&#x2F;取得MySQL主机信息mysql_get_proto_info() &#x2F;&#x2F;取得MySQL协议信息mysql_get_server_info() &#x2F;&#x2F;取得MySQL服务器信息&#x2F;* 【SQL注入】 *&#x2F;特殊字符导致的问题： 1. 转义：mysql_real_escape_string() 对外来数据(GPC: GET, POST, COOKIE)进行转义 2. 先查询当前记录行，再匹配用户名&#x2F;&#x2F;魔术引号机制自动为所有提交到服务器的数据增加特殊符号的转义。当打开时，所有的单引号，双引号，反斜线和NULL字符都会被自动加上一个反斜线进行转义。这和addslashes()作用完全相同。php.ini配置： magic_quotes_gpc &#x3D; Offget_magic_quotes_gpc() 获取当前魔术引号机制的配置信息&#x2F;* 【错误处理】 *&#x2F;解析错误、运行错误&#x2F;&#x2F;标准错误： 级别、信息、文件、行号 trigger_error 触发一个用户自定义的error&#x2F;warning&#x2F;notice错误信息&#x2F;&#x2F;php.ini配置，ini_set()error_reporting 设置报告哪些级别的错误# 错误报告：显示到页面 display_errors &#x3D; On 是否显示错误报告# 错误日志：存放到文件 log_errors &#x3D; on 是否开启错误日志 error_log 发送错误信息到错误日志文件- 错误报告和错误日志可同时启用！自定义错误处理器set_error_handler — 注册自定义错误处理器函数- 自定义处理器函数包含4个参数，分别是级别、信息、文件、行号- 开启自定义错误处理器，则系统内置的错误报告和错误日志则不会执行。- 自定义错误处理器函数返回false，则自定义函数结束后系统内置的会继续执行。- 用户定义的错误级别(E_USER_ERROR)，可以被自定义的错误处理器所捕获并继续执行。系统内置的错误，则脚本会立即停止。restore_error_handler — 恢复预定义错误处理器函数error_get_last — 获取最近的错误信息&#x2F;&#x2F;错误处理函数debug_backtrace 产生一条回溯跟踪 返回数组，包含的键值：function, line, file, class, object, type, argsdebug_print_backtrace 打印一条回溯&#x2F;&#x2F;错误常量手册&gt;错误处理#生产模式关闭错误报告，记录错误日志。#开发模式关闭错误日志，开启错误报告。&#x2F;&#x2F;异常面向对象语法中的错误处理方式。一个异常就是一个包含当前异常信息的对象。预定义异常类Exception及其扩展类。#抛出异常触发一个异常的错误throw new UserException();如果没有被捕获，则报告致命错误。#监视异常try &#123;代码段&#125;#捕获异常catch (UserException $obj) &#123;代码段&#125;需要通过当前异常的类型匹配才可悲捕获。#异常处理器用以处理未被捕获的异常。异常处理器函数与catch类似，参数也是含类型的对象。set_exception_handler — 注册异常处理器函数restore_exception_handler — 恢复预定义的异常处理器函数#自定义异常用户定义的异常类须继承自Exception类。&#x2F;&#x2F;异常相关属性protected string $message 异常消息内容protected int $code 异常代码protected string $file 抛出异常的文件名protected int $line 抛出异常在该文件中的行号&#x2F;&#x2F;异常相关方法Exception::__construct — 异常构造函数Exception::getMessage — 获取异常消息内容Exception::getPrevious — 返回异常链中的前一个异常Exception::getCode — 获取异常代码Exception::getFile — 获取发生异常的程序文件名称Exception::getLine — 获取发生异常的代码在文件中的行号Exception::getTrace — 获取异常追踪信息Exception::getTraceAsString — 获取字符串类型的异常追踪信息Exception::__toString — 将异常对象转换为字符串Exception::__clone — 异常克隆&#x2F;* 【数据库抽象层】 *&#x2F;PDO:PHP Data ObjectsPHO抽象层默认被加载，但需加载相应数据库的驱动。PDO是OOP语法，提供三个类：PDO：PDO自身PDOStatement：PDO语句类，提供对语句的后续处理PDOException：PDO异常类，提供对错误的异常处理&#x2F;&#x2F;连接数据库PDO::__construct(str $dsn [,str $username [,str $password [,arr $driver_options]]])DSN：Data Source Name，数据源$dsn &#x3D; &#39;mysql:dbname&#x3D;testdb;host&#x3D;127.0.0.1;port&#x3D;3306&#39;;&#x2F;&#x2F;执行没有返回结果的SQL语句int PDO::exec(str $statement) &#x2F;&#x2F;返回影响的记录数&#x2F;&#x2F;执行有返回结果集的SQL语句PDOStatement PDO::query (string $statement) &#x2F;&#x2F;返回PDOStatement对象&#x2F;&#x2F;处理结果集(PDOStatement对象)array PDOStatement::fetchAll([int $fetch_style [,mixed $fetch_argument [,array $ctor_args &#x3D; array()]]]) &#x2F;&#x2F;默认返回关联+索引数组mixed PDOStatement::fetch ([ int $fetch_style [, int $cursor_orientation &#x3D; PDO::FETCH_ORI_NEXT [, int $cursor_offset &#x3D; 0 ]]] ) &#x2F;&#x2F;返回一行string PDOStatement::fetchColumn ([ int $column_number &#x3D; 0 ] ) &#x2F;&#x2F;返回一列&#x2F;&#x2F;释放资源unset($pdo) 或 $pdo &#x3D; null&#x2F;&#x2F;错误报告静默模式：silent mode，出现错误，不主动报告错误（默认）array PDO::errorInfo(void)警告模式：warning mode，出现错误，触发一个警告级别的错误异常错误：exception mode，出现错误，抛出异常bool PDO::setAttribute(int $attribute, mixed $value) &#x2F;&#x2F;设置PDO类属性值PDO::setAttribute(&#39;PDO::ATTR_ERRMODE&#39;, &#39;PDO::ERRMODE_SILENT | PDO::ERRMODE_WARNING | PDO::ERRMODE_EXCEPTION&#39;)&#x2F;&#x2F;预处理式执行SQL可对数据自动转义，可有效抵制SQL注入。PDOStatement PDO::prepare(string $statement [,array $driver_options&#x3D;array()])bool PDOStatement::bindParam ( mixed $parameter , mixed &amp;$variable [, int $data_type &#x3D; PDO::PARAM_STR [, int $length [, mixed $driver_options ]]] )bool PDOStatement::execute ([ array $input_parameters ] )&#x2F;* 【AR模式】 *&#x2F;表 -&gt; 类字段 -&gt; 类属性数据 -&gt; 对象&#x2F;* Date&#x2F;Time *&#x2F;date($format [,$timestamp]) &#x2F;&#x2F;格式化一个本地时间／日期，$timestamp默认为time() Y：4位数字完整表示的年份 m：数字表示的月份，有前导零 d：月份中的第几天，有前导零的2位数字 j：月份中的第几天，没有前导零 H：小时，24小时格式，有前导零 h：小时，12小时格式，有前导零 i：有前导零的分钟数 s：秒数，有前导零 L：是否为闰年，如果是闰年为1，否则为0 M：三个字母缩写表示的月份，Jan到Dec W：年份中的第几周，每周从星期一开始 z：年份中的第几天 N：数字表示的星期中的第几天 w：星期中的第几天，数字表示 e：时区标识 T：本机所在的时区 U：从Unix纪元开始至今的秒数(时间戳)time() &#x2F;&#x2F;返回当前的Unix时间戳(秒)microtime([$get_as_float]) &#x2F;&#x2F;返回当前Unix时间戳和微秒数 $get_as_float参数存在并且其值等价于TRUE，将返回一个浮点数strtotime($time [,$now]) &#x2F;&#x2F;将任何英文文本的日期时间描述解析为Unix时间戳 date(&quot;Y-m-d H:i:s&quot;, strtotime(&quot;-1 day&quot;)); &#x2F;&#x2F;格式化前一天的时间戳 &quot;now&quot; &quot;10 September 2000&quot; &quot;+1 week&quot; &quot;+1 week -2 days 4 hours 2 seconds&quot; &quot;last Monday&quot; &quot;next Thursday&quot;gmdate($format [,$timestamp]) &#x2F;&#x2F;格式化一个GMT&#x2F;UTC 日期／时间mktime([$hour &#x3D; date(&quot;H&quot;) [,$minute &#x3D; date(&quot;i&quot;) [,$second &#x3D; date(&quot;s&quot;) [,$month &#x3D; date(&quot;n&quot;) [,$day &#x3D; date(&quot;j&quot;) [,$year &#x3D; date(&quot;Y&quot;) [,$is_dst &#x3D; -1]]]]]]]) &#x2F;&#x2F;取得一个日期的Unix时间戳strftime($format [,$timestamp]) &#x2F;&#x2F;根据区域设置格式化本地时间／日期date_default_timezone_get($timezone) &#x2F;&#x2F;获取默认时区date_default_timezone_set($timezone) &#x2F;&#x2F;设置默认时区&#x2F;* DateTime *&#x2F;&#x2F;&#x2F;date()函数能处理有效时间戳范围是格林威治时间 1901 年 12 月 13 日 20:45:54 到 2038 年 1 月 19 日 03:14:07(因为32位系统能最大正整数限制)DateTime::__construct([$time&#x3D;&quot;now&quot;]) &#x2F;&#x2F;构造方法 $time若是时间戳，则在时间戳前加@符号，如&#39;@2345678&#39;DateTime::setTimezone($timezone) &#x2F;&#x2F;设置时区 eg: $date-&gt;setTimezone(new DateTimeZone(&#39;PRC&#39;));DateTime::format($format) &#x2F;&#x2F;格式化时间戳，格式化字符串形式同date()函数&#x2F;* $_SERVER *&#x2F;&#x2F;&#x2F;示例URL：http:&#x2F;&#x2F;desktop&#x2F;dir&#x2F;demo.php?a&#x3D;aaa&amp;b&#x3D;bbbPHP_SELF 当前执行脚本的文件名 &#x2F;&#x2F; &#x2F;dir&#x2F;demo.phpGATEWAY_INTERFACE 服务器使用的CGI规范的版本 &#x2F;&#x2F; CGI&#x2F;1.1SERVER_ADDR 当前运行脚本所在的服务器的IP地址 &#x2F;&#x2F; 127.0.0.1SERVER_NAME 当前运行脚本所在的服务器的主机名 &#x2F;&#x2F; desktopSERVER_SOFTWARE 服务器标识字符串 &#x2F;&#x2F; Apache&#x2F;2.2.22 (Win32) PHP&#x2F;5.3.13SERVER_PROTOCOL 请求页面时通信协议的名称和版本 &#x2F;&#x2F; HTTP&#x2F;1.1REQUEST_METHOD 访问页面使用的请求方式 &#x2F;&#x2F; GETREQUEST_TIME 请求开始时的时间戳 &#x2F;&#x2F; 1386032633QUERY_STRING 查询字符串(参数) &#x2F;&#x2F; a&#x3D;aaa&amp;b&#x3D;bbbDOCUMENT_ROOT 当前运行脚本所在的文档根目录 &#x2F;&#x2F; C:&#x2F;Users&#x2F;Administrator&#x2F;DesktopHTTP_ACCEPT 当前请求头中Accept:项的内容 &#x2F;&#x2F; text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8HTTP_ACCEPT_CHARSET 当前请求头中Accept-Charset:项的内容 &#x2F;&#x2F; UTF-8,*HTTP_ACCEPT_ENCODING 当前请求头中Accept-Encoding:项的内容 &#x2F;&#x2F; gzip, deflateHTTP_ACCEPT_LANGUAGE 当前请求头中Accept-Language:项的内容 &#x2F;&#x2F; zh-cn,zh;q&#x3D;0.5HTTP_CONNECTION 当前请求头中Connection:项的内容 &#x2F;&#x2F; keep-aliveHTTP_HOST 当前请求头中Host:项的内容 &#x2F;&#x2F; desktopHTTP_REFERER 引导用户代理到当前页的前一页的地址HTTP_USER_AGENT 当前请求头中User-Agent:项的内容 &#x2F;&#x2F; Mozilla&#x2F;5.0 (Windows NT 6.1; rv:2.0.1) Gecko&#x2F;20100101 Firefox&#x2F;4.0.1HTTPS 如果脚本是通过HTTPS协议被访问，则被设为一个非空的值REMOTE_ADDR 浏览当前页面的用户的IP地址 &#x2F;&#x2F; 127.0.0.1REMOTE_HOST 浏览当前页面的用户的主机名REMOTE_PORT 用户机器上连接到Web服务器所使用的端口号 &#x2F;&#x2F; 49197REMOTE_USER 经验证的用户REDIRECT_REMOTE_USER 验证的用户，如果请求已在内部重定向SCRIPT_FILENAME 当前执行脚本的绝对路径 &#x2F;&#x2F; C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;dir&#x2F;demo.phpSERVER_ADMIN 该值指明了Apache服务器配置文件中的SERVER_ADMIN参数 &#x2F;&#x2F;admin@shocker.comSERVER_PORT Web服务器使用的端口 &#x2F;&#x2F; 80SERVER_SIGNATURE 包含了服务器版本和虚拟主机名的字符串PATH_TRANSLATED 当前脚本所在文件系统（非文档根目录）的基本路径SCRIPT_NAME 当前脚本的路径 &#x2F;&#x2F; &#x2F;dir&#x2F;demo.phpREQUEST_URI URI用来指定要访问的页面 &#x2F;&#x2F; &#x2F;dir&#x2F;demo.php?a&#x3D;aaa&amp;b&#x3D;bbbPHP_AUTH_DIGEST 客户端发送的“Authorization” HTTP头内容PHP_AUTH_PW 用户输入的密码AUTH_TYPE 认证的类型PATH_INFO 包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息ORIG_PATH_INFO 在被PHP处理之前，“PATH_INFO”的原始版本&#x2F;* 缓存 *&#x2F;1. ob缓存(输出缓存)(需开启) php.ini设置中开启并设置输出缓存大小：output_buffering &#x3D; 4096 ob_start() 开启当前脚本页面的输出缓存 如果输出缓存打开，则输出的数据先放到输出缓存(header函数前可以有输出)，否则直接放入程序缓存。 header()函数发送的内容直接放入程序缓存。 开启输出缓存后，输出缓存数据会刷新到程序缓存，然后有Apache封装成http响应包返回给浏览器。 输出缓存：存放的数据是从开启输出缓存开始返回给浏览器的所有静态页面数据！2. 程序缓存(内部缓存，必须存在，不能关闭)3. 浏览器缓存&#x2F;* ob缓存(输出控制) *&#x2F; Output Bufferingob_start() &#x2F;&#x2F;打开一个输出缓冲区，所有的输出信息不再直接发送到浏览器，而是保存在输出缓冲区里面。 ob_start(&#39;ob_gzhandler&#39;); &#x2F;&#x2F;将gz编码的数据发送到支持压缩页面的浏览器ob_clean(); &#x2F;&#x2F;删除内部缓冲区的内容，不关闭缓冲区(不输出)。ob_end_clean(); &#x2F;&#x2F;删除内部缓冲区的内容，关闭缓冲区(不输出)。ob_get_clean(); &#x2F;&#x2F;返回内部缓冲区的内容，关闭缓冲区。相当于执行ob_get_contents()与ob_end_clean()ob_flush(); &#x2F;&#x2F;发送内部缓冲区的内容到浏览器，删除缓冲区的内容，不关闭缓冲区。ob_end_flush(); &#x2F;&#x2F;发送内部缓冲区的内容到浏览器，删除缓冲区的内容，关闭缓冲区。ob_get_flush(); &#x2F;&#x2F;返回内部缓冲区的内容，并关闭缓冲区，再释放缓冲区的内容。相当于ob_end_flush()并返回缓冲区内容。flush(); &#x2F;&#x2F;将当前为止程序的所有输出发送到用户的浏览器ob_get_contents(); &#x2F;&#x2F;返回缓冲区的内容，不输出。ob_get_length(); &#x2F;&#x2F;返回内部缓冲区的长度，如果缓冲区未被激活，该函数返回FALSE。ob_get_level(); &#x2F;&#x2F;Return the nesting level of the output buffering mechanism.ob_get_status(); &#x2F;&#x2F;获取ob状态信息ob_implicit_flush(); &#x2F;&#x2F;打开或关闭绝对刷新，默认为关闭，打开后ob_implicit_flush(true)，所谓绝对刷新，即当有输出语句(e.g: echo)被执行时，便把输出直接发送到浏览器，而不再需要调用flush()或等到脚本结束时才输出。ob_gzhandler &#x2F;&#x2F;ob_start回调函数，用gzip压缩缓冲区的内容。ob_list_handlers &#x2F;&#x2F;List all output handlers in useoutput_add_rewrite_var &#x2F;&#x2F;Add URL rewriter valuesoutput_reset_rewrite_vars &#x2F;&#x2F;Reset URL rewriter values这些函数的行为受php_ini设置的影响：output_buffering &#x2F;&#x2F;该值为ON时，将在所有脚本中使用输出控制；若该值为一个数字，则代表缓冲区的最大字节限制，当缓存内容达到该上限时将会自动向浏览器输出当前的缓冲区里的内容。output_handler &#x2F;&#x2F;该选项可将脚本所有的输出，重定向到一个函数。例如，将 output_handler 设置为 mb_output_handler() 时，字符的编码将被修改为指定的编码。设置的任何处理函数，将自动的处理输出缓冲。implicit_flush &#x2F;&#x2F;作用同ob_implicit_flush，默认为Off。&#x2F;&#x2F;ob缓存作用1)防止在浏览器有输出之后再使用setcookie()、header()或session_start()等发送头文件的函数造成的错误。其实这样的用法少用为好，养成良好的代码习惯。2)捕捉对一些不可获取的函数的输出，比如phpinfo()会输出一大堆的HTML，但是我们无法用一个变量例如$info&#x3D;phpinfo();来捕捉，这时候ob就管用了。3)对输出的内容进行处理，例如进行gzip压缩，例如进行简繁转换，例如进行一些字符串替换。4)生成静态文件，其实就是捕捉整页的输出，然后存成文件。经常在生成HTML，或者整页缓存中使用。&#x2F;* 网站并发 *&#x2F;测试工具：apache&#x2F;bin&#x2F;ab.exe用法：cmd&#123;%apache-bin%&#125;&gt;ab.exe -n 执行访问次数 -c 用户并发数量 URL地址MPM(多路处理模块)：perfork(预处理模式), worker(工作者模式), winnt(Win系统)MPM配置：httpd-mpm.conf查看当前MPM模式：httpd –l mpm_xxx.c中xxx表示当前模式类型httpd.conf配置(开启MPM)：#Include conf&#x2F;extra&#x2F;httpd-mpm.conf#参考配置#配置文件：extra&#x2F;httpd-mpm.conf#mpm_winnt.c&lt;IfModule mpm_winnt_module&gt; ThreadsPerChild 1000 #中型网站1500-5500合理 MaxRequestsPerChild 0&lt;&#x2F;IfModule&gt;#mpm_prefork.c&lt;IfModule mpm_prefork_module&gt; StartServers 5 #预先启动 MinSpareServers 5 MaxSpareServers 10 #最大空闲进程 ServerLimit 1500 #用于修改apache编程参数 MaxClients 1000 #最大并发数 MaxRequestsPerChild 0 #一个进程对应的线程数，对worker更用&lt;&#x2F;IfModule&gt;#如果你的网站pv值上百万ServerLimit 2500 #用于修改apache编程参数MaxClients 2000 #最大并发数&#x2F;* 静态化 *&#x2F;1. 页面URL长度不超过255字节2. meta信息尽量完整，keywords5个左右3. 前端不要使用框架4. 图片alt属性添加信息5. 静态页面不要带动态值&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; language&#x3D;&quot;javascript&quot; src&#x3D;&quot;url&quot;&gt;&lt;&#x2F;script&gt;url可以是js&#x2F;php&#x2F;图片等，返回的数据替换&lt;script&gt;标签所在位置的内容！相当于简单的Ajax&#x2F;* Apache压缩 *&#x2F;gzip&#x2F;deflate&#x2F;* XSS攻击 *&#x2F;#恶意JS代码#不规则HTML代码开源过滤器：htmlpurifier&#x2F;&#x2F;获取COOKIE&lt;script&gt;var c &#x3D; document.cookie; &#x2F;&#x2F;获取COOKIEvar script &#x3D; document.createElement(&#39;script&#39;); &#x2F;&#x2F;创建script标签script.src &#x3D; &#39;demo.php?c&#x3D;&#39; + c; &#x2F;&#x2F;发送到指定的文件接收document.body.appendChild(script); &#x2F;&#x2F;添加到DOM对象中生效&lt;&#x2F;script&gt;&#x2F;* 命令行CLI *&#x2F;&#x2F;&#x2F;显示帮助信息php -h&#x2F;&#x2F;解析并运行-f选项给定的文件名php [-f] &lt;file&gt; [--] [args...]&#x2F;&#x2F;在命令行内运行单行PHP代码php [options] -r &lt;code&gt; [--] [args...]无需加上PHP的起始和结束标识符，否则将会导致语法解析错误&#x2F;&#x2F;调用phpinfo()函数并显示出结果php -i&#x2F;--info&#x2F;&#x2F;检查PHP语法php -l&#x2F;--syntax-check&#x2F;&#x2F;打印出内置以及已加载的PHP及Zend模块php -m&#x2F;--modules&#x2F;&#x2F;将PHP，PHP SAPI和Zend的版本信息写入标准输出php -v&#x2F;--version&#x2F;&#x2F;参数接收$argv 传递给脚本的参数数组 第一个参数总是当前脚本的文件名，因此$argv[0]就是脚本文件名$argc 传递给脚本的参数数目 脚本的文件名总是作为参数传递给当前脚本，因此$argc的最小值为1包含当运行于命令行下时传递给当前脚本的参数的数组此两个变量仅在register_argc_argv打开时可用&#x2F;* 设计模式 *&#x2F;单例模式：为一个类生成一个唯一的对象。使用单例模式生成一个对象后，该对象可以被其它众多对象所使用。工厂模式：封装对象的建立过程。可以在对象本身创建对象工厂或者是一个额外的工厂类MVC模式：用户-&gt;控制器-&gt;模型-&gt;控制器-&gt;视图-&gt;控制器-&gt;用户&#x2F;* 配置选项 *&#x2F;set_time_limit($seconds) &#x2F;&#x2F;设置脚本最大执行时间(默认30秒)，0表示不限制ini_get($varname) &#x2F;&#x2F;获取一个配置选项的值ini_set($varname, $newvalue) &#x2F;&#x2F;为一个配置选项设置值extension_loaded($ext_name) &#x2F;&#x2F;检测一个扩展是否已经加载get_extension_funcs($ext_name) &#x2F;&#x2F;返回模块函数名的数组&#x2F;* 【其他】 *&#x2F;version_compare(str $ver1, str $ver2 [,str $operator]) &#x2F;&#x2F;比较版本号 $operator表示操作符，可选：&lt;, lt, &lt;&#x3D;, le, &gt;, gt, &gt;&#x3D;, ge, &#x3D;&#x3D;, &#x3D;, eq, !&#x3D;, &lt;&gt;, ne 如果省略$operator，返回两个版本号的差值。符号@ 用于抑制系统运行错误的报告显示memory_get_usage &#x2F;&#x2F;获取当期内存使用情况memory_get_peak_usage &#x2F;&#x2F;获取内存使用的峰值getrusage &#x2F;&#x2F;获取CPU使用情况(Windows不可用)uniqid([$prefix]) &#x2F;&#x2F;获取一个带前缀、基于当前时间微秒数的唯一IDhighlight_string($str [,$return]) &#x2F;&#x2F;字符串的语法高亮 $return：设置为TRUE，高亮后的代码不会被打印输出，而是以字符串的形式返回。高亮成功返回TRUE，否则返回FALSE。highlight_file($file [,$return]) &#x2F;&#x2F;语法高亮一个文件__halt_compiler &#x2F;&#x2F;中断编译器的执行get_browser &#x2F;&#x2F;获取浏览器具有的功能 get_browser ([ string $user_agent [, bool $return_array &#x3D; false ]] ) 如果设置为 TRUE，该函数会返回一个 array，而不是 objecteval($code) &#x2F;&#x2F;把字符串作为PHP代码执行gzcompress($str [,$level&#x3D;-1]) &#x2F;&#x2F;压缩字符串gzuncompress($str) &#x2F;&#x2F;解压缩字符串gzencode($str [,$level&#x3D;-1]) &#x2F;&#x2F;压缩字符串gzdecode($str) &#x2F;&#x2F;解压缩字符串ignore_user_abort($bool) &#x2F;&#x2F;设置客户端断开连接时是否中断脚本的执行","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"fastcgi_pass 使用socket连接还是tcp连接","slug":"fastcgi_socket","date":"2020-04-20T11:30:10.000Z","updated":"2020-04-20T11:31:06.000Z","comments":true,"path":"2020/04/20/fastcgi_socket/","link":"","permalink":"http://yoursite.com/2020/04/20/fastcgi_socket/","excerpt":"","text":"Nginx 和 PHP-FPM 的进程间通信有两种方式，一种是 TCP,一种是 UNIX Domain Socket. 其中 TCP 是 IP 加端口，可以跨服务器。而 UNIX Domain Socket 不经过网络，只能用于 Nginx 跟 PHP-FPM 都在同一服务器的场景。用哪种取决于你的 PHP-FPM 配置： 方式 1: php-fpm.conf: listen = 127.0.0.1:9000 nginx.conf: fastcgi_pass 127.0.0.1:9000; 方式 2: php-fpm.conf: listen = /tmp/php-fpm.sock nginx.conf: fastcgi_pass unix:/tmp/php-fpm.sock; 其中 php-fpm.sock 是一个文件，由 php-fpm 生成，类型是 srw-rw—-. UNIX Domain Socket 可用于两个没有亲缘关系的进程，是目前广泛使用的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX Domain Socket 通讯的。这种通信方式是发生在系统内核里而不会在网络里传播。UNIX Domain Socket 和长连接都能避免频繁创建 TCP 短连接而导致 TIME_WAIT 连接过多的问题。对于进程间通讯的两个程序，UNIX Domain Socket 的流程不会走到 TCP 那层，直接以文件形式，以 stream socket 通讯。如果是 TCP Socket,则需要走到 IP 层，对于非同一台服务器上，TCP Socket 走的就更多了。 UNIX Domain Socket: Nginx &lt;=&gt; socket &lt;=&gt; PHP-FPM TCP Socket(本地回环): Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPM TCP Socket(Nginx 和 PHP-FPM 位于不同服务器): Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; 物理层 &lt;=&gt; 路由器 &lt;=&gt; 物理层 &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPM 像 MySQL 命令行客户端连接 mysqld 服务也类似有这两种方式： 使用 Unix Socket 连接(默认): MySQL -uroot -p –protocol=socket –socket=/tmp/mysql.sock 使用 TCP 连接： MySQL -uroot -p –protocol=tcp –host=127.0.0.1 –port=3306","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"启动多配置php-fpm","slug":"more_php_fpm","date":"2020-04-20T11:29:04.000Z","updated":"2020-04-20T11:30:01.000Z","comments":true,"path":"2020/04/20/more_php_fpm/","link":"","permalink":"http://yoursite.com/2020/04/20/more_php_fpm/","excerpt":"","text":"一。使用 tcp 方式进行配置 1.首先配置 php-fpm.conf 文件 /usr/local/php/etc/php-fpm.conf 2.复制多个 php-fpm.conf 文件 为 php-fpm2.conf php-fpm3.conf php-fpm4.conf 3.对每个配置文件进行配置不同端口 不同 pid 不同日志文件 如： 12345678910111213[global]pid &#x3D; &#x2F;usr&#x2F;local&#x2F;php&#x2F;var&#x2F;run&#x2F;php-fpm4.piderror_log &#x3D; &#x2F;usr&#x2F;local&#x2F;php&#x2F;var&#x2F;log&#x2F;php-fpm4.loglog_level &#x3D; notice[www]#listen &#x3D; &#x2F;tmp&#x2F;php-cgi.socklisten &#x3D; 127.0.0.1:10004 不同文件配置不同端口 4.启动多个 php.conf 主进程 1234567&#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin&#x2F;php-fpm -y &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf&#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin&#x2F;php-fpm -y &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm1.conf&#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin&#x2F;php-fpm -y &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm2.conf&#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin&#x2F;php-fpm -y &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm3.conf 5.对 nginx 进行配置 可以进行反向代理 也可以进行固定项目固定对应不同的 php-fpm 端口 固定配置如下 12345678910111213141516171819location ~ \\.php(.*)$ &#123; # fastcgi_pass unix:&#x2F;tmp&#x2F;php-cgi.sock; fastcgi_pass 127.0.0.1:9000; &#x2F;&#x2F;固定配置 fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(&#x2F;?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; &#125; 反向代理如下 在 nginx.conf 配置添加需要代理的端口 并在 http 代码里面添加 1234567891011upstream PHP &#123; server 127.0.0.1:9000; server 127.0.0.1:10002; server 127.0.0.1:10003; server 127.0.0.1:10004; &#125; 在配置文件 PHP 更改端口为 PHP 变量 12345678910111213141516171819location ~ \\.php(.*)$ &#123; # fastcgi_pass unix:&#x2F;tmp&#x2F;php-cgi.sock; fastcgi_pass php; &#x2F;&#x2F;随机使用 ip fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(&#x2F;?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; &#125; 6.重启某一个主进程 kill -USR2 9436 killall php-fpm 杀死所有 php-fpm 进程 二。使用 socket 进行配置是 1、第一步： 12345678910111213141516171819202122232425cp php-fpm.conf php-fpm2.confvi php-fpm2.conf 做相应的修改[global]#修改这里 1&#x2F;2pid &#x3D; &#x2F;usr&#x2F;local&#x2F;php&#x2F;var&#x2F;run&#x2F;php-fpm2.piderror_log &#x3D; &#x2F;usr&#x2F;local&#x2F;php&#x2F;var&#x2F;log&#x2F;php-fpm2.log#endlog_level &#x3D; notice[www]#修改这里 2&#x2F;2listen &#x3D; &#x2F;tmp&#x2F;php-cgi2.sock#end#listen &#x3D; 127.0.0.1:9000listen.backlog &#x3D; 2048listen.allowed_clients &#x3D; 127.0.0.1pm &#x3D; staticpm.max_children &#x3D; 200pm.start_servers &#x3D; 50pm.min_spare_servers &#x3D; 30pm.max_spare_servers &#x3D; 250request_terminate_timeout &#x3D; 0request_slowlog_timeout &#x3D; 2slowlog &#x3D; var&#x2F;log&#x2F;slow.log 2、第二步 123456789101112131415161718192021cp &#x2F;etc&#x2F;init.d&#x2F;php-fpm &#x2F;etc&#x2F;init.d&#x2F;php-fpm2 vi &#x2F;etc&#x2F;init.d&#x2F;php-fpm2 修改prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;phpexec_prefix&#x3D;$&#123;prefix&#125;php_fpm_BIN&#x3D;$&#123;exec_prefix&#125;&#x2F;sbin&#x2F;php-fpmphp_fpm_CONF&#x3D;$&#123;prefix&#125;&#x2F;etc&#x2F;php-fpm2.confphp_fpm_PID&#x3D;$&#123;prefix&#125;&#x2F;var&#x2F;run&#x2F;php-fpm2.pid","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"php--面试大全2","slug":"php_mianshi02","date":"2020-04-20T11:28:04.000Z","updated":"2020-04-20T11:28:49.000Z","comments":true,"path":"2020/04/20/php_mianshi02/","link":"","permalink":"http://yoursite.com/2020/04/20/php_mianshi02/","excerpt":"","text":"MySQL 的读写分离？1读写分离的实现原理就是在执行 SQL 语句的时候，判断到底是读操作还是写操作，把读的操作转向到读服务器上（从服务器，一般是多台），写的操作转到写的服务器上（主服务器，一般是一台，视数据量来看）。 2、说一下单引号双引号？ 123单引号内部的变量不会执行， 双引号会执行单引号解析速度比双引号快。单引号只能解析部分特殊字符，双引号可以解析所有特殊字符。 3、PHP7 的新特性？重点 123456789标量类型声明：PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float 和 bool 了。返回值类型声明：增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。NULL 合并运算符：由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为 NULL， 它就会返回自身的值，否则返回它的第二个操作数。use 加强：从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了匿名类：现在支持通过 new class 来实例化一个匿名类 4、PHP 数组排序 sort() - 以升序对数组排序 rsort() - 以降序对数组排序 asort() - 根据值，以升序对关联数组进行排序 ksort() - 根据键，以升序对关联数组进行排序 arsort() - 根据值，以降序对关联数组进行排序 krsort() - 根据键，以降序对关联数组进行排序 5.查看按址传递的引用 1234567&lt;?php$a &#x3D; &#39;abc&#39;;$b &#x3D; &amp;$a;unset($a);echo $b; &#x2F;&#x2F;abcecho $a; &#x2F;&#x2F;报错 消息队列是什么1消息队列主要用在系统解耦、流量削峰、异步处理、数据顺序处理等场景，特点先进先出 栈 后进先出 PHP 接口(interface)总结12接口是起到规范程序使用的对事物的抽象是指，区别两个不同事物之间的本质特征，这两个事物应该在某个视角上有明确的区分界限。 MySQL 索引类型1234567891、主键索引：主键索引是一种特殊的唯一索引，不允许有空值2、普通索引或者单列索引3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合 遵循最左原则4.唯一索引或者非唯一索引5.full text: 表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。 ### MySQL 常用储存引擎12345678910111213141516171819202122232425262728293031323334353637383940411.innoDB 2.MyISAM 3. MEMORY 4. MERGE&#x3D;&#x3D;MyISAM&#x3D;&#x3D;它不支持事务，也不支持外键，其优势是访问的速度快，对事务完整性没有要求的或者以 select&#x2F;insert 为主的应用基本上可以使用这个引擎来创建表。每个 MyISAM 在磁盘上都有 3 个文件，其文件名都与表名相同，但扩展名是：.frm(表定义) .MYD(MYDate：存储数据) .MYI(MYIndex：存储索引).MYD 文件和。MYI 文件可以放置在不同的目录中，通过 data directory 和 index directory 语句指定。 MyISAM 类型的表可能会损坏，可以使用 CHECK TABLE 语句来检查 MyISAM 表的健康，并用 REPAIR TABLE 语句修复一个损坏到 MyISAM 表。MyISAM 支持 3 种不同的存储格式：静态（固定长度）表 动态表 压缩表在静态表中，如果需要保存的内容后面本来就带有空格，那么在返回结果的时候会去掉公共的。 在动态表中，记录不固定，优点是占用空间相对比较少，缺点是频繁的更新和删除记录会产生碎片，需要定期执行 optimize table 来改善性能。 在压缩表中，由 myisampack 工具创建，占据非常小的磁盘空间。因为每个记录都被单独压缩的。&#x3D;&#x3D;InnoDB&#x3D;&#x3D;InnoDB 支持事务安全，对比 MyISAM 引擎，InnoDB 写的效率差一些，并且会占据更多的磁盘空间。InnoDB 自动增长列可以手工插入，但是插入的值是空或者 0，则实际插入的将是自动增长后的值。可以使用 last*insert*id()查询当前线程最后插入记录使用的值。可以通过 alert table *** auto_increment&#x3D;n;语句强制设置自动增长值。对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引到前面几列排序后递增的。**MySQL 支持外键的存储引擎只有 InnoDB**，在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 restrict、cascade、set null 和 no action。其中 restrict 和 no action 相同，是指限制在子表有关联的情况下，父表不能更新；casecade 表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被 set null。当某个表被其它表创建了外键参照，那么该表对应的索引或主键被禁止删除。可以使用 set foreign*key*checks&#x3D;0;临时关闭外键约束，set foreign*key*checks&#x3D;1;打开约束。 InnoDB 存储表和索引有如下两种方式：使用共享表空间存储。 使用多表空间存储。&#x3D;&#x3D;MEMORY&#x3D;&#x3D;memory 使用存在内存中的内容来创建表。每个 MEMORY 表实际对应一个磁盘文件，格式是。frm。MEMORY 类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用 HASH 索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。 每个 MEMORY 表中放置到数据量的大小，受到 max*heap*table*size 系统变量的约束，这个系统变量的初始值是 16M，同时在创建 MEMORY 表时可以使用 MAX*ROWS 子句来指定表中的最大行数。 memory 主要用于那些内容变化不频繁的代码表，或作为统计操作的中间结果表。&#x3D;&#x3D;MERGE&#x3D;&#x3D;merge 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表结构必须完全相同，MERGE 表中并没有数据，对 MERGE 类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的 MyISAM 表进行操作。对于对 MERGE 表进行的插入操作，是根据 INSERT_METHOD 子句定义的插入的表，可以有 3 个不同的值，first 和 last 值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为 NO，表示不能对这个 MERGE 表进行插入操作。 可以对 MERGE 表进行 drop 操作，这个操作只是删除 MERGE 表的定义，对内部的表没有任何影响。MERGE 在磁盘上保留 2 个以 MERGE 表名开头文件：.frm 文件存储表的定义；.MRG 文件包含组合表的信息，包括 MERGE 表由哪些表组成，插入数据时的依据。可以通过修改。MRG 文件来修改 MERGE 表，但是修改后要通过 flush table 刷新。 merge 表与分区表的区别是：merge 表不会智能的将记录写到对应的表中，而分区表可以的。 MySQL 字符集 utf8 和 utfmb4 的区别1那上面说了既然 utf8 能够存下大部分中文汉字，那为什么还要使用 utf8mb4 呢？ &#x3D;&#x3D; 原来 MySQL 支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面（BMP）。也就是说，任何不在基本多文本平面的 Unicode 字符，都无法使用 MySQL 的 utf8 字符集存储 &#x3D;&#x3D;。包括 Emoji 表情（Emoji 是一种特殊的 Unicode 编码，常见于 iOS 和 Android 手机上），和很多不常用的汉字，以及任何新增的 Unicode 字符等等。 主从复制的作用（好处，或者说为什么要做主从）重点！123451、做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。2、架构的扩展。业务量越来越大，I&#x2F;O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘 I&#x2F;O 访问的频率，提高单个机器的 I&#x2F;O 性能。3、读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表 SQL 语句非常的慢，导致锁表，影响前台服务。如果前台使用 master，报表使用 slave，那么报表 SQL 将不会造成前台锁，保证了前台速度。 主从复制的原理1234567891011121314151617181920212223242526271.数据库有个 bin-log 二进制文件，记录了所有 SQL 语句。2.我们的目标就是把主数据库的 bin-log 文件的 SQL 语句复制过来。3.让其在从数据的 relay-log 重做日志文件中再执行一次这些 SQL 语句即可。4.下面的主从配置就是围绕这个原理配置5.具体需要三个线程来操作：1.binlog 输出线程：每当有从库连接到主库的时候，主库都会创建一个线程然后发送 binlog 内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：2.从库 I&#x2F;O 线程：当 START SLAVE 语句在从库开始执行之后，从库创建一个 I&#x2F;O 线程，该线程连接到主库并请求主库发送 binlog 里面的更新记录到从库上。从库 I&#x2F;O 线程读取主库的 binlog 输出线程发送的更新并拷贝这些更新到本地文件，其中包括 relay log 文件。3.从库的 SQL 线程：从库创建一个 SQL 线程，这个线程读取从库 I&#x2F;O 线程写到 relay log 的更新事件并执行。可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个 binlog 输出线程，每一个从库都有它自己的 I&#x2F;O 线程和 SQL 线程。步骤一：主库 db 的更新事件(update、insert、delete)被写到 binlog步骤二：从库发起连接，连接到主库步骤三：此时主库创建一个 binlog dump thread 线程，把 binlog 的内容发送到从库步骤四：从库启动之后，创建一个 I&#x2F;O 线程，读取主库传过来的 binlog 内容并写入到 relay log.步骤五：还会创建一个 SQL 线程，从 relay log 里面读取内容，从 Exec*Master*Log_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的 db.","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"php---面试大全1","slug":"php_mianshi01","date":"2020-04-20T11:27:06.000Z","updated":"2020-04-20T11:27:48.000Z","comments":true,"path":"2020/04/20/php_mianshi01/","link":"","permalink":"http://yoursite.com/2020/04/20/php_mianshi01/","excerpt":"","text":"1.合并两个数组有几种方式，试比较它们的异同 12345671. array_merge() 2. ’+’ 3. array_merge_recursivearray_merge 简单的合并数组 array_merge_recursive 合并两个数组，如果数组中有完全一样的数据，将它们递归合并 array_combine 和 ‘+’ ：合并两个数组，前者的值作为新数组的键 2.什么是 mvc 123MVC 三层分别指：业务模型、视图、控制器，由控制器层调用模型处理数据，然后将数据映射到视图层进行显示。优点是：①可以实现代码的重用性，避免产生代码冗余；②M 和 V 的实现代码分离，从而使同一个程序可以使用不同的表现形式 3.Print、echo、print_r 有什么区别？ 123（1） echo和print都可以做输出，不同的是，echo不是函数，没有返回值，而print是一个函数有返回值，所以相对而言如果只是输出echo会更快，而print_r通常用于打印变量的相关信息，通常在调试中使用。（2） print 是打印字符串（3）print_r 则是打印复合类型 如数组 对象 4、SESSION 与 COOKIE 的区别？ 123（1）存储位置：session 存储于服务器，cookie 存储于浏览器（2）安全性：session 安全性比 cookie 高（3）session 为‘会话服务’，在使用时需要开启服务，cookie 不需要开启，可以直接用 5、PHP 处理数组的常用函数？（重点看函数的‘参数’和‘返回值’） 1234567891011121314151617181920212223（1）array() 创建数组（2）in_array() 判断元素是否在数组中（3）count() 返回数组中元素的数目（4）array_merge() 将多个数组合并成一个数组（5）array_diff() 比较两个或两个以上数组的差异（6）array_intersect() 获取两个或两个数组以上的交集（7）array_keys() 获取数组的key列表（8）array_values() 获取数组的值列表（9）array_unique() 删除数组中的重复值（10）array_push()将一个或多个元素插入数组的末尾（入栈）（11）array_pop() 弹出并返回 array 数组的最后一个单元（出栈）（12）array_walk() 使用用户自定义函数对数组中的每个元素做回调处理 6.PHP 处理字符串的常用函数？（重点看函数的‘参数’和‘返回值’） 123456789101112131415161718192021（1）trim() 移除字符串两侧的空白字符和其他字符；（2）strlen() 获取字符串的长度（3）mb_strlen() 获取字符串长度（可指定字符编码，对中文字符串计算长度）（4）substr()返回字符串的一部分；（5）str_replace() 子字符串替换（6）str_repeat () 重复一个字符串（7）is_string() 检测变量是否是字符串；（8）str_shuffle () 随机打乱一个字符串（9）sprintf() 返回根据格式化字符串生成的字符串（通常用于获取分表后的数据表名）（10）strstr() 查找字符串的首次出现（11）addslashes 使用反斜线引用字符串 7.PHP 处理时间的常用函数？（重点看函数的‘参数’和‘返回值’） 1234567891011121314（1）date() 格式化一个本地时间／日期。（2）getdate() 取得日期／时间信息。（3）date_default_timezone_set() 设定默认时区。（4）date_default_timezone_get() 返回默认时区。（5）mktime() 返回一个日期的 Unix 时间戳。（6）strtotime() 将任何字符串的日期时间描述解析为 Unix 时间戳（7）strftime() 根据区域设置格式化本地时间／日期 8.SQL 语言包括哪几部分？每部分都有哪些操作关键字？ 123456答：SQL 语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。数据定义：Create Table,Alter Table,Drop Table, Craete&#x2F;Drop Index 等数据操纵：Select ,insert,update,delete,数据控制：grant,revoke数据查询：select 9.什么是事务？及其特性？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。特性：（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。简单理解：在事务里的操作，要么全部成功，要么全部失败。&#x3D;&#x3D;1.隔离性 &#x3D;&#x3D;其实我们在《MySQL InnoDB 引擎 MVCC 并发控制》中谈到了事务的隔离级别，但没有谈到怎样实现隔离性。我们提到了要消除幻读，一般的数据库系统需要保证串行化的事务隔离级别，而 MySQL &#x3D;&#x3D;InnoDB 在可重复读的事务隔离级别下消除了幻读 &#x3D;&#x3D;，&#x3D;&#x3D; 功劳应该归于 Next-key Lock 锁 &#x3D;&#x3D;。这个具体详述在《MySQL InnoDB 中的行锁 Next-Key Lock 消除幻读》。那说了半天事务隔离级别，隔离性到底是如何实现的？其实在上面我们已经谈到了，是锁机制 +MVCC。我们通过 MVCC 使得事务隔离级别达到了可重复读，使用锁机制消除了幻读，实现了事务隔离。需要注意的是，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为串行化。&#x3D;&#x3D;2.持久性和原子性 &#x3D;&#x3D;通过数据库的 redo log 重做日志，来保证事务的持久性与原子性。&#x3D;&#x3D; 持久性 &#x3D;&#x3D;重做日志由两部分组成：重做日志缓冲（内存）和重做日志文件（物理存储）。当事务提交（commit）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务提交操作完成才算完成。redo log 重做日志基本上都是顺序写的。为了确保每次日志都写入重做日志文件，在每次将重做日志缓存写入重做日志文件后，InnoDB 存储引擎都需要调用一次 fsync（文件同步）操作。当然 MySQL 提供一些参数来调整缓冲刷新到文件的策略，在这里就不细讲了。&#x3D;&#x3D; 原子性 &#x3D;&#x3D;在 InnoDB 存储引擎中，重做日志都是以 512 字节进行存储的，称为重做日志块。若一个页中产生的重做日志数量大于 512 字节，那么需要分割为多个重做日志块进行存储。由于重做日志块的大小与磁盘扇区大小一样，都是 512 字节，因此重做日志的写入可以保证事务的原子性。重做日志块大小为 512 字节，但其中包含的有效存储为 492 字节，重做日志文件头占 12 字节，日志尾占 8 字节。&#x3D;&#x3D; 一致性 &#x3D;&#x3D;通过数据库的 undo log 撤销日志，来保证事务的一致性。 为了完成事务的回滚操作，在对数据库进行修改时，InnoDB 存储引擎不但会产生 redo log,还会产生一定量的 undo logo。undo log 是逻辑日志，只是将数据库逻辑地恢复到原来的样子，保证了事务的一致性（从一个状态转换为下一个一致性状态）。&#x3D;&#x3D;redu 和 undo 的区别 &#x3D;&#x3D; redo 恢复提交事务修改的页操作，undo 回滚行记录到某个特定版本。 redo 通常是物理日志，记录的是页的物理修改操作。undo 是逻辑日志，根据每行记录进行记录。undo 误解 通常对 undo 的误解是 undo 用于将数据库物理地恢复到执行语句或事务之前的样子。事实上，NO!!!举个栗子：一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。所以，在上面我们说道 undo log 是逻辑日志。undo 作用 除了回滚操作，undo 的另一个作用是 MVCC，在 InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读。 undo log 会产生 redo log，undo 操作需要持久性保护。&#x3D;&#x3D;MySQL 数据库的四种隔离级别 &#x3D;&#x3D;1、 Serializable (串行化)：可避免脏读、不可重读读、幻读的发生2、 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。3、 Read committed (读已提交)：可避免脏读的发生。4、 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。以上四种的隔离级别最高的 Serializable，最低的是 Read uncommitted，级别越高，虽然安全级别越高，但是执行的效率就越低，MySQL 中默认的隔离级别是：Repeatable read(可重复读)，Oracle 默认的隔离级别是：Read committed(读已提交)。这里需要注意的是，MySQL 支持以上四种隔离级别，但是 Oracle 只支持 Serializable(串行化)和 Read committed(读已提交)这两种隔离级别。 10.什么是锁？ 12345数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。基本锁类型：锁包括行级锁和表级锁 11.什么是存储过程？用什么来调用？ 12存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。 12.PHP 的垃圾回收机制 12345PHP 可以自动进行内存管理，清除不需要的对象。PHP 使用了引用计数(reference counting) GC 机制。每个对象都内含一个引用计数器 refcount，每个 reference 连接到对象，计数器加 1。当 reference 离开生存空间或被设为 NULL，计数器减 1。当某个对象的引用计数器为零时，PHP 知道你将不再需要使用这个对象，释放其所占的内存空间。 13.PHP 页面重定向的方法有哪些 123451. header(&#39;Location: http:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;) ;2. echo &#39;&lt;meta http-equiv&#x3D;&quot;Refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot; &gt;&#39;;3 echo &#39;&lt;script&gt;window.location.href&#x3D; www.baidu.com&lt;&#x2F;script&gt;&#39;; 14. 长连接、短连接的区别和使用 12345678910111213长连接：client 方与 server 方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于 P2P 通信。短连接：Client 方与 server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C&#x2F;S 通信。长连接与短连接的使用时机：长连接：短连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个 TCP 连 接的建立都需要三次握手，每个 TCP 连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据 就可以了，不用再建立 TCP 连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误，频繁的 socket 创建也是对资源的浪 费。短连接：Web 网站的 http 服务一般都用短连接。因为长连接对于服务器来说要耗费一定 的资源。像 Web 网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个 连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。 15.状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 123456789101112131415161718192021221xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求200 OK &#x2F;&#x2F;客户端请求成功400 Bad Request &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解401 Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务404 Not Found &#x2F;&#x2F;请求资源不存在，eg：输入了错误的 URL500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误503 Server Unavailable &#x2F;&#x2F;服务器超时 &#x2F;&#x2F;可能恢复正常304 Not Modifed &#x2F;&#x2F;自从上次请求后，请求的网页未修改过。 16. 预定义变量、魔术变量、魔术方法比较，及作用举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748预定义变量（超级全局变量）$GLOBALS$_SERVER$_GET$_POST$_COOKIE$_SESSION$_REQUEST$_ENV魔术方法__construct 和__destruct__autoload__get 和__set__isset 和__unset__call 和__callStatic__clone__toString__sleep 和__wakeup__invoke魔术变量__LINE____FILE____DIR____CLASS____FUNCTION____METHOD____NAMESPACE__ 17. PHP 设计模式 12345678910111213工厂模式建立一个工厂（一个函数或一个类方法）来制造新的对象工厂模式 是一种类，它具有为您创建对象的某些方法。您可以使用工厂类创建对象，而不直接使用 new。这样，如果您想要更改所创建的对象类型，只需更改该工厂即可。使用该工厂的所有代码会自动更改。单例模式某些应用程序资源是独占的，因为有且只有一个此类型的资源。例如，通过数据库句柄到数据库的连接是独占的。您希望在应用程序中共享数据库句柄，因为在保持连接打开或关闭时，它是一种开销，在获取单个页面的过程中更是如此。单元素模式可以满足此要求。PHP 中的单例模式（singleton pattern）：指的是在 PHP 的应用程序的范围内只对指定的类创建一个实例。 18.Redis 支持的数据类型？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143String 字符串：格式： set key valuestring 类型是二进制安全的。意思是 Redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象 。string 类型是 Redis 最基本的数据类型，一个键最大能存储 512MB。 Hash（哈希）格式： hmset name key1 value1 key2 value2Redis hash 是一个键值(key&#x3D;&gt;value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）格式： lpush name value在 key 对应 list 的头部添加字符串元素格式： rpush name value在 key 对应 list 的尾部添加字符串元素格式： lrem name indexkey 对应 list 中删除 count 个和 value 相同的元素格式： llen name 返回 key 对应 list 的长度 Set（集合）格式： sadd name valueRedis 的 Set 是 string 类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 zset(sorted set：有序集合)格式： zadd name score valueRedis zset 和 set 一样也是 string 类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。Redis 正是通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的，但分数(score)却可以重复。**什么是 Redis 持久化？Redis 有哪几种持久化方式？优缺点是什么？**持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式：RDB（默认） 和 AOF **RDB：**rdb 是 Redis DataBase 缩写功能核心函数 rdbSave(生成 RDB 文件)和 rdbLoad（从文件加载内存）两个函数**AOF:**Aof 是 Append-only file 缩写每当执行服务器(定时)任务或者函数时 flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof 写入保存：WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。**存储结构：** 内容是 Redis 通讯协议(RESP )格式的命令文本存储。**比较**：1. aof 文件比 rdb 更新频率高，优先使用 aof 还原数据。2. aof 比 rdb 更安全也更大3. rdb 性能比 aof 好4. 如果两个都配了优先加载 AOF**刚刚上面你有提到 Redis 通讯协议(RESP )，能解释下什么是 RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）**RESP 是 Redis 客户端和服务端之前使用的一种通讯协议；RESP 的特点：实现简单、快速解析、可读性好For Simple Strings the first byte of the reply is &quot;+&quot; 回复For Errors the first byte of the reply is &quot;-&quot; 错误For Integers the first byte of the reply is &quot;:&quot; 整数For Bulk Strings the first byte of the reply is &quot;$&quot; 字符串For Arrays the first byte of the reply is &quot;*&quot; 数组 **Redis 有哪些架构模式？讲讲各自的特点** **单机版**特点：简单问题：1. 内存容量有限 2、处理能力有限 3、无法高可用。**主从复制**Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。特点：1. master&#x2F;slave 角色2. master&#x2F;slave 数据相同3. 降低 master 读压力在转交从库 19.请选择以下代码运行的结果： &lt;?php if (&#39;1e3&#39; == &#39;1000&#39;) echo &#39;LOL&#39;; ?&gt; A 无任何输出结果 B LOL C 不执行且报错 1解析：1e3 是 科学计数法 实数的指数形式 为 1 乘以 10 的三次方，故‘1e3’&#x3D;&#x3D;&#39;1000&#39;是成立的，输出 echo ‘LOL’； 20、请选出以下代码运行的结果： &lt;?php $a = &quot;aabbzz&quot;; $a++; echo $a; ?&gt; A b B aabbzz C aabcaa 1解析： 字符串字母相加其实就是在末尾字母加一 如：$a &#x3D; &quot;a&quot;; $a++;答应结果就是 b,$a&#x3D;&#39;&#39;aa&#39;;结果就是 ab 故 $a &#x3D; &quot;aabb&quot;;打印结果就是 aabc ,如 $a &#x3D; &quot;aabbz&quot;;结果就是 aabca,因为 Z 是末尾字母故加一变为 a,向前一位进一，b 就变为 c,故结果为 C； 21，写出一下程序的输出结果： 12345678&lt;?php $data &#x3D; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]; foreach($data as $k&#x3D;&gt;$v)&#123; $v &#x3D; &amp;$data[$k];&#125;&gt; A $data = [‘a’,’b’,’c’]; B $data = [‘b’,’b’,’c’]; C $data = [‘b’,’c’,’c’]; 1解析：这里有个考点要记得 就是&amp;是引用；修改引用变量的值，那么空间的值也会改变，第一次循环 得到 $v&#x3D;&amp;$data[0]&#x3D;&gt;&#39;a&#39;,第二次循环$v&#x3D;&amp;$data[1]&#x3D;&gt;&#39;b&#39;,可见第一次引用的 $data[0]的值已经被改变，所以此时的 $data[0]&#x3D;b,此时 $v 引用的 $data[1],进入第三次循环 此时 $v 又变为 $v&#x3D;&amp;$data[2]&#x3D;&gt;&#39;c&#39;,,$v 又一次改变，引用的 $data[1]的值也被改变为 C，所以此时的 $data[1]&#x3D;c,这样循环结束 $data[0]&#x3D;&gt;&#39;b&#39;， $data[1]&#x3D;&gt;&#39;c&#39;， $data[2]&#x3D;&gt;&#39;c&#39;， 22，写出一下程序的输出结果： 12345678&lt;?php $a&#x3D; 0.1; $b &#x3D; 0.7;if($a+$b &#x3D;&#x3D;0.8)&#123; echo true; &#125;else&#123; echo false; &#125; &gt; A 空; B true; C false; D、1； E、0； F:报错 1 解析：这里的考点有两个：1，echo false 和 true 的值；2、浮点类型不能用于精确计算；首先浮点类型的数据不能用于计算，他会将浮点类型转为二进制，所以有一定的损耗，故它无限接近于 0.8，也就是 0.79999999...，所以 echo 应该是个 false；echo false；结果是空；echo true；结果是 1； 23，用 PHP 写出显示客户端的 IP 和服务端的 IP echo $_SERVER[‘REMOTE_ADDR’];//客户端 IP echo gethostbyname(“www.baidu.com”)//服务端 24.以下表达式的结果是： $a= 0; $b= 0; if($a= 3&gt;0 || $b= 3&gt;0){ $a++; $b++; } echo $a,$b; A 报错； B:1,1； (要是真的只有两个选项该多好肯定大家都选 B) 123解析：此题考查的是运算符的优先级问题，首先在此题中比较运算符 &gt; 逻辑运算符 &gt; 赋值，所以 1，先看 3&gt;0 为 true,2，因为是 || 运算所以后面的 $b&#x3D;3&gt;0 形成短路作用，这时的 $a&#x3D;true,$b&#x3D;0; 故 $a++;为 1；$b++;为 1 这里解释下布尔类型运算不影响布尔类型结果；但是 $b&#x3D;0;$b++;就改变为 1， echo true；结果为 1， 25.用正则 写出以 139 开头的手机号码 $str = ‘13812345678’;$pattern = ‘/^139\\d{8}$/‘;preg_match($pattern,$str,$macth);var_dump($macth); 26.用PHP方式对目录进行遍历 12345678910111213$dir &#x3D; &#39;.&#x2F;test&#39;;function loopDir($dir)&#123; $handle &#x3D; opendir($dir); while(false !&#x3D;&#x3D;($file &#x3D;readdir($handle)))&#123; if($file!&#x3D;&#39;.&#39;&amp;&amp;$file!&#x3D;&#39;..&#39;)&#123; echo $file.&quot;&lt;br&gt;&quot;; if(filetype($dir.&#39;&#x2F;&#39;.$file)&#x3D;&#x3D;&#39;dir&#39;)&#123; loopDir($dir.&#39;&#x2F;&#39;.$file); &#125; &#125; &#125;&#125; loopDir($dir); 27.请简单叙述 CGI fastCGI h和 PHP-FPM的区别CGI 代表为了联系PHP 和websevae 的一个桥梁fastCGI 是CGI的改良版PHP-FPM 进程管理器 28.冒泡排序很实用要记得 1234567891011121314function maopao($arr)&#123; $len &#x3D; count($arr); $n &#x3D; count($arr)-1; for($i&#x3D;0;$i&lt;$len;$i++)&#123; for($j&#x3D;0;$j&lt;$n;$j++)&#123; if($arr[$j]&lt;$arr[$j+1])&#123; $temp &#x3D; $arr[$j+1]; $arr[$j+1] &#x3D; $arr[$j]; $arr[$j] &#x3D;$temp; &#125; &#125; &#125; return $arr;&#125; 29.快速排序 1234567891011121314151617181920212223242526272829function quick_sort($array) &#123; if (count($array) &lt;&#x3D; 1) return $array; $key &#x3D; $array[0]; $left_arr &#x3D; array(); $right_arr &#x3D; array(); for ($i&#x3D;1; $i&lt;count($array); $i++)&#123; if ($array[$i] &lt;&#x3D; $key) $left_arr[] &#x3D; $array[$i]; else $right_arr[] &#x3D; $array[$i]; &#125; $left_arr &#x3D; quick_sort($left_arr); $right_arr &#x3D; quick_sort($right_arr); return array_merge($left_arr, array($key), $right_arr);&#125; 30.请说明 PHP 中传值与传引用的区别，什么时候传值什么时候传引用？**** 按值传递：函数范围内对值的任何改变在函数外部都会被忽略 按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改 优缺点：按值传递时，PHP 必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。 按引用传递则不需要复制值，对于性能提高很有好处。 31.MySQL 数据库中的字段类型 varchar 和 char 的主要区别是什么？ 123 char 和 varchar 最大的不同就是一个是固定长度，一个是可变长度。由于是可变长度，因此存储的是实际字符串再加上一个记录字符串长度的字节。如果分配给 char 或 varchar 列的值超过 列的最大长度，则对值进行裁剪。 varchar(M)和 char(M),M 都表示字符数。varchar 的最大长度为 65535 个字节，不同的编码所对应的最大可存储的字符数不同。char 最多可以存放 255 个字符，不同的编码最大可用字节数不同 32.对于大流量的网站，采用什么样的方法来解决访问量问题？ 12345671. 确认服务器硬件是否足够支持当前的流量 1. 优化数据库访问。 1. 禁止外部的盗链。 1. 控制大文件的下载。 1. 使用不同主机分流主要流量 1. 使用流量分析统计软件 1. 尽量使用静态页，缓存 33.什么是面向对象？主要特征是什么？ 面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态。 34、SESSION 与 COOKIE 的区别是什么？ 1SESSION 存储在服务器端，COOKIE 保存在客户端。Session 比较安全，cookie 用某些手段可以修改，不安全。Session 依赖于 cookie 进行传递。禁用 cookie 后，session 还可以使用，在存储 session 的文件中，生成 sessionID，通过 get 传参的方式将 sessionID 传到要实现 session 共享的页面，读取 sessionID,从而从 session 中获取数据。 35、对缓存技术的了解 1、缓存技术是将动态内容缓存到文件中，在一定时间内访问动态页面直接调用缓存文件，而不必重新访问数据库。 2、使用 memcache 可以做缓存。 36、表单中 get 和 post 提交方式的区别？ get 是显式的，数据从 url 中可以看到，传输的数据量小，安全性低； post 是隐式的，传送的数据量较大，安全性较高 37、优化 MySQL 数据库的方法 1，数据表中的数据类型的优化 如选择合适的字段，选择效率快速的字段 2，索引优化 3、SQL 语句的优化 （1）优化查询过程中的数据访问如使用 limit、使用返回列不用* （2）优化长难句的查询语句 变复杂为简单、切分查询、分解关联查询 （3）优化特定类型的查询语句如优化 count()、优化关联查询、优化子查询、优化 Group by、优化 li’mit 4、存储引擎的优化 （1）尽量使用 InnoDB 存储引擎，因为它支持事务、外键、使用独立表空间、使用的是行级锁、 5、数据表结构的设计优化 （1）分区操作 如通过特定的策略对数据进行物理拆分、对用户透明的、partition by （2）分库分表 如水平拆分（以行级进行拆分）、垂直拆分（列及拆分） 6、数据架构的优化 （1）主从复制 （2）读写分离 （3）双主热备 （4）负载均衡 通过 LVS 的三种模式实现的、Mycat 数据库中间件实现的 38、语句 include 和 require 的区别是什么？ require 是无条件包含，也就是如果一个流程里加入 require，无论条件成立与否都会先执行 require，当文件不存在或者无法打开的时候，会提示错误，并且会终止程序执行 include 有返回值，而 require 没有(可能因为如此 require 的速度比 include 快)，如果被包含的文件不存在的化，那么会提示一个错误，但是程序会继续执行下去 39、Redis 和 memcacahe、MongoDB 的区别？ 12345 都是非关系型数据库，性能都非常高，但是 MongoDB 和 memcache、Redis 是不同的两种类型。后两者主要用于数据的缓存，前者主要用在查询和储存大数据方面，是最接近数据库的文档型的非关系数据库。 从数据存储位置上来分，memcache 的数据存在内存中，而 Redis 既可以存储在内存中，也可以存储的到磁盘中，达到持久化存储的功能，memcache 一旦断电，数据全部丢失，Redis 可以利用快照和 AOF 把数据存到磁盘中，当恢复时又从磁盘中读取到内存中，当物理内存使用完毕后，可以把数据写入到磁盘中。 从存储数据的类型上来分，memcache 和 Redis 存储的方式都是键值对，只不过 Redis 值的类型比较丰富，有 string(字符串),hash(哈希)，list(列表),set(集合)zset(有序集合)，而 memcache 主要存储的是字符串。 40、PHP 的基本变量类型 12345 四种标量类型：boolean （布尔型）、integer （整型）、float （浮点型， 也称作 double)、string （字符串） 两种复合类型：array （数组）、object （对象） 最后是两种特殊类型：resource（资源）、NULL（NULL） 42、静态化如何实现的？伪静态如何实现？ 12345678910111213 1、 静态化指的是页面静态化，也即生成实实在在的静态文件，也即不需要查询数据库就可以直接从文件中获取数据，指的是真静态。 实现方式主要有两种： 一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术。 一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，如果存在就读缓存，不存在就读数据库，同时生成缓存文件。 2、伪静态不是真正意义上的静态化，之所以使用伪静态，主要是为了 SEO 推广，搜索引擎对动态的文件获取难度大，不利于网站的推广。实习原理是基于 Apache 或 Nginx 的 rewrite 机智 主要有两种方式： 一种是直接在配置虚拟机的位置配置伪静态，这个每次修改完成后需要重启 Web 服务器。 另一种采用分布式的，可以在网站的根目录上创建。htaccess 的文件，在里面配置相应的重写规则来实现伪静态，这种每次重写时不需要重启 Web 服务器，且结构上比较清晰。 43、如何处理负载，高并发 123456789101、HTML 静态化效率最高、消耗最小的就是纯静态化的 HTML 页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。2、图片服务器分离把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如七牛等3、数据库集群和库表散列及缓存数据库的并发连接为 100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如 memcache、Redis。4、镜像：尽量减少下载，可以把不同的请求分发到多个镜像端。5、负载均衡：Apache 的最大并发连接为 1500，只能增加服务器，可以从硬件上着手，如 F5 服务器。当然硬件的成本比较高，我们往往从软件方面着手。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"laraval -- 路由的用法","slug":"laravel02","date":"2020-04-20T11:25:44.000Z","updated":"2020-04-20T11:26:33.000Z","comments":true,"path":"2020/04/20/laravel02/","link":"","permalink":"http://yoursite.com/2020/04/20/laravel02/","excerpt":"","text":"1.路由的用法构建最基本的路由只需要一个 URI 与一个 闭包，这里提供了一个非常简单优雅的定义路由的方法： 123Route::get(&#39;foo&#39;, function () &#123; return &#39;Hello World&#39;;&#125;); 2.第二种用法 123456Route::get(&#39;&#x2F;user&#39;, &#39;UserController@index&#39;);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback); 3.注册一个可响应多个 HTTP 请求的路由，这时你可以使用 match 方法，也可以使用 any 方法注册一个实现响应所有 HTTP 请求的路由* 1234567Route::match([&#39;get&#39;, &#39;post&#39;], &#39;&#x2F;&#39;, function () &#123; &#x2F;&#x2F;&#125;);Route::any(&#39;foo&#39;, function () &#123; &#x2F;&#x2F;&#125;); 4.重定向路由 1Route::redirect(&#39;&#x2F;here&#39;, &#39;&#x2F;there&#39;, 301);redirect(&#39;&#x2F;here&#39;, &#39;&#x2F;there&#39;, 301);(&#39;&#x2F;here&#39;, &#39;&#x2F;there&#39;, 301);&#39;&#x2F;here&#39;, &#39;&#x2F;there&#39;, 301);, &#39;&#x2F;there&#39;, 301); &#39;&#x2F;there&#39;, 301);&#39;&#x2F;there&#39;, 301);, 301); 301);301););; 如果你的路由只需要返回一个视图，可以使用 Route::view 方法。它和 redirect 一样方便，不需要定义完整的路由或控制器。view 方法有三个参数，其中前两个是必填参数，分别是 URI 和视图名称。第三个参数选填，可以传入一个数组，数组中的数据会被传递给视图 12Route::view(&#39;&#x2F;welcome&#39;, &#39;welcome&#39;);Route::view(&#39;&#x2F;welcome&#39;, &#39;welcome&#39;, [&#39;name&#39; &#x3D;&gt; &#39;Taylor&#39;]); 5.路由参数当然，有时需要在路由中捕获一些 URL 片段。例如，从 URL 中捕获用户的 ID，可以通过定义路由参数来执行此操作： 123Route::get(&#39;user&#x2F;&#123;id&#125;&#39;, function ($id) &#123; return &#39;User &#39;.$id;&#125;); 也可以根据需要在路由中定义多个参数： 123Route::get(&#39;posts&#x2F;&#123;post&#125;&#x2F;comments&#x2F;&#123;comment&#125;&#39;, function ($postId, $commentId) &#123; &#x2F;&#x2F;&#125;); 路由的参数通常都会被放在 {} 内，并且参数名只能为字母，同时路由参数不能包含 - 符号，如果需要可以用下划线 (_) 代替。路由参数会按顺序依次被注入到路由回调或者控制器中，而不受回调或者控制器的参数名称的影响。 可选参数有时，你可能需要指定一个路由参数，但你希望这个参数是可选的。你可以在参数后面加上 ? 标记来实现，但前提是要确保路由的相应变量有默认值： 1234567Route::get(&#39;user&#x2F;&#123;name?&#125;&#39;, function ($name &#x3D; null) &#123; return $name;&#125;);Route::get(&#39;user&#x2F;&#123;name?&#125;&#39;, function ($name &#x3D; &#39;John&#39;) &#123; return $name;&#125;); 正则表达式约束你可以使用路由实例上的 where 方法约束路由参数的格式。where 方法接受参数名称和定义参数应如何约束的正则表达式： 1234567891011Route::get(&#39;user&#x2F;&#123;name&#125;&#39;, function ($name) &#123; &#x2F;&#x2F;&#125;)-&gt;where(&#39;name&#39;, &#39;[A-Za-z]+&#39;);Route::get(&#39;user&#x2F;&#123;id&#125;&#39;, function ($id) &#123; &#x2F;&#x2F;&#125;)-&gt;where(&#39;id&#39;, &#39;[0-9]+&#39;);Route::get(&#39;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&#39;, function ($id, $name) &#123; &#x2F;&#x2F;&#125;)-&gt;where([&#39;id&#39; &#x3D;&gt; &#39;[0-9]+&#39;, &#39;name&#39; &#x3D;&gt; &#39;[a-z]+&#39;]);","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"laravel的基本用法","slug":"laravel01","date":"2020-04-20T11:24:53.000Z","updated":"2020-04-20T11:25:25.000Z","comments":true,"path":"2020/04/20/laravel01/","link":"","permalink":"http://yoursite.com/2020/04/20/laravel01/","excerpt":"","text":"1.首先设置key安装 Laravel 之后下一件应该做的事就是将应用程序的密钥设置为随机字符串。如果你是通过 Composer 或 Laravel 安装器安装的 Laravel，那这个密钥已经为你通过 1php artisan key:generate 命令设置好了。 通常来说，这个字符串长度为 32 个字符。密钥可以在 .env 环境文件中设置。前提是你要将 .env.example 文件重命名为 .env。如果应用程序密钥没有被设置，就不能确保你的用户会话和其他加密数据的安全！ 2.laravel设置维护模式要启用维护模式，只需执行下面的 Artisan 命令 down： 1php artisan down 你还可以向 down 命令提供 message 和 retry 选项。其中 message 选项的值可用于显示或记录自定义消息，而 retry 值可用于设置 HTTP 请求头中 Retry-After 的值： 1php artisan down --message&#x3D;&quot;Upgrading Database&quot; --retry&#x3D;60 即使在维护模式下，也可以使用命令 allow 选项允许特定的 IP 地址或网络访问应用程序： 1php artisan down --allow&#x3D;127.0.0.1 --allow&#x3D;192.168.0.0&#x2F;16 要关闭维护模式，请使用 up 命令： 1php artisan up 3.Artisan命令生成工具eptions 目录包含了应用的异常处理器，也是应用抛出异常的好地方。如果想自定义记录或者渲染异常的方式，你就要修改此目录下的 Handler 类。 Http 目录Http 目录包含了控制器、中间件和表单请求。几乎所有的进入应用的请求的处理逻辑都被放在这里。 Jobs 目录Jobs 目录默认是不存在的，它会在你运行 Artisan 命令 make:job 时生成。这个目录存放了应用中的 队列任务 。 应用的任务可以被推送到队列或者在当前请求的生命周期内同步运行。在当前请求期间同步运行的任务可以看做是一个「命令」，因为它们是 命令模式 的实现。 Listeners 目录Listeners 目录默认是不存在的，它会在你运行 Artisan 命令 event:generate 或 make:listener 时生成。Listeners 目录包含了用来处理 事件 的类。事件监听器接收事件实例并执行响应该事件被触发的逻辑。例如， UserRegistered 事件可能由 SendWelcomeEmail 监听器处理。 Mail 目录Mail 目录默认不存在，它会在你运行 Artisan 命令 make:mail 时生成。 Mail 目录包含应用所有的邮件发送类。邮件对象允许你将邮件的逻辑封装单个类中，邮件对象还可以使用 Mail::send 方法来发送邮件。 Notifications 目录Notifications 目录默认不存在，它会在你运行 Artisan 命令 make:notification 时生成。 Notifications 目录包含应用发送的所有「业务性」通知，比如关于在应用中发生的事件的简单通知。Laravel 的通知功能抽象了发送通知接口，你可以通过各种驱动（例如邮件、Slack、短信）发送通知，或是存储在数据库中。 Policies 目录Policies 目录默认不存在，它会通过运行 Artisan 命令 make:policy 来创建。 Policies 目录包含了应用的授权策略类。策略可以用来决定一个用户是否有权限去操作指定资源。更多详情可以查看 授权文档。 Providers 目录Providers 目录包含了应用的所有 服务提供者 。服务提供者通过在服务容器中绑定服务、注册事件、以及执行其他任务来为即将到来的请求做准备来启动应用。 在一个新的 Laravel 应用里，Providers 目录已经包含了一些服务提供者。你可以按照需要把自己的服务提供者添加到该目录。 Rules 目录Rules 目录默认不存在，它会在运行 Artisan 命令 make:rule 命令时被创建。Rules 目录包含应用自定义验证规则对象。这些规则意在将复杂的验证逻辑封装在一个简单的对象中。 4.优化自动加载部署项目到生产环境时，请确保你优化了 Composer 类的自动加载映射，以便 Composer 可以快速找到正确文件为给定类加载： 1composer install --optimize-autoloader --no-dev {tip} 除了优化自动加载之外，还应该确保项目的源代码管理库中包含了 composer.lock 文件。因为当 composer.lock 文件存在时，项目的依赖项可以被更快地安装。 优化配置加载当你将应用部署到生产环境时，请确保在部署过程中运行 Artisan 命令： 1php artisan config:cache 这个命令可以将所有 Laravel 的配置文件合并到单个文件中缓存，此举能大大减少框架在加载配置值时必须执行的系统文件的数量。 {note} 如果你在部署过程中执行了 config:cache 命令，那么你应该确保仅在配置文件中调用了 env 函数，一旦配置被缓存了，将不会加载 .env 文件，（除配置文件外）对 env 函数的所有调用都将返回 null。 优化路由加载如果你构建的是具有许多路由的大型应用程序，那你应该在部署过程中运行 Artisan 命令 route:cache ： 1php artisan route:cache 这个命令可以将所有路由注册减少为缓存文件中的单个方法调用，以达到当应用程序在注册数百条路由时，提高路由注册的性能。 {note} 由于此功能使用 PHP 序列化，而 PHP 无法序列化闭包，因此只能缓存应用程序中基于控制器的路由。 5.数据库迁移 1php artisan make:migration create_users_table &#x2F;&#x2F;在目录下创建一张表 新的迁移位于 database/migrations 目录下。每个迁移文件名都包含时间戳，以便让 Laravel 确认迁移的顺序。 –table 和 –create 选项可用来指定数据表的名称，或是该迁移被执行时是否将创建的新数据表。这些选项需在预生成迁移文件时填入指定的数据表： 123php artisan make:migration create_users_table --create&#x3D;usersphp artisan make:migration add_votes_to_users_table --table&#x3D;users 如果你想要指定生成迁移指定一个自定义输出路径，则可以在运行 make:migration 命令时添加 –path 选项，给定的路径必须是相对于应用程序的基本路径。 1php artisan migrate &#x2F;&#x2F;迁移到数据库","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"swoole--简单实现数据转发","slug":"swoole_round","date":"2020-04-20T11:23:31.000Z","updated":"2020-04-20T11:24:16.000Z","comments":true,"path":"2020/04/20/swoole_round/","link":"","permalink":"http://yoursite.com/2020/04/20/swoole_round/","excerpt":"","text":"前段文件 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script&gt; &#x2F;&#x2F;http ws &#x3D; new Websocket(&#39;ws:&#x2F;&#x2F;127.0.0.1:9502&#39;); console.log(ws); ws.onopen&#x3D;function (event) &#123; &#x2F;&#x2F; alert(&#39;连接成功&#39;); ws.send(&#39;hello word!&#39;); &#125; ws.onmessage &#x3D; function($data)&#123; console.log($data.data); &#125; ws.onclose&#x3D;function (e) &#123; alert(&#39;连接失败！&#39;); &#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; php文件* 123456789101112131415161718192021222324252627282930313233343536&lt;?php&#x2F;** * 接收内容推送服务器的消息 转发给消息接收服务端 *&#x2F;$serv &#x3D; new swoole_websocket_server(&#39;127.0.0.1&#39;, 9502);&#x2F;&#x2F;当监听到客户连接服务器$serv-&gt;on(&#39;open&#39;, function () &#123; echo &#39;用户连接上来&#39; . PHP_EOL;&#125;);&#x2F;&#x2F;当客户端发送消息过来时 会触发$serv-&gt;on(&#39;message&#39;, function ($server, $frame) &#123;&#x2F;&#x2F; echo &#39;有用户发送消息过来！&#39;.PHP_EOL;&#x2F;&#x2F;转发消息给客户端 $data &#x3D; $frame-&gt;data;&#x2F;&#x2F; var_dump($server); &#x2F;&#x2F;conection_list 所有连接的用户 并转发数据 foreach ($server-&gt;conection_list() as $v) &#123; &#x2F;&#x2F;redis &#x2F;&#x2F;将消息发送给某一个用户 $server-&gt;push($v, $data); &#125;&#125;);$serv-&gt;on(&#39;close&#39;, function () &#123; echo &#39;用户关闭连接&#39; . PHP_EOL;&#125;);&#x2F;&#x2F;开启服务$serv-&gt;start();","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"PhpStorm 增加Swoole智能提示","slug":"swoole_up","date":"2020-04-20T11:22:24.000Z","updated":"2020-04-20T11:23:06.000Z","comments":true,"path":"2020/04/20/swoole_up/","link":"","permalink":"http://yoursite.com/2020/04/20/swoole_up/","excerpt":"","text":"下载 https://github.com/eaglewu/swoole-ide-helper 源码 将代码包含到 PhpStorm 的包的任何路径下面 找到设置 Settings-&gt;Languages &amp; Frameworks-&gt;PHP-&gt;inclue path 把文件的路径填写进去就ok","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"linux sed命令详解","slug":"sed","date":"2020-04-20T11:21:11.000Z","updated":"2020-04-20T11:21:49.000Z","comments":true,"path":"2020/04/20/sed/","link":"","permalink":"http://yoursite.com/2020/04/20/sed/","excerpt":"","text":"简介sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed 主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 sed 使用参数123456789101112131415161718[root@www ~]# sed [-nefr] [动作]选项与参数：-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。-e ：直接在命令列模式上进行 sed 的动作编辑；-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)-i ：直接修改读取的文件内容，而不是输出到终端。动作说明： [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』function：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s&#x2F;old&#x2F;new&#x2F;g 就是啦！ 以行为单位的新增/删除将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！ 12345[root@www ~]# nl &#x2F;etc&#x2F;passwd | sed &#39;2,5d&#39;1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown.....(后面省略)..... sed 的动作为 ‘2,5d’ ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗 ～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！ 只要删除第 2 行 1nl &#x2F;etc&#x2F;passwd | sed &#39;2d&#39; 要删除第 3 到最后一行 1nl &#x2F;etc&#x2F;passwd | sed &#39;3,$d&#39; 在第二行后(亦即是加在第三行)加上『drink tea?』字样！ 123456[root@www ~]# nl &#x2F;etc&#x2F;passwd | sed &#39;2a drink tea&#39;1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash2 bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologindrink tea3 daemon:x:2:2:daemon:&#x2F;sbin:&#x2F;sbin&#x2F;nologin.....(后面省略)..... 那如果是要在第二行前 1nl &#x2F;etc&#x2F;passwd | sed &#39;2i drink tea&#39; 如果是要增加两行以上，在第二行后面加入两行字，例如『Drink tea or …..』与『drink beer?』 12345678[root@www ~]# nl &#x2F;etc&#x2F;passwd | sed &#39;2a Drink tea or ......\\&gt; drink beer ?&#39;root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashbin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologinDrink tea or ......drink beer ?daemon:x:2:2:daemon:&#x2F;sbin:&#x2F;sbin&#x2F;nologin.....(后面省略)..... 每一行之间都必须要以反斜杠『 \\ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \\ 存在。 以行为单位的替换与显示 将第 2-5 行的内容取代成为『No 2-5 number』呢？ 12345[root@www ~]# nl &#x2F;etc&#x2F;passwd | sed &#39;2,5c No 2-5 number&#39;1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashNo 2-5 number6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync.....(后面省略)..... 透过这个方法我们就能够将数据整行取代了！ 仅列出 /etc/passwd 文件内的第 5-7 行 1234[root@www ~]# nl &#x2F;etc&#x2F;passwd | sed -n &#39;5,7p&#39;5 lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown 可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。 数据的搜寻并显示搜索 /etc/passwd 有 root 关键字的行 12345678nl &#x2F;etc&#x2F;passwd | sed &#39;&#x2F;root&#x2F;p&#39;1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash2 daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;bin&#x2F;sh3 bin:x:2:2:bin:&#x2F;bin:&#x2F;bin&#x2F;sh4 sys:x:3:3:sys:&#x2F;dev:&#x2F;bin&#x2F;sh5 sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync....下面忽略 [![复制代码] 如果 root 找到，除了输出所有行，还会输出匹配行。 使用-n 的时候将只打印包含模板的行。 12nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;p&#39;1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash 数据的搜寻并删除删除/etc/passwd 所有包含 root 的行，其他行输出 1234nl &#x2F;etc&#x2F;passwd | sed &#39;&#x2F;root&#x2F;d&#39;2 daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;bin&#x2F;sh3 bin:x:2:2:bin:&#x2F;bin:&#x2F;bin&#x2F;sh....下面忽略 #第一行的匹配 root 已经删除了 1234[root@www ~]# nl &#x2F;etc&#x2F;passwd | sed -n &#39;5,7p&#39;5 lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown 数据的搜寻并执行命令找到匹配模式 eastern 的行后， 搜索/etc/passwd,找到 root 对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把 bash 替换为 blueshell，再输出这行： 12nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;&#123;s&#x2F;bash&#x2F;blueshell&#x2F;;p&#125;&#39; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;blueshell 如果只替换/etc/passwd 的第一个 bash 关键字为 blueshell，就退出 12nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;bash&#x2F;&#123;s&#x2F;bash&#x2F;blueshell&#x2F;;p;q&#125;&#39; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;blueshell 最后的 q 是退出。 数据的搜寻并替换除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样： sed ‘s/要被取代的字串/新的字串/g’ 先观察原始信息，利用 /sbin/ifconfig 查询 IP 123456[root@www ~]# &#x2F;sbin&#x2F;ifconfig eth0eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0inet6 addr: fe80::290:ccff:fea6:3484&#x2F;64 Scope:LinkUP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1.....(以下省略)..... 本机的 ip 是 192.168.1.100。 将 IP 前面的部分予以删除 12[root@www ~]# &#x2F;sbin&#x2F;ifconfig eth0 | grep &#39;inet addr&#39; | sed &#39;s&#x2F;^.*addr:&#x2F;&#x2F;g&#39;192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 将 IP 后面的部分予以删除 12[root@www ~]# &#x2F;sbin&#x2F;ifconfig eth0 | grep &#39;inet addr&#39; | sed &#39;s&#x2F;^.*addr:&#x2F;&#x2F;g&#39; | sed &#39;s&#x2F;Bcast.*$&#x2F;&#x2F;g&#39;192.168.1.100 多点编辑一条 sed 命令，删除/etc/passwd 第三行到末尾的数据，并把 bash 替换为 blueshell 123nl &#x2F;etc&#x2F;passwd | sed -e &#39;3,$d&#39; -e &#39;s&#x2F;bash&#x2F;blueshell&#x2F;&#39;1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;blueshell2 daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;bin&#x2F;sh -e 表示多点编辑，第一个编辑命令删除/etc/passwd 第三行到末尾的数据，第二条命令搜索 bash 替换为 blueshell。 直接修改文件内容(危险动作)sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用下载的 regular_express.txt 文件来测试看看吧！ 利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 ! 1[root@www ~]# sed -i &#39;s&#x2F;\\.$&#x2F;\\!&#x2F;g&#39; regular_express.txt 利用 sed 直接在 regular_express.txt 最后一行加入『# This is a test』 1[root@www ~]# sed -i &#39;$a # This is a test&#39; regular_express.txt 由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增『# This is a test』！ sed 的『 -i 』选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 VIM 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 VIM 去修订！","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"PHP file_get_contents函数详解","slug":"file_get_contents","date":"2020-04-20T11:19:30.000Z","updated":"2020-04-20T11:20:13.000Z","comments":true,"path":"2020/04/20/file_get_contents/","link":"","permalink":"http://yoursite.com/2020/04/20/file_get_contents/","excerpt":"","text":"*一。 file_get_contents(path,include_path,context,start,max_length) * 参数 描述 参数 必需。规定要读取的文件。 include_path* 可选。如果也想在 include_path 中搜寻文件的话，可以将该参数设为 “1”。 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 null，则忽略。 start 可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 新加的。 max_length 可选。规定读取的字节数。该参数是 PHP 5.1 新加的。 1,此函数可以用来打开一个网络地址 可以实现简单的网页抓取2.此函数可以读取本地的文件3.此函数可以模拟 post 请求 网页抓取 一般用 file_get_contents 或者 fopen, file , readfile 等函数读取 url 的时候 会创建一个 $http_response_header 变量保存 HTTP 响应的报头，使用 fopen 等函数打开的数据流信息可以用 stream_get_meta_data 获取 12345$html &#x3D; file_get_contents(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;);print_r($http_response_header);$fp &#x3D; fopen(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;, &#39;r&#39;);print_r(stream_get_meta_data($fp));fclose($fp); 模拟 post 请求 test.php 12345678910111213141516$url &#x3D; &#39;http:&#x2F;&#x2F;192.168.31.63&#x2F;2.php&#39;;$data &#x3D; array( &#39;item&#39; &#x3D;&gt; &#39;test data&#39;,);$content &#x3D; http_build_query($data);$content_length &#x3D; strlen($content);$options &#x3D; array( &#39;http&#39; &#x3D;&gt; array( &#39;method&#39; &#x3D;&gt; &#39;POST&#39;, &#39;header&#39; &#x3D;&gt; &quot;Content-type: application&#x2F;x-www-form-urlencoded\\r\\n&quot; . &quot;Content-length: $content_length\\r\\n&quot;, &#39;content&#39; &#x3D;&gt; $content ));echo file_get_contents($url, false, stream_context_create($options)); 2.php 12345678&lt;?php&#x2F;** * @Author: anchen * @Date: 2017-03-23 13:51:46 * @Last Modified by: anchen * @Last Modified time: 2017-03-23 13:53:46 *&#x2F;file_put_contents(&#39;.&#x2F;1.txt&#39;, var_export($_POST, true));&#x2F;&#x2F;把接收的数据储存起来 下面写一个贴近一点的例子 12345678910111213141516171819$data &#x3D; [ &#39;author&#39; &#x3D;&gt; &#39;白菜打下&#39;, &#39;mail&#39; &#x3D;&gt; &#39;info@aiyooyoo.com&#39;, &#39;text&#39; &#x3D;&gt; &#39;博主很给力&#39;,];$data &#x3D; http_build_query($data);$opts &#x3D; [ &#39;http&#39; &#x3D;&gt; [ &#39;method&#39; &#x3D;&gt; &#39;POST&#39;, &#39;header&#39; &#x3D;&gt; &quot;Content-type:application&#x2F;x-www-form-urlencoded\\r\\n&quot;. &quot;Content-Length: &quot;.strlen($data).&quot;\\r\\n&quot;. &quot;Cookie: PHPSESSID&#x3D;13ROTEGFGJDFDFDOGDFGD&quot;.&quot;\\r\\n&quot;. &quot;User-Agent: Mozilla&#x2F;5.0(Windows: U; Windows NT 6.1; zh-CH; rv: 1.9.2.13) Gecko&#x2F;20101203 Firefox&#x2F;3.6.13&quot;.&quot;\\r\\n&quot;. &quot;Referer:http:&#x2F;&#x2F;aiyooyoo.com&#x2F;index.php&#x2F;archives&#x2F;7&#x2F;&quot;.&quot;\\r\\n&quot;, &#39;content&#39; &#x3D;&gt; $data, ],];$context &#x3D; stream_context_create($opts);$html &#x3D; @file_get_contents(&#39;http:&#x2F;&#x2F;aiyooyoo.com&#x2F;index.php&#x2F;archives&#x2F;7&#x2F;comment&#39;, false, $context);","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"PHP程序员学习路线","slug":"php_learn","date":"2020-04-20T11:12:39.000Z","updated":"2020-04-20T11:15:05.000Z","comments":true,"path":"2020/04/20/php_learn/","link":"","permalink":"http://yoursite.com/2020/04/20/php_learn/","excerpt":"","text":"第一阶段：基础阶段（基础 PHP 程序员）重点：把 LNMP 搞熟练（核心是安装配置基本操作） 目标：能够完成基本的 LNMP 系统安装，简单配置维护；能够做基本的简单系统的 PHP 开发；能够在 PHP 中型系统中支持某个 PHP 功能模块的开发。 时间：完成本阶段的时间因人而异，有的成长快半年一年就过了，成长慢的两三年也有。 1.Linux 基本命令、操作、启动、基本服务配置（包括 rpm 安装文件，各种服务配置等）；会写简单的 shell 脚本和 awk/sed 脚本命令等。 2.Nginx 做到能够安装配置 nginx+php，知道基本的 nginx 核心配置选项，知道 server/fastcgi_pass/access_log 等基础配置，目标是能够让 nginx+php_fpm 顺利工作。 3.MySQL 会自己搭建 MySQL，知道基本的 MySQL 配置选项；知道 innodb 和 myisam 的区别，知道针对 InnoDB 和 MyISAM 两个引擎的不同配置选项；知道基本的两个引擎的差异和选择上面的区别；能够纯手工编译搭建一个 MySQL 数据库并且配置好编码等正常稳定运行；核心主旨是能够搭建一个可运行的 MySQL 数据库。 4.PHP 基本语法数组、字符串、数据库、XML、Socket、GD/ImageMgk 图片处理等等；熟悉各种跟 MySQL 操作链接的 API（mysql/mysqli/PDO)，知道各种编码问题的解决；知道常规熟练使用的 PHP 框架（ThinkPHP、Zendframework、Yii、Yaf 等）；了解基本 MVC 的运行机制和为什么这么做，稍微知道不同的 PHP 框架之间的区别；能够快速学习一个 MVC 框架。能够知道开发工程中的文件目录组织，有基本的良好的代码结构和风格，能够完成小系统的开发和中型系统中某个模块的开发工作。 5.前端 如果条件时间允许，可以适当学习下 HTML/CSS/JS 等相关知识，知道什么 Web 标准，div+css 的 web/wap 页面模式，知道 HTML5 和 HTML4 的区别；了解一些基本的前端只是和 JS 框架（jQuery 之类的）；了解一些基本的 JavaScript 编程知识；（本项不是必须项，如果有时间，稍微了解一下是可以的，不过不建议作为重点，除非个人有强烈兴趣）。 6.系统设计 能够完成小型系统的基本设计，包括简单的数据库设计，能够完成基本的：浏览器 -&gt; Nginx+PHP -&gt; 数据库 架构的设计开发工作；能够支撑每天几十万到数百万流量网站的开发维护工作； 第二阶段：提高阶段 （中级 PHP 程序员）重点：提高针对 LNMP 的技能，能够更全面的对 LNMP 有熟练的应用。 目标：能够随时随地搭建好 LNMP 环境，快速完成常规配置；能够追查解决大部分遇到的开发和线上环境的问题；能够独立承担中型系统的构架和开发工作；能够在大型系统中承担某个中型模块的开发工作。 1. Linux 在第一阶段的基础上面，能够流畅的使用 Shell 脚本来完成很多自动化的工作；awk/sed/perl 也操作的不错，能够完成很多文本处理和数据统计等工作；基本能够安装大部分非特殊的 Linux 程序（包括各种库、包、第三方依赖等等，比如 MongoDB/Redis/Sphinx/Luncene/SVN 之类的）；了解基本的 Linux 服务，知道如何查看 Linux 的性能指标数据，知道基本的 Linux 下面的问题跟踪等。 2. Nginx 在第一阶段的基础上面，了解复杂一些的 Nginx 配置；包括 多核配置、events、proxy_pass，sendfile/tcp_*配置，知道超时等相关配置和性能影响；知道 nginx 除了 Web server，还能够承担代理服务器、反向静态服务器等配置；知道基本的 nginx 配置调优；知道如何配置权限、编译一个 nginx 扩展到 nginx；知道基本的 nginx 运行原理（master/worker 机制，epoll），知道为什么 nginx 性能比 apache 性能好等知识。 3. MySQL/MongoDB 在第一阶段的基础上面，在 MySQL 开发方面，掌握很多小技巧，包括常规 SQL 优化（group by/order by/rand 优化等）；除了能够搭建 MySQL，还能够冷热备份 MySQL 数据，还知道影响 innodb/myisam 性能的配置选项（比如 key_buffer/query_cache/sort_buffer/innodb_buffer_pool_size/innodb_flush_log_at_trx_commit 等），也知道这些选项配置成为多少值合适；另外也了解一些特殊的配置选项，比如 知道如何搭建 MySQL 主从同步的环境，知道各个 binlog_format 的区别；知道 MySQL 的性能追查，包括 slow_log/explain 等，还能够知道基本的索引建立处理等知识；原理方面了解基本的 MySQL 的架构（Server+ 存储引擎），知道基本的 InnoDB/MyISAM 索引存储结构和不同（聚簇索引，B 树）；知道基本的 InnoDB 事务处理机制；了解大部分 MySQL 异常情况的处理方案（或者知道哪儿找到处理方案）。条件允许的情况，建议了解一下 NoSQL 的代表 MongoDB 数据库，顺便对比跟 MySQL 的差别，同事能够在合适的应用场景安全谨慎的使用 MongoDB，知道基本的 PHP 与 MongoDB 的结合开发。 4. Redis/Memcached 在大部分中型系统里面一定会涉及到缓存处理，所以一定要了解基本的缓存；知道 Memcached 和 Redis 的异同和应用场景，能够独立安装 Redis/Memcached，了解 Memcahed 的一些基本特性和限制，比如最大的 value 值，知道 PHP 跟他们的使用结合；Redis 了解基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解 Redis 的事务等等。原理部分，能够大概了解 Memcached 的内存结构（slab 机制），Redis 就了解常用数据类型底层实现存储结构（SDS/链表/SkipList/HashTable）等等，顺便了解一下 Redis 的事务、RDB、AOF 等机制更好。 5. PHP 除了第一阶段的能力，安装配置方面能够随意安装 PHP 和各种第三方扩展的编译安装配置；了解 php-fpm 的大部分配置选项和含义（如 max_requests/max_children/request_terminate_timeout 之类的影响性能的配置），知道 mod_php/fastcgi 的区别；在 PHP 方面已经能够熟练各种基础技术，还包括各种深入些的 PHP，包括对 PHP 面向对象的深入理解/SPL/语法层面的特殊特性比如反射之类的；在框架方面已经阅读过最少一个以上常规 PHP MVC 框架的代码了，知道基本 PHP 框架内部实现机制和设计思想；在 PHP 开发中已经能够熟练使用常规的设计模式来应用开发（抽象工厂/单例/观察者/命令链/策略/适配器 等模式）；建议开发自己的 PHP MVC 框架来充分让开发自由化，让自己深入理解 MVC 模式，也让自己能够在业务项目开发里快速升级；熟悉 PHP 的各种代码优化方法，熟悉大部分 PHP 安全方面问题的解决处理；熟悉基本的 PHP 执行的机制原理（Zend 引擎/扩展基本工作机制）。 6. C/C++ 开始涉猎一定的 C/C++ 语言，能够写基本的 C/C++ 代码，对基本的 C/C++ 语法熟悉（指针、数组操作、字符串、常规标准 API）和数据结构（链表、树、哈希、队列）有一定的熟悉下；对 Linux 下面的 C 语言开发有基本的了解概念，会简单的 makefile 文件编写，能够使用简单的 GCC/GDB 的程序编译简单调试工作；对基本的网络编程有大概了解。（本项是为了向更高层次打下基础）。 7. 前端 在第一阶段的基础上面，熟悉基本的 HTTP 协议（协议代码 200/300/400/500，基本的 HTTP 交互头）；条件允许，可以在深入写出稍微优雅的 HTML+CSS+JavaScript，或者能够大致简单使用某些前端框架（jQuery/YUI/ExtJS/RequireJS/BootStrap 之类）；如果条件允许，可以深入学习 JavaScript 编程，比如闭包机制、DOM 处理；再深入些可以读读 jQuery 源码做深入学习。（本项不做重点学习，除非对前端有兴趣）。 8. 系统设计 能够设计大部分中型系统的网站架构、数据库、基本 PHP 框架选型；性能测试排查处理等；能够完成类似：浏览器 -&gt; CDN(Squid) -&gt; Nginx+PHP -&gt; 缓存 -&gt; 数据库 结构网站的基本设计开发维护；能够支撑每天数百万到千万流量基本网站的开发维护工作； 第三阶段：高级阶段 （高级 PHP 程序员）重点：除了基本的 LNMP 程序，还能够在某个方向或领域有深入学习。（纵深维度发展） 目标：除了能够完成基本的 PHP 业务开发，还能够解决大部分深入复杂的技术问题，并且可以独立设计完成中大型的系统设计和开发工作；自己能够独立 hold 深入某个技术方向，在这块比较专业。（比如在 MySQL、Nginx、PHP、Redis 等等任一方向深入研究） 1. Linux 除了第二阶段的能力，在 Linux 下面除了常规的操作和性能监控跟踪，还能够使用很多高级复杂的命令完成工作（watch/tcpdump/starce/ldd/ar 等)；在 shell 脚本方面，已经能够编写比较复杂的 shell 脚本（超过 500 行）来协助完成很多包括备份、自动化处理、监控等工作的 shell；对 awk/sed/perl 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据；对 Linux 内部机制有一些了解，对内核模块加载，启动错误处理等等有个基本的处理；同时对一些其他相关的东西也了解，比如 NFS、磁盘管理等等； 2. Nginx 在第二阶段的基础上面，已经能够把 Nginx 操作的很熟练，能够对 Nginx 进行更深入的运维工作，比如监控、性能优化，复杂问题处理等等；看个人兴趣，更多方面可以考虑侧重在关于 Nginx 工作原理部分的深入学习，主要表现在阅读源码开始，比如具体的 master/worker 工作机制，Nginx 内部的事件处理，内存管理等等；同时可以学习 Nginx 扩展的开发，可以定制一些自己私有的扩展；同时可以对 Nginx+Lua 有一定程度的了解，看看是否可以结合应用出更好模式；这个阶段的要求是对 Nginx 原理的深入理解，可以考虑成为 Nginx 方向的深入专业者。 3. MySQL/MongoDB 在第二阶段的基础上面，在 MySQL 应用方面，除了之前的基本 SQL 优化，还能够在完成一些复杂操作，比如大批量数据的导入导出，线上大批量数据的更改表结构或者增删索引字段等等高危操作；除了安装配置，已经能够处理更多复杂的 MySQL 的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL 高可用架构等都有涉及了解；对 MySQL 应用层面，对 MySQL 的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对 MySQL 性能方面，有包括磁盘优化（SAS 迁移到 SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其他核心性能优化选项（innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout 等）、连接池软件选择应用，对 show *（show status/show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；MySQL 备份技术的深入熟悉，包括灾备还原、对 Binlog 的深入理解，冷热备份，多 IDC 备份等；在 MySQL 原理方面，有更多了解，比如对 MySQL 的工作机制开始阅读部分源码，比如对主从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM/Innodb/TokuDB）等等的源码学习理解，如果条件允许，可以参考 CSV 引擎开发自己简单的存储引擎来保存一些数据，增强对 MySQL 的理解；在这个过程，如果自己有兴趣，也可以考虑往 DBA 方向发展。MongoDB 层面，可以考虑比如说在写少读多的情况开始在线上应用 MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解 RMDBS 和 NoSQL 的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下 MongoDB 的工作机制。 4. Redis/Memcached 在第二阶段的基础上面，能够更深入的应用和学习。因为 Memcached 不是特别复杂，建议可以把源码进行阅读，特别是内存管理部分，方便深入理解；Redis 部分，可以多做一些复杂的数据结构的应用（zset 来做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作）；多涉及 aof 等同步机制的学习应用，设计一个高可用的 Redis 应用架构和集群；建议可以深入的学习一下 Redis 的源码，把在第二阶段积累的知识都可以应用上，特别可以阅读一下包括核心事件管理、内存管理、内部核心数据结构等充分学习了解一下。如果兴趣允许，可以成为一个 Redis 方面非常专业的使用者。 5. PHP 作为基础核心技能，我们在第二阶段的基础上面，需要有更深入的学习和应用。从基本代码应用上面来说，能够解决在 PHP 开发中遇到 95% 的问题，了解大部分 PHP 的技巧；对大部分的 PHP 框架能够迅速在一天内上手使用，并且了解各个主流 PHP 框架的优缺点，能够迅速方便项目开发中做技术选型；在配置方面，除了常规第二阶段会的知识，会了解一些比较偏门的配置选项（PHP auto_prepend_file/auto_append_file），包括扩展中的一些复杂高级配置和原理（比如 Memcached 扩展配置中的 memcache.hash_strategy、apc 扩展配置中的 apc.mmap_file_mask/apc.slam_defense/apc.file_update_protection 之类的）；对 PHP 的工作机制比较了解，包括 php-fpm 工作机制（比如 php-fpm 在不同配置机器下面开启进程数量计算以及原理），对 zend 引擎有基本熟悉（vm/gc/stream 处理），阅读过基本的 PHP 内核源码（或者阅读过相关文章），对 PHP 内部机制的大部分核心数据结构（基础类型/Array/Object）实现有了解，对于核心基础结构（zval/hashtable/gc）有深入学习了解；能够进行基本的 PHP 扩展开发，了解一些扩展开发的中高级知识（minit/rinit 等），熟悉 PHP 跟 apache/nginx 不同的通信交互方式细节（mod_php/fastcgi）；除了开发 PHP 扩展，可以考虑学习开发 Zend 扩展，从更底层去了解 PHP。 6. C/C++ 在第二阶段基础上面，能够在 C/C++ 语言方面有更深入的学习了解，能够完成中小型 C/C++ 系统的开发工作；除了基本第二阶段的基础 C/C++ 语法和数据结构，也能够学习一些特殊数据结构（b-tree/rb-tree/skiplist/lsm-tree/trie-tree 等）方便在特殊工作中需求；在系统编程方面，熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存/信号量/管道等）；多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；同时对网络编程比较熟悉，了解多进程模型/多线程模型/异步网络 IO 模型的差别和选型，熟悉不同异步网络 IO 模型的原理和差异（select/poll/epoll/iocp 等），并且熟悉常见的异步框架（ACE/ICE/libev/libevent/libuv/Boost.ASIO 等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如 muduo）；同时能够设计好的高并发程序架构（leader-follow/master-worker 等）；了解大部分 C/C++ 后端 Server 开发中的问题（内存管理、日志打印、高并发、前后端通信协议、服务监控），知道各个后端服务 RPC 通信问题（struct/http/thirft/protobuf 等）；能够更熟络的使用 GCC 和 GDB 来开发编译调试程序，在线上程序 core 掉后能够迅速追查跟踪解决问题；通用模块开发方面，可以积累或者开发一些通用的工具或库（比如异步网络框架、日志库、内存池、线程池等），不过开发后是否应用要谨慎，省的埋坑去追 bug。 7. 前端 深入了解 HTTP 协议（包括各个细致协议特殊协议代码和背后原因，比如 302 静态文件缓存了，502 是 nginx 后面 PHP 挂了之类的）；除了之前的前端方面的各种框架应用整合能力，前端方面的学习如果有兴趣可以更深入，表现形式是，可以自己开发一些类似 jQuery 的前端框架，或者开发一个富文本编辑器之类的比较琐碎考验 JavaScript 功力。 8. 其他领域语言学习 在基础的 PHP/C/C++ 语言方面有基本积累，建议在当前阶段可以尝试学习不同的编程语言，看个人兴趣爱好，脚本类语言可以学学 Python/Ruby 之类的，函数式编程语言可以试试 Lisp/Haskell/Scala/Erlang 之类的，静态语言可以试试 Java/Golang，数据统计分析可以了解了解 R 语言，如果想换个视角做后端业务，可以试试 Node.js 还有前面提到的跟 Nginx 结合的 Nginx_Lua 等。学习不同的语言主要是提升自己的视野和解决问题手段的差异，比如会了解除了进程/线程，还有轻量级协程；比如在跨机器通信场景下面，Erlang 的解决方案简单的惊人；比如在不想选择 C/C++ 的情况下，还有类似高效的 Erlang/Golang 可用等等；主要是提升视野。 9. 其他专业方向学习 在本阶段里面，会除了基本的 LNMP 技能之外，会考虑一些其他领域知识的学习，这些都是可以的，看个人兴趣和长期的目标方向。目前情况能够选择的领域比较多，比如、云计算（分布式存储、分布式计算、虚拟机等），机器学习（数据挖掘、模式识别等，应用到统计、个性化推荐），自然语言处理（中文分词等），搜索引擎技术、图形图像、语音识别等等。除了这些高大上的，也有很多偏工程方面可以学习的地方，比如高性能系统、移动开发（Android/IOS）、计算机安全、嵌入式系统、硬件等方向。 10. 系统设计 系统设计在第二阶段的基础之上，能够应用掌握的经验技能，设计出比较复杂的中大型系统，能够解决大部分线上的各种复杂系统的问题，完成类似 浏览器 -&gt; CDN -&gt; 负载均衡 -&gt; 接入层 -&gt; Nginx+PHP -&gt; 业务缓存 -&gt; 数据库 -&gt; 各路复杂后端 RPC 交互（存储后端、逻辑后端、反作弊后端、外部服务） -&gt; 更多后端 酱紫的复杂业务；能够支撑每天数千万到数亿流量网站的正常开发维护工作。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"Yaf教程1：安装","slug":"yaf02","date":"2020-04-20T11:11:22.000Z","updated":"2020-04-20T11:12:03.000Z","comments":true,"path":"2020/04/20/yaf02/","link":"","permalink":"http://yoursite.com/2020/04/20/yaf02/","excerpt":"","text":"Yaf 要求 PHP 必须为 5.2 及以上版本，如果是 PHP7，请使用 Yaf 3。本教程使用 64 位的 PHP 5.6，所以使用最后稳定版本 *Yaf 2.3.5 *为例。 1 Linux 服务器确保服务器上安装了 PHP，再到 PHP PECL 下载 Yaf 源码： 123456789wget https:&#x2F;&#x2F;github.com&#x2F;laruence&#x2F;yaf&#x2F;archive&#x2F;yaf-3.0.8.tar.gzcd yaf-3.0.8phpize.&#x2F;configuremake &amp;&amp; make installsudo vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;7.2&#x2F;php.ini#加入配置extension&#x3D;php_yaf.dll#使用phpinfo()查看扩展或者使用 php -m 查看 2 下载yaf框架1234git clone https:&#x2F;&#x2F;github.com&#x2F;laruence&#x2F;yaf.gitcd yaf&#x2F;tools&#x2F;cgphp yaf_cg yaf #生成框架cd output #这个目录下的项目就是yaf框架了","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"Yaf教程0：简介","slug":"yaf01","date":"2020-04-20T11:09:45.000Z","updated":"2020-04-20T11:11:00.000Z","comments":true,"path":"2020/04/20/yaf01/","link":"","permalink":"http://yoursite.com/2020/04/20/yaf01/","excerpt":"","text":"Yaf，全称 Yet Another Framework，是一个高性能的 PHP 开发框架。Yaf 用 C 语言编写，以 PHP 扩展形式作为 PHP 开发框架。相比于一般的 PHP 框架，如 Zend Framework、Yii、Ci，它更快更轻便。它提供了启动配置、路由、分发、视图、插件等功能， 是一个全功能的 PHP 框架。 Yaf 特点： 用 C 语言开发的 PHP 框架， 相比原生的 PHP, 几乎不会带来额外的性能开销。 所有的框架类， 不需要编译, 在 PHP 启动的时候加载， 并常驻内存. 更短的内存周转周期， 提高内存利用率, 降低内存占用率。 灵巧的自动加载. 支持全局和局部两种加载规则， 方便类库共享。 高性能的视图引擎. 高度灵活可扩展的框架, 支持自定义视图引擎， 支持插件， 支持自定义路由等等。 内建多种路由, 可以兼容目前常见的各种路由协议。 强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失。 在框架本身，对危险的操作习惯做了禁止. 更快的执行速度， 更少的内存占用.","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"mysql的备份和导出","slug":"mysqldump","date":"2020-04-20T11:08:08.000Z","updated":"2020-04-20T11:10:18.000Z","comments":true,"path":"2020/04/20/mysqldump/","link":"","permalink":"http://yoursite.com/2020/04/20/mysqldump/","excerpt":"","text":"1.导出整个数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u root -p dataname &gt;dataname.sql备份 MySQL 数据库的命令mysqldump -hhostname -uusername -ppassword databasename &gt; backupfile.sql备份 MySQL 数据库为带删除表的格式备份 MySQL 数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。mysqldump -–add-drop-table -uusername -ppassword databasename &gt; backupfile.sql直接将 MySQL 数据库压缩备份mysqldump -hhostname -uusername -ppassword databasename | gzip &gt; backupfile.sql.gz备份 MySQL 数据库某个(些)表mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 &gt; backupfile.sql同时备份多个 MySQL 数据库mysqldump -hhostname -uusername -ppassword –databases databasename1 databasename2 databasename3 &gt; multibackupfile.sql仅仅备份数据库结构mysqldump –no-data –databases databasename1 databasename2 databasename3 &gt; structurebackupfile.sql备份服务器上所有数据库mysqldump –all-databases &gt; allbackupfile.sql还原 MySQL 数据库的命令MySQL -hhostname -uusername -ppassword databasename &lt; backupfile.sql还原压缩的 MySQL 数据库gunzip &lt; backupfile.sql.gz | MySQL -uusername -ppassword databasename将数据库转移到新服务器mysqldump -uusername -ppassword databasename | MySQL –host&#x3D;*.*.*.* -C databasename2.导出一个表mysqldump -u 用户名 -p 数据库名 表名 &gt; 导出的文件名mysqldump -u root -p dataname users&gt; dataname_users.sql3.导出一个数据库结构mysqldump -u wcnc -p -d –add-drop-table smgp_apps_wcnc &gt;d:\\wcnc_db.sql-d 没有数据 –add-drop-table 在每个 create 语句之前增加一个 drop table4.导入数据库常用 source 命令进入 MySQL 数据库控制台，如 MySQL -u root -pmysql&gt;use 数据库然后使用 source 命令，后面参数为脚本文件（如这里用到的。SQL）mysql&gt;source d:\\wcnc_db.sqlmysqldump 支持下列选项：–add-locks在每个表导出之前增加 LOCK TABLES 并且之后 UNLOCK TABLE。(为了使得更快地插入到 MySQL)。–add-drop-table在每个 create 语句之前增加一个 drop table。–allow-keywords允许创建是关键词的列名字。这由表名前缀于每个列名做到。-c, –complete-insert使用完整的 insert 语句(用列名字)。-C, –compress如果客户和服务器均支持压缩，压缩两者间所有的信息。–delayed用 Insert DELAYED 命令插入行。-e, –extended-insert使用全新多行 Insert 语法。（给出更紧缩并且更快的插入语句）-#, –debug[&#x3D;option_string]跟踪程序的使用(为了调试)。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[]},{"title":"linux scp 服务器远程拷贝","slug":"scp","date":"2020-04-20T11:05:49.000Z","updated":"2020-04-20T11:10:09.000Z","comments":true,"path":"2020/04/20/scp/","link":"","permalink":"http://yoursite.com/2020/04/20/scp/","excerpt":"","text":"一、将本机文件复制到远程服务器上 #scp /home/administrator/news.txt root@192.168.1.1:/etc/squid /home/administrator/ 本地文件的绝对路径 news.txt 要复制到服务器上的本地文件 root 通过root用户登录到远程服务器（也可以使用其他拥有同等权限的用户） 192.168.6.129 远程服务器的ip地址（也可以使用域名或机器名） /etc/squid 将本地文件复制到位于远程服务器上的路径 二、将远程服务器上的文件复制到本机 #scp remote@www.abc.com:/usr/local/sin.sh /home/administrator remote 通过remote用户登录到远程服务器（也可以使用其他拥有同等权限的用户） www.abc.com 远程服务器的域名（当然也可以使用该服务器ip地址） /usr/local/sin.sh 欲复制到本机的位于远程服务器上的文件 /home/administrator 将远程文件复制到本地的绝对路径","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"php服务器把session放到redis中","slug":"session_redis","date":"2020-04-20T11:05:03.000Z","updated":"2020-04-20T11:07:36.000Z","comments":true,"path":"2020/04/20/session_redis/","link":"","permalink":"http://yoursite.com/2020/04/20/session_redis/","excerpt":"","text":"一、将本机文件复制到远程服务器上 #scp /home/administrator/news.txt root@192.168.1.1:/etc/squid /home/administrator/ 本地文件的绝对路径 news.txt 要复制到服务器上的本地文件 root 通过root用户登录到远程服务器（也可以使用其他拥有同等权限的用户） 改为 123session.save_handler &#x3D; redissession.save_path &#x3D; &quot;tcp:&#x2F;&#x2F;127.0.0.1:6379&quot;&quot;tcp:&#x2F;&#x2F;127.0.0.1:6379&quot; 重启 apache 以生效 12service httpd restart httpd restart 如果是以 FastCGI 运行的（比如 nginx 就是默认 FastCGI 运行的）编辑 /etc/php-fpm.d/www.conf（可能视系统环境而路径不一样）把这两行 123php_value[session.save_handler] &#x3D; filesphp_value[session.save_path] &#x3D; &#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;var&#x2F;lib&#x2F;php&#x2F;session 改为（其实就是增加分号以注释掉） 123;php_value[session.save_handler] &#x3D; files;php_value[session.save_path] &#x3D; &#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;var&#x2F;lib&#x2F;php&#x2F;session 然后增加两行： 123php_value[session.save_handler] &#x3D; redisphp_value[session.save_path] &#x3D; tcp:&#x2F;&#x2F;127.0.0.1:6379&#x2F;&#x2F;127.0.0.1:6379 重启 PHP 服务以生效 1service php-fpm restart php-fpm restart","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"PHP写文件函数file_put_contents 加锁","slug":"file_put_contents","date":"2020-04-20T11:03:38.000Z","updated":"2020-04-20T11:07:18.000Z","comments":true,"path":"2020/04/20/file_put_contents/","link":"","permalink":"http://yoursite.com/2020/04/20/file_put_contents/","excerpt":"","text":"file_put_contents 写 PHP 的 Cache 文件，如果不加 LOCK_EX 就可能会存在同步问题，当一个进程写 file 时，只写到一半有另外的进程去 require 此文件， 这时就会因为文件不完整，导致 PHP 语法错误。所以涉及到同时读写同一个文件或数据时一定要加锁，否则在高并发的情况下会产生严重错误。 最近有个项目需要用 file_put_contents 函数写 txt 文件，由于需要频繁操作，所以经常出现前半截内容缺失的情况，非常苦恼。 后来查询资料发现，file_put_contents 函数有个参数 LOCK_EX 非常有用，加上它之后，再也没有出现过内容缺失的情况了。 这个参数 LOCK_EX 的意思很直白，就是写文件时，先锁上这个文件，这样只允许某个客户端访问的时候写，其他客户端访问不能写了。 我的用法如下： 1| &#96;file_put_contents($file, $content, FILE_APPEND|LOCK_EX)&#96; 解释：$file=&gt; 这个是写入文件的路径 + 文件名$content=&gt; 这个是写入文件的内容FILE_APPEND=&gt; 直接在该文件已有的内容后面追加内容LOCK_EX=&gt; 写文件的时候先锁定，防止多人同时写入造成内容丢失|","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"Etag缓存在PHP","slug":"etag","date":"2020-04-20T10:30:29.000Z","updated":"2020-04-20T10:43:02.000Z","comments":true,"path":"2020/04/20/etag/","link":"","permalink":"http://yoursite.com/2020/04/20/etag/","excerpt":"","text":"HTTP 提供了许多页面缓存的方案，其中属 Etag 和 Last-Modified 应用最广。本文会先介绍 Etag 的应用场景，然后说说他在 PHP 和 node 中的使用。 一、Etag 的使用客户端和浏览器之间的交互： +---------+ 1 +---------+ | |---------------->| | | | 2（200，OK） | | | || | | 户 | 4（304） | 务 | | || | | | 6（200，OK） | | | |","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"php异常、错误处理机制","slug":"catch","date":"2020-04-20T10:29:27.000Z","updated":"2020-04-20T10:33:10.000Z","comments":true,"path":"2020/04/20/catch/","link":"","permalink":"http://yoursite.com/2020/04/20/catch/","excerpt":"","text":"1.php 中 try catch 可以帮助我们捕获程序代码的异常了，这样我们可以很好的处理一些不必要的错误了，感兴趣的朋友可以一起来看看。 PHP 中 try{}catch{}语句概述 PHP5 添加了类似于其它语言的异常处理模块。在 PHP 代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。（注：一定要先抛才能获取） 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch。 使用多个 catch 可以捕获不同的类所产生的异常。 当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 当然，PHP 允许在 catch 代码块内再次抛出（throw）异常。 当一个异常被抛出时，其后（译者注：指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。 如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception … （未捕获异常）的提示信息。 先来看一下 PHP 内置异常类的基本属性和方法。（不包括具体实现） 12345678910111213try&#123;&#125;catch()&#123;throw new Exception();&#125;catch()&#123;&#x2F;&#x2F;这里可以捕获到前面一个块抛出的Exception&#96;&#125; 如果抛出了一个异常，try 语句中的脚本将会停止执行，然后马上转向执行 catch 语句中的脚本。 例子如下： 包含文件错误抛出异常 12345678910111213141516171819202122232425262728&lt;?php&#x2F;&#x2F; 错误的演示try &#123;require (&#39;test_try_catch.php&#39;);&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&#39;test_try_catch.php&#39;);&#125; else &#123;throw new Exception(&#39;file is not exists&#39;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&quot;test_try_catch.php&quot;);&#125; else &#123;throw new Exception(&quot;file is not exists&quot;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125; 2、通过 set_exception_handler 函数设置异常处理函数，在这种情况下，即使没有 try{}catch{}，throw 抛出的异常也能由 set_exception_handler 设置的函数自动捕捉 123456set_exception_handler(&#39;exceptionHandler&#39;); throw new Exception(&quot;kkkkkkkkkkkkkkkk&quot;); function exceptionHandler(Exception $exception)&#123; echo $exception-&gt;getMessage(); &#125; 在 PHP 开发的时候常常会用到 error_reporting(report_level)来调试自己的程序，下面列出了 report_level 可能值： | 值 | 常量 | 描述 || 1 | E_ERROR | 这是一个严重错误，不可恢复，如位置异常，内存不足等 || 2 | E_WARNING | 警告，最一般的错误，如函数的参数错误等 || 4 | E_PARSE | 解析错误，在解析 PHP 文件时产生，并强制 PHP 在执行前退出 || 8 | E_NOTICE | 通告表示可能在操作一些未知的变量等。在开发时可开启通告，以保证程序是”安全通告”的，瑞在正式系统中，应关闭通告 || 16 | E_CORE_ERROR | 这个内部错误是由于 PHP 加载扩展失败而导致的，并且会导致 PHP 停止运行并退出 || 32 | E_CORE_WARNING | PHP 启动时初始化过程中的警告(非致命性错) || 64 | E_COMPILE_ERROR | 编译错误是在编译时发生，这个错误将导致 PHP 运行退出 || 128 | E_COMPILE_WARNING | 编译警告用于告诉用户一些不推荐的语法信息 || 256 | E_USER_ERROR | 用户定义的错误将导致辞 PHP 退出，它对是来自 PHP 自身，而是来自脚本文件中。 || 512 | E_USER_WARNING | 脚本使用它来通知一个执行失败，同时 PHP 也会用 E_WARNING 通知 || 1024 | E_USER_NOTICE | 用户定义的通告用于在脚本中表示可能存在的错误 || 2048 | E_STRICT | 编码标准化警告(建议如何修改以向前兼容) || 4096 | E_RECOVERABLE_ERROR | 接近致命的运行时错误，若未被捕获则视同 E_ERROR || 8191 | E_ALL | 除 E_STRICT 外的所有错误(PHP6 中为 8191,即包含所有) | 例子： 任意数目的以上选项都可以用“或”来连接（用 OR 或 |），这样可以报告所有需要的各级别错误。例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别： 12345678910111213141516171819&lt;?php&#x2F;&#x2F;禁用错误报告error_reporting(0); &#x2F;&#x2F;报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE); &#x2F;&#x2F;报告所有错误error_reporting(E_ALL); error_reporting(7);&#x2F;*设置php错误检测级别E_ERROR - 致命性运行时错 (1)E_WARNING - 运行时警告（非致命性错）(2)E_PARSE - 编译时解析错误 (4)1+2+4 &#x3D; 7*&#x2F;?&gt; 如果设置了 error_reporting(E_NOTICE)，那么程序只会输出 E_NOTICE 等级的信息，一般我们使用的时候只需要设置 error_reporting(E_ALL&amp;!E_WARNING)就行了 上面我们看到有一种错误叫用户自定义的错误消息，这是什么呢？我们先看一个例子 123456set_error_handler(&#39;errorHandler&#39;); trigger_error(&quot;aaaaaaassssssssssss&quot;,E_USER_ERROR); function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_USER_ERROR)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; 输出结果： 1innnnnnnni:aaaaaaassssssssssss trigger_error()就是用来抛出用户自定义错误消息的函数，通过这个我们能抛出自定义的一些消息被当作错误来处理，比如严重的逻辑问题 上面的程序我们看到，当程序出错时，除了让 PHP 默认输出出错信息外，我们还能设置自己的错误处理函数，设置的方法就是set_error_handler(),下面来看个例子 12345678set_error_handler(&#39;errorHandler&#39;); echo &quot;dddddddddddd&lt;&#x2F;br&gt;&quot;; echo $cc;&#x2F;&#x2F;$cc没有定义，echo会出错 function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_NOTICE)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; &#125; 输出结果： 12ddddddddddddinnnnnnnni:Undefined variable: cc","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"iconv的使用方法(转换编码,截取字符串,统计长度)","slug":"iconv","date":"2020-04-20T10:27:54.000Z","updated":"2020-04-20T10:30:00.000Z","comments":true,"path":"2020/04/20/iconv/","link":"","permalink":"http://yoursite.com/2020/04/20/iconv/","excerpt":"","text":"1.php 中 try catch 可以帮助我们捕获程序代码的异常了，这样我们可以很好的处理一些不必要的错误了，感兴趣的朋友可以一起来看看。 PHP 中 try{}catch{}语句概述 PHP5 添加了类似于其它语言的异常处理模块。在 PHP 代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。（注：一定要先抛才能获取） 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch。 使用多个 catch 可以捕获不同的类所产生的异常。 当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 当然，PHP 允许在 catch 代码块内再次抛出（throw）异常。 当一个异常被抛出时，其后（译者注：指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。 如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception … （未捕获异常）的提示信息。 先来看一下 PHP 内置异常类的基本属性和方法。（不包括具体实现） 12345678910111213try&#123;&#125;catch()&#123;throw new Exception();&#125;catch()&#123;&#x2F;&#x2F;这里可以捕获到前面一个块抛出的Exception&#96;&#125; 如果抛出了一个异常，try 语句中的脚本将会停止执行，然后马上转向执行 catch 语句中的脚本。 例子如下： 包含文件错误抛出异常 12345678910111213141516171819202122232425262728&lt;?php&#x2F;&#x2F; 错误的演示try &#123;require (&#39;test_try_catch.php&#39;);&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&#39;test_try_catch.php&#39;);&#125; else &#123;throw new Exception(&#39;file is not exists&#39;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&quot;test_try_catch.php&quot;);&#125; else &#123;throw new Exception(&quot;file is not exists&quot;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125; 2、通过 set_exception_handler 函数设置异常处理函数，在这种情况下，即使没有 try{}catch{}，throw 抛出的异常也能由 set_exception_handler 设置的函数自动捕捉 123456set_exception_handler(&#39;exceptionHandler&#39;); throw new Exception(&quot;kkkkkkkkkkkkkkkk&quot;); function exceptionHandler(Exception $exception)&#123; echo $exception-&gt;getMessage(); &#125; 在 PHP 开发的时候常常会用到 error_reporting(report_level)来调试自己的程序，下面列出了 report_level 可能值： | 值 | 常量 | 描述 || 1 | E_ERROR | 这是一个严重错误，不可恢复，如位置异常，内存不足等 || 2 | E_WARNING | 警告，最一般的错误，如函数的参数错误等 || 4 | E_PARSE | 解析错误，在解析 PHP 文件时产生，并强制 PHP 在执行前退出 || 8 | E_NOTICE | 通告表示可能在操作一些未知的变量等。在开发时可开启通告，以保证程序是”安全通告”的，瑞在正式系统中，应关闭通告 || 16 | E_CORE_ERROR | 这个内部错误是由于 PHP 加载扩展失败而导致的，并且会导致 PHP 停止运行并退出 || 32 | E_CORE_WARNING | PHP 启动时初始化过程中的警告(非致命性错) || 64 | E_COMPILE_ERROR | 编译错误是在编译时发生，这个错误将导致 PHP 运行退出 || 128 | E_COMPILE_WARNING | 编译警告用于告诉用户一些不推荐的语法信息 || 256 | E_USER_ERROR | 用户定义的错误将导致辞 PHP 退出，它对是来自 PHP 自身，而是来自脚本文件中。 || 512 | E_USER_WARNING | 脚本使用它来通知一个执行失败，同时 PHP 也会用 E_WARNING 通知 || 1024 | E_USER_NOTICE | 用户定义的通告用于在脚本中表示可能存在的错误 || 2048 | E_STRICT | 编码标准化警告(建议如何修改以向前兼容) || 4096 | E_RECOVERABLE_ERROR | 接近致命的运行时错误，若未被捕获则视同 E_ERROR || 8191 | E_ALL | 除 E_STRICT 外的所有错误(PHP6 中为 8191,即包含所有) | 例子： 任意数目的以上选项都可以用“或”来连接（用 OR 或 |），这样可以报告所有需要的各级别错误。例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别： 12345678910111213141516171819&lt;?php&#x2F;&#x2F;禁用错误报告error_reporting(0); &#x2F;&#x2F;报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE); &#x2F;&#x2F;报告所有错误error_reporting(E_ALL); error_reporting(7);&#x2F;*设置php错误检测级别E_ERROR - 致命性运行时错 (1)E_WARNING - 运行时警告（非致命性错）(2)E_PARSE - 编译时解析错误 (4)1+2+4 &#x3D; 7*&#x2F;?&gt; 如果设置了 error_reporting(E_NOTICE)，那么程序只会输出 E_NOTICE 等级的信息，一般我们使用的时候只需要设置 error_reporting(E_ALL&amp;!E_WARNING)就行了 上面我们看到有一种错误叫用户自定义的错误消息，这是什么呢？我们先看一个例子 123456set_error_handler(&#39;errorHandler&#39;); trigger_error(&quot;aaaaaaassssssssssss&quot;,E_USER_ERROR); function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_USER_ERROR)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; 输出结果： 1innnnnnnni:aaaaaaassssssssssss trigger_error()就是用来抛出用户自定义错误消息的函数，通过这个我们能抛出自定义的一些消息被当作错误来处理，比如严重的逻辑问题 上面的程序我们看到，当程序出错时，除了让 PHP 默认输出出错信息外，我们还能设置自己的错误处理函数，设置的方法就是set_error_handler(),下面来看个例子 12345678set_error_handler(&#39;errorHandler&#39;); echo &quot;dddddddddddd&lt;&#x2F;br&gt;&quot;; echo $cc;&#x2F;&#x2F;$cc没有定义，echo会出错 function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_NOTICE)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; &#125; 输出结果： 12ddddddddddddinnnnnnnni:Undefined variable: cc","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"百度语音接口简单使用","slug":"baidu","date":"2020-04-20T10:23:01.000Z","updated":"2020-04-20T10:23:55.000Z","comments":true,"path":"2020/04/20/baidu/","link":"","permalink":"http://yoursite.com/2020/04/20/baidu/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpheader(&quot;Content-type:text&#x2F;html;charset&#x3D;utf-8&quot;);define(&#39;AUDIO_FILE&#39;, &quot;.&#x2F;test2.pcm&quot;);&#x2F;&#x2F;put your params here$cuid &#x3D; &quot;&quot;;$apiKey &#x3D; &quot;&quot;;$secretKey &#x3D; &quot;&quot;;$auth_url &#x3D; &quot;https:&#x2F;&#x2F;openapi.baidu.com&#x2F;oauth&#x2F;2.0&#x2F;token?grant_type&#x3D;client_credentials&amp;client_id&#x3D;&quot;.$apiKey.&quot;&amp;client_secret&#x3D;&quot;.$secretKey;$ch &#x3D; curl_init();curl_setopt($ch, CURLOPT_URL, $auth_url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);$response &#x3D; curl_exec($ch);if(curl_errno($ch))&#123; print curl_error($ch);&#125;curl_close($ch);$response &#x3D; json_decode($response, true);$token &#x3D; $response[&#39;access_token&#39;];$url &#x3D; &quot;http:&#x2F;&#x2F;vop.baidu.com&#x2F;server_api?cuid&#x3D;&quot;.$cuid.&quot;&amp;token&#x3D;&quot;.$token;&#x2F;&#x2F;$url &#x3D; $url.&quot;&amp;lan&#x3D;zh&quot;;$audio &#x3D; file_get_contents(AUDIO_FILE);$content_len &#x3D; &quot;Content-Length: &quot;.strlen($audio);$header &#x3D; array ($content_len,&#39;Content-Type: audio&#x2F;pcm; rate&#x3D;8000&#39;,);$ch &#x3D; curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_HTTPHEADER, $header);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);curl_setopt($ch, CURLOPT_TIMEOUT, 30);curl_setopt($ch, CURLOPT_POSTFIELDS, $audio);$response &#x3D; curl_exec($ch);if(curl_errno($ch))&#123; print curl_error($ch);&#125;curl_close($ch);echo $response;$response &#x3D; json_decode($response, true);&#x2F;&#x2F;var_dump($response);?&gt; 测试的时候官方会提示一个 3300 的错误 是证书验证不通过 特在此记录一下 在第一个 curl 里面加上下面语句就 ok 了 有兴趣的可以试一下吧 123&#96;curl_setopt(&#96;&#96;$ch&#96;&#96;, CURLOPT_SSL_VERIFYPEER, FALSE);&#96;&#96;curl_setopt(&#96;&#96;$ch&#96;&#96;, CURLOPT_SSL_VERIFYHOST, FALSE);&#96;","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"session和cookie的区别","slug":"session","date":"2020-04-20T10:21:32.000Z","updated":"2020-04-20T10:26:26.000Z","comments":true,"path":"2020/04/20/session/","link":"","permalink":"http://yoursite.com/2020/04/20/session/","excerpt":"","text":"——————————————session 的使用————————————– session 中同一浏览器同一站点只能有一个 session_id,下面我们一起来看看关于 session 使用方法。如何使用 session，凡是与 session 有关的，之前必须调用函数 session_start();为 session 赋值很简单，如： 1234567&lt;?phpSession_start();$Name &#x3D; &quot;这是一个Session例子&quot;;Session_Register(&quot;Name&quot;);&#x2F;&#x2F;注意,不要写成：Session_Register(&quot;$Name&quot;);echo $_SESSION[&quot;Name&quot;];&#x2F;&#x2F;输出$_SESSION[&quot;Name&quot;]为&quot;这是一个Session例子&quot;?&gt; 取消 session 可以这样： 12345&lt;?phpsession_start();session_unset();session_destroy();?&gt; 读取 session PHP 内置的 $_SESSION 变量可以很方便的访问设置的 session 变量。 1234&lt;?phpsession_start();echo &quot;登记的用户名为：&quot;.$_SESSION[&quot;username&quot;]; &#x2F;&#x2F;输出 登记的用户名为：nostop?&gt; 检查变量是否被登记为会话变量 session_is_registered语法：boobean session_is_registered(string name);这个函数可检查当前的 session 之中是否已有指定的变量注册，参数 name 就是要检查的变量名。成功则返回逻辑值 true。 123456&lt;?php session_start(); if(!session_is_registered(&quot;gender&quot;))&#123; &#x2F;&#x2F;判断当前会话变量是否注册 session_register(&quot;gender&quot;); &#x2F;&#x2F;注册变量 &#125; $gender&#x3D;&quot;女&quot;; ?&gt; 1234存取当前会话名称 session_name语法：boolean session_name(string [name]);这个函数可取得或重新设置当前 session 的名称。若无参数 name 则表示获取当前 session 名称，加上参数则表示将 session 名称设为参数 name。 12345存取当前会话标识号 session_id语法：boolean session_id(string [id]);这个函数可取得或重新设置当前存放 session 的标识号。若无参数 id 则表示只获取当前 session 的标识号，加上参数则表示将 session 的标识号设成新指定的 id。设置 Session 的生存期 123session_set_cookie_params:设置 Session 的生存期的，该函数必须在 session_start() 函数调用之前调用。如果客户端使用 IE 6.0 ， session_set_cookie_params(); 函数设置 Cookie 会有些问题，所以我们还是手动调用 setcookie 函数来创建 cookie。 123设置 Session 文件的保存路径session_save_path() ：必须在 session_start() 函数调用之前调用 12 12注意：1:在调用 Session_Start()之前不能有任何输出。例如下面是错误的。 12345678910111213141516171819202122232425提示 1:凡是出现&quot;........headers already sent..........&quot;,就是 Session_Start()之前向浏览器输出信息。去掉输出就正常，（COOKIE 也会出现这种错误，错误原因一样）提示 2:如果你的 Session_Start()放在循环语句里，并且很难确定之前哪里向浏览器输出信息，可以用下面这种方法：1 行 &lt;?PHP Ob_Start(); ?&gt;........这里是你的程序......2:这是什么错误Warning: session_start(): open(&#x2F;tmpsess_7d190aa36b4c5ec13a5c1649cc2da23f, O_RDWR) failed:....因为你没有指定 session 文件的存放路径。解决方法：(1)在 c 盘建立文件夹 tmp(2)打开 php.ini,找到 session.save_path,修改为 session.save_path&#x3D; &quot;c:&#x2F;tmp&quot;------------------------------------------**PHP cookie 的使用以及坑**--------------------------------------1.设置 cookie setcookie(‘uid’, 3, time()+3600, ‘/‘, $_SERVER[‘HTTP_HOST’]); // cookie 名字 cookie 值 过期时间 path 保存目录 作用域 12.设置 cookie 的过期 setcookie(‘uid’, 0, 0, ‘/‘, $_SERVER[‘HTTP_HOST’]); 123453.cookie 的坑 url 区分大小写如果不加第四个参数 可能会在 url 大小写下出现获取不到 cookie 所以一定要加上域名的作用域4.语法 setcookie(name,value,expire,path,domain,secure) 参数 描述 name 必需。规定 cookie 的名称。 value 必需。规定 cookie 的值。 expire 可选。规定 cookie 的有效期。 path 可选。规定 cookie 的服务器路径。 domain 可选。规定 cookie 的域名。 secure 可选。规定是否通过安全的 HTTPS 连接来传输 cookie。 ```","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"hexo 使用教程","slug":"hexo","date":"2020-04-20T07:16:36.000Z","updated":"2020-04-20T09:39:08.000Z","comments":true,"path":"2020/04/20/hexo/","link":"","permalink":"http://yoursite.com/2020/04/20/hexo/","excerpt":"","text":"搭建步骤获得个人网站域名GitHub创建个人仓库安装Git安装Node.js安装Hexo推送网站绑定域名更换主题初识MarkDown语法发布文章寻找图床个性化设置其他附录 1.首先安装 node和npm git 这些软件 以及注册github2.安装hexo12npm i hexo-cli -g 安装Hexohexo init blog 建立一个项目 3.连接Github与本地123456789101112131415161718git config --global user.name &quot;godweiyang&quot;git config --global user.email &quot;792321264@qq.com&quot;用户名和邮箱根据你注册github的信息自行修改。然后生成密钥SSH key：ssh-keygen -t rsa -C &quot;792321264@qq.com&quot;打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。cat ~&#x2F;.ssh&#x2F;id_rsa.pub将输出的内容复制到框中，点击确定保存。在终端输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。修改最后一行的配置：deploy: type: git repository: https:&#x2F;&#x2F;github.com&#x2F;godweiyang&#x2F;godweiyang.github.io branch: masterrepository修改为你自己的github项目地址。 4.hexo命令1234hexo new post &quot;article title&quot;，新建一篇文章。hexo generate 生成静态文件hexo server 运行hexo服务器hexo deploy 将Hexo上传到Github 5.建立标签分类生成”分类”hexo new page categories，来新建一个页面，并命名为categories。成功后会提示：INFO Created: ~/hexo/source/categories/index.md根据上面的路径找到index.md这个文件，打开后默认内容如下： 12title: categoriesdate: 2018-10-25 20:11:37 编辑新创建的页面，添加type: “categories”到内容中(注意，这些属性和属性值之间必须有一个空格)，主题将自动为这个页面显示所有分类，添加后是这样的： 123title: categoriesdate: 2018-10-25 20:11:37type: &quot;categories&quot; 保存并关闭文件。 给文章添加”categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: Python表示添加这篇文章到“Python”这个分类中。 注意：Hexo中一篇文章只能属于一个分类，也就是说如果在”Python”下方添加”-xxx”，Hexo不会产生两个分类，而是把分类嵌套，即该文章属于”Python“下的”-xxx“分类。 12title: Python中*args和**kwargs的用法总结categories: Python 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令(重新部署)。 在Hexo菜单上添加分类选项 menu: Python: /Python##6.遇到问题hexo d命令报错 ERROR Deployer not found: git 解决方案这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了： 1npm install hexo-deployer-git --save","categories":[{"name":"oneself","slug":"oneself","permalink":"http://yoursite.com/categories/oneself/"}],"tags":[]}],"categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"},{"name":"linux_private","slug":"linux-private","permalink":"http://yoursite.com/categories/linux-private/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"},{"name":"oneself","slug":"oneself","permalink":"http://yoursite.com/categories/oneself/"}],"tags":[]}