{"meta":{"title":"道法自然","subtitle":"记录精彩的人生, 留下永恒的脚印","description":"php教程 js教程 php博客 linux教程","author":"道法自然","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-04-20T09:02:01.000Z","updated":"2020-04-20T09:05:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP程序员学习路线","slug":"php_learn","date":"2020-04-20T11:12:39.000Z","updated":"2020-04-20T11:15:05.000Z","comments":true,"path":"2020/04/20/php_learn/","link":"","permalink":"http://yoursite.com/2020/04/20/php_learn/","excerpt":"","text":"第一阶段：基础阶段（基础 PHP 程序员）重点：把 LNMP 搞熟练（核心是安装配置基本操作） 目标：能够完成基本的 LNMP 系统安装，简单配置维护；能够做基本的简单系统的 PHP 开发；能够在 PHP 中型系统中支持某个 PHP 功能模块的开发。 时间：完成本阶段的时间因人而异，有的成长快半年一年就过了，成长慢的两三年也有。 1.Linux 基本命令、操作、启动、基本服务配置（包括 rpm 安装文件，各种服务配置等）；会写简单的 shell 脚本和 awk/sed 脚本命令等。 2.Nginx 做到能够安装配置 nginx+php，知道基本的 nginx 核心配置选项，知道 server/fastcgi_pass/access_log 等基础配置，目标是能够让 nginx+php_fpm 顺利工作。 3.MySQL 会自己搭建 MySQL，知道基本的 MySQL 配置选项；知道 innodb 和 myisam 的区别，知道针对 InnoDB 和 MyISAM 两个引擎的不同配置选项；知道基本的两个引擎的差异和选择上面的区别；能够纯手工编译搭建一个 MySQL 数据库并且配置好编码等正常稳定运行；核心主旨是能够搭建一个可运行的 MySQL 数据库。 4.PHP 基本语法数组、字符串、数据库、XML、Socket、GD/ImageMgk 图片处理等等；熟悉各种跟 MySQL 操作链接的 API（mysql/mysqli/PDO)，知道各种编码问题的解决；知道常规熟练使用的 PHP 框架（ThinkPHP、Zendframework、Yii、Yaf 等）；了解基本 MVC 的运行机制和为什么这么做，稍微知道不同的 PHP 框架之间的区别；能够快速学习一个 MVC 框架。能够知道开发工程中的文件目录组织，有基本的良好的代码结构和风格，能够完成小系统的开发和中型系统中某个模块的开发工作。 5.前端 如果条件时间允许，可以适当学习下 HTML/CSS/JS 等相关知识，知道什么 Web 标准，div+css 的 web/wap 页面模式，知道 HTML5 和 HTML4 的区别；了解一些基本的前端只是和 JS 框架（jQuery 之类的）；了解一些基本的 JavaScript 编程知识；（本项不是必须项，如果有时间，稍微了解一下是可以的，不过不建议作为重点，除非个人有强烈兴趣）。 6.系统设计 能够完成小型系统的基本设计，包括简单的数据库设计，能够完成基本的：浏览器 -&gt; Nginx+PHP -&gt; 数据库 架构的设计开发工作；能够支撑每天几十万到数百万流量网站的开发维护工作； 第二阶段：提高阶段 （中级 PHP 程序员）重点：提高针对 LNMP 的技能，能够更全面的对 LNMP 有熟练的应用。 目标：能够随时随地搭建好 LNMP 环境，快速完成常规配置；能够追查解决大部分遇到的开发和线上环境的问题；能够独立承担中型系统的构架和开发工作；能够在大型系统中承担某个中型模块的开发工作。 1. Linux 在第一阶段的基础上面，能够流畅的使用 Shell 脚本来完成很多自动化的工作；awk/sed/perl 也操作的不错，能够完成很多文本处理和数据统计等工作；基本能够安装大部分非特殊的 Linux 程序（包括各种库、包、第三方依赖等等，比如 MongoDB/Redis/Sphinx/Luncene/SVN 之类的）；了解基本的 Linux 服务，知道如何查看 Linux 的性能指标数据，知道基本的 Linux 下面的问题跟踪等。 2. Nginx 在第一阶段的基础上面，了解复杂一些的 Nginx 配置；包括 多核配置、events、proxy_pass，sendfile/tcp_*配置，知道超时等相关配置和性能影响；知道 nginx 除了 Web server，还能够承担代理服务器、反向静态服务器等配置；知道基本的 nginx 配置调优；知道如何配置权限、编译一个 nginx 扩展到 nginx；知道基本的 nginx 运行原理（master/worker 机制，epoll），知道为什么 nginx 性能比 apache 性能好等知识。 3. MySQL/MongoDB 在第一阶段的基础上面，在 MySQL 开发方面，掌握很多小技巧，包括常规 SQL 优化（group by/order by/rand 优化等）；除了能够搭建 MySQL，还能够冷热备份 MySQL 数据，还知道影响 innodb/myisam 性能的配置选项（比如 key_buffer/query_cache/sort_buffer/innodb_buffer_pool_size/innodb_flush_log_at_trx_commit 等），也知道这些选项配置成为多少值合适；另外也了解一些特殊的配置选项，比如 知道如何搭建 MySQL 主从同步的环境，知道各个 binlog_format 的区别；知道 MySQL 的性能追查，包括 slow_log/explain 等，还能够知道基本的索引建立处理等知识；原理方面了解基本的 MySQL 的架构（Server+ 存储引擎），知道基本的 InnoDB/MyISAM 索引存储结构和不同（聚簇索引，B 树）；知道基本的 InnoDB 事务处理机制；了解大部分 MySQL 异常情况的处理方案（或者知道哪儿找到处理方案）。条件允许的情况，建议了解一下 NoSQL 的代表 MongoDB 数据库，顺便对比跟 MySQL 的差别，同事能够在合适的应用场景安全谨慎的使用 MongoDB，知道基本的 PHP 与 MongoDB 的结合开发。 4. Redis/Memcached 在大部分中型系统里面一定会涉及到缓存处理，所以一定要了解基本的缓存；知道 Memcached 和 Redis 的异同和应用场景，能够独立安装 Redis/Memcached，了解 Memcahed 的一些基本特性和限制，比如最大的 value 值，知道 PHP 跟他们的使用结合；Redis 了解基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解 Redis 的事务等等。原理部分，能够大概了解 Memcached 的内存结构（slab 机制），Redis 就了解常用数据类型底层实现存储结构（SDS/链表/SkipList/HashTable）等等，顺便了解一下 Redis 的事务、RDB、AOF 等机制更好。 5. PHP 除了第一阶段的能力，安装配置方面能够随意安装 PHP 和各种第三方扩展的编译安装配置；了解 php-fpm 的大部分配置选项和含义（如 max_requests/max_children/request_terminate_timeout 之类的影响性能的配置），知道 mod_php/fastcgi 的区别；在 PHP 方面已经能够熟练各种基础技术，还包括各种深入些的 PHP，包括对 PHP 面向对象的深入理解/SPL/语法层面的特殊特性比如反射之类的；在框架方面已经阅读过最少一个以上常规 PHP MVC 框架的代码了，知道基本 PHP 框架内部实现机制和设计思想；在 PHP 开发中已经能够熟练使用常规的设计模式来应用开发（抽象工厂/单例/观察者/命令链/策略/适配器 等模式）；建议开发自己的 PHP MVC 框架来充分让开发自由化，让自己深入理解 MVC 模式，也让自己能够在业务项目开发里快速升级；熟悉 PHP 的各种代码优化方法，熟悉大部分 PHP 安全方面问题的解决处理；熟悉基本的 PHP 执行的机制原理（Zend 引擎/扩展基本工作机制）。 6. C/C++ 开始涉猎一定的 C/C++ 语言，能够写基本的 C/C++ 代码，对基本的 C/C++ 语法熟悉（指针、数组操作、字符串、常规标准 API）和数据结构（链表、树、哈希、队列）有一定的熟悉下；对 Linux 下面的 C 语言开发有基本的了解概念，会简单的 makefile 文件编写，能够使用简单的 GCC/GDB 的程序编译简单调试工作；对基本的网络编程有大概了解。（本项是为了向更高层次打下基础）。 7. 前端 在第一阶段的基础上面，熟悉基本的 HTTP 协议（协议代码 200/300/400/500，基本的 HTTP 交互头）；条件允许，可以在深入写出稍微优雅的 HTML+CSS+JavaScript，或者能够大致简单使用某些前端框架（jQuery/YUI/ExtJS/RequireJS/BootStrap 之类）；如果条件允许，可以深入学习 JavaScript 编程，比如闭包机制、DOM 处理；再深入些可以读读 jQuery 源码做深入学习。（本项不做重点学习，除非对前端有兴趣）。 8. 系统设计 能够设计大部分中型系统的网站架构、数据库、基本 PHP 框架选型；性能测试排查处理等；能够完成类似：浏览器 -&gt; CDN(Squid) -&gt; Nginx+PHP -&gt; 缓存 -&gt; 数据库 结构网站的基本设计开发维护；能够支撑每天数百万到千万流量基本网站的开发维护工作； 第三阶段：高级阶段 （高级 PHP 程序员）重点：除了基本的 LNMP 程序，还能够在某个方向或领域有深入学习。（纵深维度发展） 目标：除了能够完成基本的 PHP 业务开发，还能够解决大部分深入复杂的技术问题，并且可以独立设计完成中大型的系统设计和开发工作；自己能够独立 hold 深入某个技术方向，在这块比较专业。（比如在 MySQL、Nginx、PHP、Redis 等等任一方向深入研究） 1. Linux 除了第二阶段的能力，在 Linux 下面除了常规的操作和性能监控跟踪，还能够使用很多高级复杂的命令完成工作（watch/tcpdump/starce/ldd/ar 等)；在 shell 脚本方面，已经能够编写比较复杂的 shell 脚本（超过 500 行）来协助完成很多包括备份、自动化处理、监控等工作的 shell；对 awk/sed/perl 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据；对 Linux 内部机制有一些了解，对内核模块加载，启动错误处理等等有个基本的处理；同时对一些其他相关的东西也了解，比如 NFS、磁盘管理等等； 2. Nginx 在第二阶段的基础上面，已经能够把 Nginx 操作的很熟练，能够对 Nginx 进行更深入的运维工作，比如监控、性能优化，复杂问题处理等等；看个人兴趣，更多方面可以考虑侧重在关于 Nginx 工作原理部分的深入学习，主要表现在阅读源码开始，比如具体的 master/worker 工作机制，Nginx 内部的事件处理，内存管理等等；同时可以学习 Nginx 扩展的开发，可以定制一些自己私有的扩展；同时可以对 Nginx+Lua 有一定程度的了解，看看是否可以结合应用出更好模式；这个阶段的要求是对 Nginx 原理的深入理解，可以考虑成为 Nginx 方向的深入专业者。 3. MySQL/MongoDB 在第二阶段的基础上面，在 MySQL 应用方面，除了之前的基本 SQL 优化，还能够在完成一些复杂操作，比如大批量数据的导入导出，线上大批量数据的更改表结构或者增删索引字段等等高危操作；除了安装配置，已经能够处理更多复杂的 MySQL 的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL 高可用架构等都有涉及了解；对 MySQL 应用层面，对 MySQL 的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对 MySQL 性能方面，有包括磁盘优化（SAS 迁移到 SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其他核心性能优化选项（innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout 等）、连接池软件选择应用，对 show *（show status/show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；MySQL 备份技术的深入熟悉，包括灾备还原、对 Binlog 的深入理解，冷热备份，多 IDC 备份等；在 MySQL 原理方面，有更多了解，比如对 MySQL 的工作机制开始阅读部分源码，比如对主从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM/Innodb/TokuDB）等等的源码学习理解，如果条件允许，可以参考 CSV 引擎开发自己简单的存储引擎来保存一些数据，增强对 MySQL 的理解；在这个过程，如果自己有兴趣，也可以考虑往 DBA 方向发展。MongoDB 层面，可以考虑比如说在写少读多的情况开始在线上应用 MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解 RMDBS 和 NoSQL 的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下 MongoDB 的工作机制。 4. Redis/Memcached 在第二阶段的基础上面，能够更深入的应用和学习。因为 Memcached 不是特别复杂，建议可以把源码进行阅读，特别是内存管理部分，方便深入理解；Redis 部分，可以多做一些复杂的数据结构的应用（zset 来做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作）；多涉及 aof 等同步机制的学习应用，设计一个高可用的 Redis 应用架构和集群；建议可以深入的学习一下 Redis 的源码，把在第二阶段积累的知识都可以应用上，特别可以阅读一下包括核心事件管理、内存管理、内部核心数据结构等充分学习了解一下。如果兴趣允许，可以成为一个 Redis 方面非常专业的使用者。 5. PHP 作为基础核心技能，我们在第二阶段的基础上面，需要有更深入的学习和应用。从基本代码应用上面来说，能够解决在 PHP 开发中遇到 95% 的问题，了解大部分 PHP 的技巧；对大部分的 PHP 框架能够迅速在一天内上手使用，并且了解各个主流 PHP 框架的优缺点，能够迅速方便项目开发中做技术选型；在配置方面，除了常规第二阶段会的知识，会了解一些比较偏门的配置选项（PHP auto_prepend_file/auto_append_file），包括扩展中的一些复杂高级配置和原理（比如 Memcached 扩展配置中的 memcache.hash_strategy、apc 扩展配置中的 apc.mmap_file_mask/apc.slam_defense/apc.file_update_protection 之类的）；对 PHP 的工作机制比较了解，包括 php-fpm 工作机制（比如 php-fpm 在不同配置机器下面开启进程数量计算以及原理），对 zend 引擎有基本熟悉（vm/gc/stream 处理），阅读过基本的 PHP 内核源码（或者阅读过相关文章），对 PHP 内部机制的大部分核心数据结构（基础类型/Array/Object）实现有了解，对于核心基础结构（zval/hashtable/gc）有深入学习了解；能够进行基本的 PHP 扩展开发，了解一些扩展开发的中高级知识（minit/rinit 等），熟悉 PHP 跟 apache/nginx 不同的通信交互方式细节（mod_php/fastcgi）；除了开发 PHP 扩展，可以考虑学习开发 Zend 扩展，从更底层去了解 PHP。 6. C/C++ 在第二阶段基础上面，能够在 C/C++ 语言方面有更深入的学习了解，能够完成中小型 C/C++ 系统的开发工作；除了基本第二阶段的基础 C/C++ 语法和数据结构，也能够学习一些特殊数据结构（b-tree/rb-tree/skiplist/lsm-tree/trie-tree 等）方便在特殊工作中需求；在系统编程方面，熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存/信号量/管道等）；多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；同时对网络编程比较熟悉，了解多进程模型/多线程模型/异步网络 IO 模型的差别和选型，熟悉不同异步网络 IO 模型的原理和差异（select/poll/epoll/iocp 等），并且熟悉常见的异步框架（ACE/ICE/libev/libevent/libuv/Boost.ASIO 等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如 muduo）；同时能够设计好的高并发程序架构（leader-follow/master-worker 等）；了解大部分 C/C++ 后端 Server 开发中的问题（内存管理、日志打印、高并发、前后端通信协议、服务监控），知道各个后端服务 RPC 通信问题（struct/http/thirft/protobuf 等）；能够更熟络的使用 GCC 和 GDB 来开发编译调试程序，在线上程序 core 掉后能够迅速追查跟踪解决问题；通用模块开发方面，可以积累或者开发一些通用的工具或库（比如异步网络框架、日志库、内存池、线程池等），不过开发后是否应用要谨慎，省的埋坑去追 bug。 7. 前端 深入了解 HTTP 协议（包括各个细致协议特殊协议代码和背后原因，比如 302 静态文件缓存了，502 是 nginx 后面 PHP 挂了之类的）；除了之前的前端方面的各种框架应用整合能力，前端方面的学习如果有兴趣可以更深入，表现形式是，可以自己开发一些类似 jQuery 的前端框架，或者开发一个富文本编辑器之类的比较琐碎考验 JavaScript 功力。 8. 其他领域语言学习 在基础的 PHP/C/C++ 语言方面有基本积累，建议在当前阶段可以尝试学习不同的编程语言，看个人兴趣爱好，脚本类语言可以学学 Python/Ruby 之类的，函数式编程语言可以试试 Lisp/Haskell/Scala/Erlang 之类的，静态语言可以试试 Java/Golang，数据统计分析可以了解了解 R 语言，如果想换个视角做后端业务，可以试试 Node.js 还有前面提到的跟 Nginx 结合的 Nginx_Lua 等。学习不同的语言主要是提升自己的视野和解决问题手段的差异，比如会了解除了进程/线程，还有轻量级协程；比如在跨机器通信场景下面，Erlang 的解决方案简单的惊人；比如在不想选择 C/C++ 的情况下，还有类似高效的 Erlang/Golang 可用等等；主要是提升视野。 9. 其他专业方向学习 在本阶段里面，会除了基本的 LNMP 技能之外，会考虑一些其他领域知识的学习，这些都是可以的，看个人兴趣和长期的目标方向。目前情况能够选择的领域比较多，比如、云计算（分布式存储、分布式计算、虚拟机等），机器学习（数据挖掘、模式识别等，应用到统计、个性化推荐），自然语言处理（中文分词等），搜索引擎技术、图形图像、语音识别等等。除了这些高大上的，也有很多偏工程方面可以学习的地方，比如高性能系统、移动开发（Android/IOS）、计算机安全、嵌入式系统、硬件等方向。 10. 系统设计 系统设计在第二阶段的基础之上，能够应用掌握的经验技能，设计出比较复杂的中大型系统，能够解决大部分线上的各种复杂系统的问题，完成类似 浏览器 -&gt; CDN -&gt; 负载均衡 -&gt; 接入层 -&gt; Nginx+PHP -&gt; 业务缓存 -&gt; 数据库 -&gt; 各路复杂后端 RPC 交互（存储后端、逻辑后端、反作弊后端、外部服务） -&gt; 更多后端 酱紫的复杂业务；能够支撑每天数千万到数亿流量网站的正常开发维护工作。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"Yaf教程1：安装","slug":"yaf02","date":"2020-04-20T11:11:22.000Z","updated":"2020-04-20T11:12:03.000Z","comments":true,"path":"2020/04/20/yaf02/","link":"","permalink":"http://yoursite.com/2020/04/20/yaf02/","excerpt":"","text":"Yaf 要求 PHP 必须为 5.2 及以上版本，如果是 PHP7，请使用 Yaf 3。本教程使用 64 位的 PHP 5.6，所以使用最后稳定版本 *Yaf 2.3.5 *为例。 1 Linux 服务器确保服务器上安装了 PHP，再到 PHP PECL 下载 Yaf 源码： 123456789wget https:&#x2F;&#x2F;github.com&#x2F;laruence&#x2F;yaf&#x2F;archive&#x2F;yaf-3.0.8.tar.gzcd yaf-3.0.8phpize.&#x2F;configuremake &amp;&amp; make installsudo vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;7.2&#x2F;php.ini#加入配置extension&#x3D;php_yaf.dll#使用phpinfo()查看扩展或者使用 php -m 查看 2 下载yaf框架1234git clone https:&#x2F;&#x2F;github.com&#x2F;laruence&#x2F;yaf.gitcd yaf&#x2F;tools&#x2F;cgphp yaf_cg yaf #生成框架cd output #这个目录下的项目就是yaf框架了","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"Yaf教程0：简介","slug":"yaf01","date":"2020-04-20T11:09:45.000Z","updated":"2020-04-20T11:11:00.000Z","comments":true,"path":"2020/04/20/yaf01/","link":"","permalink":"http://yoursite.com/2020/04/20/yaf01/","excerpt":"","text":"Yaf，全称 Yet Another Framework，是一个高性能的 PHP 开发框架。Yaf 用 C 语言编写，以 PHP 扩展形式作为 PHP 开发框架。相比于一般的 PHP 框架，如 Zend Framework、Yii、Ci，它更快更轻便。它提供了启动配置、路由、分发、视图、插件等功能， 是一个全功能的 PHP 框架。 Yaf 特点： 用 C 语言开发的 PHP 框架， 相比原生的 PHP, 几乎不会带来额外的性能开销。 所有的框架类， 不需要编译, 在 PHP 启动的时候加载， 并常驻内存. 更短的内存周转周期， 提高内存利用率, 降低内存占用率。 灵巧的自动加载. 支持全局和局部两种加载规则， 方便类库共享。 高性能的视图引擎. 高度灵活可扩展的框架, 支持自定义视图引擎， 支持插件， 支持自定义路由等等。 内建多种路由, 可以兼容目前常见的各种路由协议。 强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失。 在框架本身，对危险的操作习惯做了禁止. 更快的执行速度， 更少的内存占用.","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"mysql的备份和导出","slug":"mysqldump","date":"2020-04-20T11:08:08.000Z","updated":"2020-04-20T11:10:18.000Z","comments":true,"path":"2020/04/20/mysqldump/","link":"","permalink":"http://yoursite.com/2020/04/20/mysqldump/","excerpt":"","text":"1.导出整个数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u root -p dataname &gt;dataname.sql备份 MySQL 数据库的命令mysqldump -hhostname -uusername -ppassword databasename &gt; backupfile.sql备份 MySQL 数据库为带删除表的格式备份 MySQL 数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。mysqldump -–add-drop-table -uusername -ppassword databasename &gt; backupfile.sql直接将 MySQL 数据库压缩备份mysqldump -hhostname -uusername -ppassword databasename | gzip &gt; backupfile.sql.gz备份 MySQL 数据库某个(些)表mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 &gt; backupfile.sql同时备份多个 MySQL 数据库mysqldump -hhostname -uusername -ppassword –databases databasename1 databasename2 databasename3 &gt; multibackupfile.sql仅仅备份数据库结构mysqldump –no-data –databases databasename1 databasename2 databasename3 &gt; structurebackupfile.sql备份服务器上所有数据库mysqldump –all-databases &gt; allbackupfile.sql还原 MySQL 数据库的命令MySQL -hhostname -uusername -ppassword databasename &lt; backupfile.sql还原压缩的 MySQL 数据库gunzip &lt; backupfile.sql.gz | MySQL -uusername -ppassword databasename将数据库转移到新服务器mysqldump -uusername -ppassword databasename | MySQL –host&#x3D;*.*.*.* -C databasename2.导出一个表mysqldump -u 用户名 -p 数据库名 表名 &gt; 导出的文件名mysqldump -u root -p dataname users&gt; dataname_users.sql3.导出一个数据库结构mysqldump -u wcnc -p -d –add-drop-table smgp_apps_wcnc &gt;d:\\wcnc_db.sql-d 没有数据 –add-drop-table 在每个 create 语句之前增加一个 drop table4.导入数据库常用 source 命令进入 MySQL 数据库控制台，如 MySQL -u root -pmysql&gt;use 数据库然后使用 source 命令，后面参数为脚本文件（如这里用到的。SQL）mysql&gt;source d:\\wcnc_db.sqlmysqldump 支持下列选项：–add-locks在每个表导出之前增加 LOCK TABLES 并且之后 UNLOCK TABLE。(为了使得更快地插入到 MySQL)。–add-drop-table在每个 create 语句之前增加一个 drop table。–allow-keywords允许创建是关键词的列名字。这由表名前缀于每个列名做到。-c, –complete-insert使用完整的 insert 语句(用列名字)。-C, –compress如果客户和服务器均支持压缩，压缩两者间所有的信息。–delayed用 Insert DELAYED 命令插入行。-e, –extended-insert使用全新多行 Insert 语法。（给出更紧缩并且更快的插入语句）-#, –debug[&#x3D;option_string]跟踪程序的使用(为了调试)。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[]},{"title":"linux scp 服务器远程拷贝","slug":"scp","date":"2020-04-20T11:05:49.000Z","updated":"2020-04-20T11:10:09.000Z","comments":true,"path":"2020/04/20/scp/","link":"","permalink":"http://yoursite.com/2020/04/20/scp/","excerpt":"","text":"一、将本机文件复制到远程服务器上 #scp /home/administrator/news.txt root@192.168.1.1:/etc/squid /home/administrator/ 本地文件的绝对路径 news.txt 要复制到服务器上的本地文件 root 通过root用户登录到远程服务器（也可以使用其他拥有同等权限的用户） 192.168.6.129 远程服务器的ip地址（也可以使用域名或机器名） /etc/squid 将本地文件复制到位于远程服务器上的路径 二、将远程服务器上的文件复制到本机 #scp remote@www.abc.com:/usr/local/sin.sh /home/administrator remote 通过remote用户登录到远程服务器（也可以使用其他拥有同等权限的用户） www.abc.com 远程服务器的域名（当然也可以使用该服务器ip地址） /usr/local/sin.sh 欲复制到本机的位于远程服务器上的文件 /home/administrator 将远程文件复制到本地的绝对路径","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"php服务器把session放到redis中","slug":"session_redis","date":"2020-04-20T11:05:03.000Z","updated":"2020-04-20T11:07:36.000Z","comments":true,"path":"2020/04/20/session_redis/","link":"","permalink":"http://yoursite.com/2020/04/20/session_redis/","excerpt":"","text":"一、将本机文件复制到远程服务器上 #scp /home/administrator/news.txt root@192.168.1.1:/etc/squid /home/administrator/ 本地文件的绝对路径 news.txt 要复制到服务器上的本地文件 root 通过root用户登录到远程服务器（也可以使用其他拥有同等权限的用户） 改为 123session.save_handler &#x3D; redissession.save_path &#x3D; &quot;tcp:&#x2F;&#x2F;127.0.0.1:6379&quot;&quot;tcp:&#x2F;&#x2F;127.0.0.1:6379&quot; 重启 apache 以生效 12service httpd restart httpd restart 如果是以 FastCGI 运行的（比如 nginx 就是默认 FastCGI 运行的）编辑 /etc/php-fpm.d/www.conf（可能视系统环境而路径不一样）把这两行 123php_value[session.save_handler] &#x3D; filesphp_value[session.save_path] &#x3D; &#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;var&#x2F;lib&#x2F;php&#x2F;session 改为（其实就是增加分号以注释掉） 123;php_value[session.save_handler] &#x3D; files;php_value[session.save_path] &#x3D; &#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;var&#x2F;lib&#x2F;php&#x2F;session 然后增加两行： 123php_value[session.save_handler] &#x3D; redisphp_value[session.save_path] &#x3D; tcp:&#x2F;&#x2F;127.0.0.1:6379&#x2F;&#x2F;127.0.0.1:6379 重启 PHP 服务以生效 1service php-fpm restart php-fpm restart","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"PHP写文件函数file_put_contents 加锁","slug":"file_put_contents","date":"2020-04-20T11:03:38.000Z","updated":"2020-04-20T11:07:18.000Z","comments":true,"path":"2020/04/20/file_put_contents/","link":"","permalink":"http://yoursite.com/2020/04/20/file_put_contents/","excerpt":"","text":"file_put_contents 写 PHP 的 Cache 文件，如果不加 LOCK_EX 就可能会存在同步问题，当一个进程写 file 时，只写到一半有另外的进程去 require 此文件， 这时就会因为文件不完整，导致 PHP 语法错误。所以涉及到同时读写同一个文件或数据时一定要加锁，否则在高并发的情况下会产生严重错误。 最近有个项目需要用 file_put_contents 函数写 txt 文件，由于需要频繁操作，所以经常出现前半截内容缺失的情况，非常苦恼。 后来查询资料发现，file_put_contents 函数有个参数 LOCK_EX 非常有用，加上它之后，再也没有出现过内容缺失的情况了。 这个参数 LOCK_EX 的意思很直白，就是写文件时，先锁上这个文件，这样只允许某个客户端访问的时候写，其他客户端访问不能写了。 我的用法如下： 1| &#96;file_put_contents($file, $content, FILE_APPEND|LOCK_EX)&#96; 解释：$file=&gt; 这个是写入文件的路径 + 文件名$content=&gt; 这个是写入文件的内容FILE_APPEND=&gt; 直接在该文件已有的内容后面追加内容LOCK_EX=&gt; 写文件的时候先锁定，防止多人同时写入造成内容丢失|","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"Etag缓存在PHP","slug":"etag","date":"2020-04-20T10:30:29.000Z","updated":"2020-04-20T10:43:02.000Z","comments":true,"path":"2020/04/20/etag/","link":"","permalink":"http://yoursite.com/2020/04/20/etag/","excerpt":"","text":"HTTP 提供了许多页面缓存的方案，其中属 Etag 和 Last-Modified 应用最广。本文会先介绍 Etag 的应用场景，然后说说他在 PHP 和 node 中的使用。 一、Etag 的使用客户端和浏览器之间的交互： +---------+ 1 +---------+ | |---------------->| | | | 2（200，OK） | | | || | | 户 | 4（304） | 务 | | || | | | 6（200，OK） | | | |","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"php异常、错误处理机制","slug":"catch","date":"2020-04-20T10:29:27.000Z","updated":"2020-04-20T10:33:10.000Z","comments":true,"path":"2020/04/20/catch/","link":"","permalink":"http://yoursite.com/2020/04/20/catch/","excerpt":"","text":"1.php 中 try catch 可以帮助我们捕获程序代码的异常了，这样我们可以很好的处理一些不必要的错误了，感兴趣的朋友可以一起来看看。 PHP 中 try{}catch{}语句概述 PHP5 添加了类似于其它语言的异常处理模块。在 PHP 代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。（注：一定要先抛才能获取） 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch。 使用多个 catch 可以捕获不同的类所产生的异常。 当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 当然，PHP 允许在 catch 代码块内再次抛出（throw）异常。 当一个异常被抛出时，其后（译者注：指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。 如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception … （未捕获异常）的提示信息。 先来看一下 PHP 内置异常类的基本属性和方法。（不包括具体实现） 12345678910111213try&#123;&#125;catch()&#123;throw new Exception();&#125;catch()&#123;&#x2F;&#x2F;这里可以捕获到前面一个块抛出的Exception&#96;&#125; 如果抛出了一个异常，try 语句中的脚本将会停止执行，然后马上转向执行 catch 语句中的脚本。 例子如下： 包含文件错误抛出异常 12345678910111213141516171819202122232425262728&lt;?php&#x2F;&#x2F; 错误的演示try &#123;require (&#39;test_try_catch.php&#39;);&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&#39;test_try_catch.php&#39;);&#125; else &#123;throw new Exception(&#39;file is not exists&#39;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&quot;test_try_catch.php&quot;);&#125; else &#123;throw new Exception(&quot;file is not exists&quot;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125; 2、通过 set_exception_handler 函数设置异常处理函数，在这种情况下，即使没有 try{}catch{}，throw 抛出的异常也能由 set_exception_handler 设置的函数自动捕捉 123456set_exception_handler(&#39;exceptionHandler&#39;); throw new Exception(&quot;kkkkkkkkkkkkkkkk&quot;); function exceptionHandler(Exception $exception)&#123; echo $exception-&gt;getMessage(); &#125; 在 PHP 开发的时候常常会用到 error_reporting(report_level)来调试自己的程序，下面列出了 report_level 可能值： | 值 | 常量 | 描述 || 1 | E_ERROR | 这是一个严重错误，不可恢复，如位置异常，内存不足等 || 2 | E_WARNING | 警告，最一般的错误，如函数的参数错误等 || 4 | E_PARSE | 解析错误，在解析 PHP 文件时产生，并强制 PHP 在执行前退出 || 8 | E_NOTICE | 通告表示可能在操作一些未知的变量等。在开发时可开启通告，以保证程序是”安全通告”的，瑞在正式系统中，应关闭通告 || 16 | E_CORE_ERROR | 这个内部错误是由于 PHP 加载扩展失败而导致的，并且会导致 PHP 停止运行并退出 || 32 | E_CORE_WARNING | PHP 启动时初始化过程中的警告(非致命性错) || 64 | E_COMPILE_ERROR | 编译错误是在编译时发生，这个错误将导致 PHP 运行退出 || 128 | E_COMPILE_WARNING | 编译警告用于告诉用户一些不推荐的语法信息 || 256 | E_USER_ERROR | 用户定义的错误将导致辞 PHP 退出，它对是来自 PHP 自身，而是来自脚本文件中。 || 512 | E_USER_WARNING | 脚本使用它来通知一个执行失败，同时 PHP 也会用 E_WARNING 通知 || 1024 | E_USER_NOTICE | 用户定义的通告用于在脚本中表示可能存在的错误 || 2048 | E_STRICT | 编码标准化警告(建议如何修改以向前兼容) || 4096 | E_RECOVERABLE_ERROR | 接近致命的运行时错误，若未被捕获则视同 E_ERROR || 8191 | E_ALL | 除 E_STRICT 外的所有错误(PHP6 中为 8191,即包含所有) | 例子： 任意数目的以上选项都可以用“或”来连接（用 OR 或 |），这样可以报告所有需要的各级别错误。例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别： 12345678910111213141516171819&lt;?php&#x2F;&#x2F;禁用错误报告error_reporting(0); &#x2F;&#x2F;报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE); &#x2F;&#x2F;报告所有错误error_reporting(E_ALL); error_reporting(7);&#x2F;*设置php错误检测级别E_ERROR - 致命性运行时错 (1)E_WARNING - 运行时警告（非致命性错）(2)E_PARSE - 编译时解析错误 (4)1+2+4 &#x3D; 7*&#x2F;?&gt; 如果设置了 error_reporting(E_NOTICE)，那么程序只会输出 E_NOTICE 等级的信息，一般我们使用的时候只需要设置 error_reporting(E_ALL&amp;!E_WARNING)就行了 上面我们看到有一种错误叫用户自定义的错误消息，这是什么呢？我们先看一个例子 123456set_error_handler(&#39;errorHandler&#39;); trigger_error(&quot;aaaaaaassssssssssss&quot;,E_USER_ERROR); function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_USER_ERROR)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; 输出结果： 1innnnnnnni:aaaaaaassssssssssss trigger_error()就是用来抛出用户自定义错误消息的函数，通过这个我们能抛出自定义的一些消息被当作错误来处理，比如严重的逻辑问题 上面的程序我们看到，当程序出错时，除了让 PHP 默认输出出错信息外，我们还能设置自己的错误处理函数，设置的方法就是set_error_handler(),下面来看个例子 12345678set_error_handler(&#39;errorHandler&#39;); echo &quot;dddddddddddd&lt;&#x2F;br&gt;&quot;; echo $cc;&#x2F;&#x2F;$cc没有定义，echo会出错 function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_NOTICE)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; &#125; 输出结果： 12ddddddddddddinnnnnnnni:Undefined variable: cc","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"iconv的使用方法(转换编码,截取字符串,统计长度)","slug":"iconv","date":"2020-04-20T10:27:54.000Z","updated":"2020-04-20T10:30:00.000Z","comments":true,"path":"2020/04/20/iconv/","link":"","permalink":"http://yoursite.com/2020/04/20/iconv/","excerpt":"","text":"1.php 中 try catch 可以帮助我们捕获程序代码的异常了，这样我们可以很好的处理一些不必要的错误了，感兴趣的朋友可以一起来看看。 PHP 中 try{}catch{}语句概述 PHP5 添加了类似于其它语言的异常处理模块。在 PHP 代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。（注：一定要先抛才能获取） 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch。 使用多个 catch 可以捕获不同的类所产生的异常。 当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 当然，PHP 允许在 catch 代码块内再次抛出（throw）异常。 当一个异常被抛出时，其后（译者注：指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。 如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception … （未捕获异常）的提示信息。 先来看一下 PHP 内置异常类的基本属性和方法。（不包括具体实现） 12345678910111213try&#123;&#125;catch()&#123;throw new Exception();&#125;catch()&#123;&#x2F;&#x2F;这里可以捕获到前面一个块抛出的Exception&#96;&#125; 如果抛出了一个异常，try 语句中的脚本将会停止执行，然后马上转向执行 catch 语句中的脚本。 例子如下： 包含文件错误抛出异常 12345678910111213141516171819202122232425262728&lt;?php&#x2F;&#x2F; 错误的演示try &#123;require (&#39;test_try_catch.php&#39;);&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&#39;test_try_catch.php&#39;);&#125; else &#123;throw new Exception(&#39;file is not exists&#39;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&quot;test_try_catch.php&quot;);&#125; else &#123;throw new Exception(&quot;file is not exists&quot;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125; 2、通过 set_exception_handler 函数设置异常处理函数，在这种情况下，即使没有 try{}catch{}，throw 抛出的异常也能由 set_exception_handler 设置的函数自动捕捉 123456set_exception_handler(&#39;exceptionHandler&#39;); throw new Exception(&quot;kkkkkkkkkkkkkkkk&quot;); function exceptionHandler(Exception $exception)&#123; echo $exception-&gt;getMessage(); &#125; 在 PHP 开发的时候常常会用到 error_reporting(report_level)来调试自己的程序，下面列出了 report_level 可能值： | 值 | 常量 | 描述 || 1 | E_ERROR | 这是一个严重错误，不可恢复，如位置异常，内存不足等 || 2 | E_WARNING | 警告，最一般的错误，如函数的参数错误等 || 4 | E_PARSE | 解析错误，在解析 PHP 文件时产生，并强制 PHP 在执行前退出 || 8 | E_NOTICE | 通告表示可能在操作一些未知的变量等。在开发时可开启通告，以保证程序是”安全通告”的，瑞在正式系统中，应关闭通告 || 16 | E_CORE_ERROR | 这个内部错误是由于 PHP 加载扩展失败而导致的，并且会导致 PHP 停止运行并退出 || 32 | E_CORE_WARNING | PHP 启动时初始化过程中的警告(非致命性错) || 64 | E_COMPILE_ERROR | 编译错误是在编译时发生，这个错误将导致 PHP 运行退出 || 128 | E_COMPILE_WARNING | 编译警告用于告诉用户一些不推荐的语法信息 || 256 | E_USER_ERROR | 用户定义的错误将导致辞 PHP 退出，它对是来自 PHP 自身，而是来自脚本文件中。 || 512 | E_USER_WARNING | 脚本使用它来通知一个执行失败，同时 PHP 也会用 E_WARNING 通知 || 1024 | E_USER_NOTICE | 用户定义的通告用于在脚本中表示可能存在的错误 || 2048 | E_STRICT | 编码标准化警告(建议如何修改以向前兼容) || 4096 | E_RECOVERABLE_ERROR | 接近致命的运行时错误，若未被捕获则视同 E_ERROR || 8191 | E_ALL | 除 E_STRICT 外的所有错误(PHP6 中为 8191,即包含所有) | 例子： 任意数目的以上选项都可以用“或”来连接（用 OR 或 |），这样可以报告所有需要的各级别错误。例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别： 12345678910111213141516171819&lt;?php&#x2F;&#x2F;禁用错误报告error_reporting(0); &#x2F;&#x2F;报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE); &#x2F;&#x2F;报告所有错误error_reporting(E_ALL); error_reporting(7);&#x2F;*设置php错误检测级别E_ERROR - 致命性运行时错 (1)E_WARNING - 运行时警告（非致命性错）(2)E_PARSE - 编译时解析错误 (4)1+2+4 &#x3D; 7*&#x2F;?&gt; 如果设置了 error_reporting(E_NOTICE)，那么程序只会输出 E_NOTICE 等级的信息，一般我们使用的时候只需要设置 error_reporting(E_ALL&amp;!E_WARNING)就行了 上面我们看到有一种错误叫用户自定义的错误消息，这是什么呢？我们先看一个例子 123456set_error_handler(&#39;errorHandler&#39;); trigger_error(&quot;aaaaaaassssssssssss&quot;,E_USER_ERROR); function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_USER_ERROR)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; 输出结果： 1innnnnnnni:aaaaaaassssssssssss trigger_error()就是用来抛出用户自定义错误消息的函数，通过这个我们能抛出自定义的一些消息被当作错误来处理，比如严重的逻辑问题 上面的程序我们看到，当程序出错时，除了让 PHP 默认输出出错信息外，我们还能设置自己的错误处理函数，设置的方法就是set_error_handler(),下面来看个例子 12345678set_error_handler(&#39;errorHandler&#39;); echo &quot;dddddddddddd&lt;&#x2F;br&gt;&quot;; echo $cc;&#x2F;&#x2F;$cc没有定义，echo会出错 function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_NOTICE)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; &#125; 输出结果： 12ddddddddddddinnnnnnnni:Undefined variable: cc","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"百度语音接口简单使用","slug":"baidu","date":"2020-04-20T10:23:01.000Z","updated":"2020-04-20T10:23:55.000Z","comments":true,"path":"2020/04/20/baidu/","link":"","permalink":"http://yoursite.com/2020/04/20/baidu/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpheader(&quot;Content-type:text&#x2F;html;charset&#x3D;utf-8&quot;);define(&#39;AUDIO_FILE&#39;, &quot;.&#x2F;test2.pcm&quot;);&#x2F;&#x2F;put your params here$cuid &#x3D; &quot;&quot;;$apiKey &#x3D; &quot;&quot;;$secretKey &#x3D; &quot;&quot;;$auth_url &#x3D; &quot;https:&#x2F;&#x2F;openapi.baidu.com&#x2F;oauth&#x2F;2.0&#x2F;token?grant_type&#x3D;client_credentials&amp;client_id&#x3D;&quot;.$apiKey.&quot;&amp;client_secret&#x3D;&quot;.$secretKey;$ch &#x3D; curl_init();curl_setopt($ch, CURLOPT_URL, $auth_url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);$response &#x3D; curl_exec($ch);if(curl_errno($ch))&#123; print curl_error($ch);&#125;curl_close($ch);$response &#x3D; json_decode($response, true);$token &#x3D; $response[&#39;access_token&#39;];$url &#x3D; &quot;http:&#x2F;&#x2F;vop.baidu.com&#x2F;server_api?cuid&#x3D;&quot;.$cuid.&quot;&amp;token&#x3D;&quot;.$token;&#x2F;&#x2F;$url &#x3D; $url.&quot;&amp;lan&#x3D;zh&quot;;$audio &#x3D; file_get_contents(AUDIO_FILE);$content_len &#x3D; &quot;Content-Length: &quot;.strlen($audio);$header &#x3D; array ($content_len,&#39;Content-Type: audio&#x2F;pcm; rate&#x3D;8000&#39;,);$ch &#x3D; curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_HTTPHEADER, $header);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);curl_setopt($ch, CURLOPT_TIMEOUT, 30);curl_setopt($ch, CURLOPT_POSTFIELDS, $audio);$response &#x3D; curl_exec($ch);if(curl_errno($ch))&#123; print curl_error($ch);&#125;curl_close($ch);echo $response;$response &#x3D; json_decode($response, true);&#x2F;&#x2F;var_dump($response);?&gt; 测试的时候官方会提示一个 3300 的错误 是证书验证不通过 特在此记录一下 在第一个 curl 里面加上下面语句就 ok 了 有兴趣的可以试一下吧 123&#96;curl_setopt(&#96;&#96;$ch&#96;&#96;, CURLOPT_SSL_VERIFYPEER, FALSE);&#96;&#96;curl_setopt(&#96;&#96;$ch&#96;&#96;, CURLOPT_SSL_VERIFYHOST, FALSE);&#96;","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"session和cookie的区别","slug":"session","date":"2020-04-20T10:21:32.000Z","updated":"2020-04-20T10:26:26.000Z","comments":true,"path":"2020/04/20/session/","link":"","permalink":"http://yoursite.com/2020/04/20/session/","excerpt":"","text":"——————————————session 的使用————————————– session 中同一浏览器同一站点只能有一个 session_id,下面我们一起来看看关于 session 使用方法。如何使用 session，凡是与 session 有关的，之前必须调用函数 session_start();为 session 赋值很简单，如： 1234567&lt;?phpSession_start();$Name &#x3D; &quot;这是一个Session例子&quot;;Session_Register(&quot;Name&quot;);&#x2F;&#x2F;注意,不要写成：Session_Register(&quot;$Name&quot;);echo $_SESSION[&quot;Name&quot;];&#x2F;&#x2F;输出$_SESSION[&quot;Name&quot;]为&quot;这是一个Session例子&quot;?&gt; 取消 session 可以这样： 12345&lt;?phpsession_start();session_unset();session_destroy();?&gt; 读取 session PHP 内置的 $_SESSION 变量可以很方便的访问设置的 session 变量。 1234&lt;?phpsession_start();echo &quot;登记的用户名为：&quot;.$_SESSION[&quot;username&quot;]; &#x2F;&#x2F;输出 登记的用户名为：nostop?&gt; 检查变量是否被登记为会话变量 session_is_registered语法：boobean session_is_registered(string name);这个函数可检查当前的 session 之中是否已有指定的变量注册，参数 name 就是要检查的变量名。成功则返回逻辑值 true。 123456&lt;?php session_start(); if(!session_is_registered(&quot;gender&quot;))&#123; &#x2F;&#x2F;判断当前会话变量是否注册 session_register(&quot;gender&quot;); &#x2F;&#x2F;注册变量 &#125; $gender&#x3D;&quot;女&quot;; ?&gt; 1234存取当前会话名称 session_name语法：boolean session_name(string [name]);这个函数可取得或重新设置当前 session 的名称。若无参数 name 则表示获取当前 session 名称，加上参数则表示将 session 名称设为参数 name。 12345存取当前会话标识号 session_id语法：boolean session_id(string [id]);这个函数可取得或重新设置当前存放 session 的标识号。若无参数 id 则表示只获取当前 session 的标识号，加上参数则表示将 session 的标识号设成新指定的 id。设置 Session 的生存期 123session_set_cookie_params:设置 Session 的生存期的，该函数必须在 session_start() 函数调用之前调用。如果客户端使用 IE 6.0 ， session_set_cookie_params(); 函数设置 Cookie 会有些问题，所以我们还是手动调用 setcookie 函数来创建 cookie。 123设置 Session 文件的保存路径session_save_path() ：必须在 session_start() 函数调用之前调用 12 12注意：1:在调用 Session_Start()之前不能有任何输出。例如下面是错误的。 12345678910111213141516171819202122232425提示 1:凡是出现&quot;........headers already sent..........&quot;,就是 Session_Start()之前向浏览器输出信息。去掉输出就正常，（COOKIE 也会出现这种错误，错误原因一样）提示 2:如果你的 Session_Start()放在循环语句里，并且很难确定之前哪里向浏览器输出信息，可以用下面这种方法：1 行 &lt;?PHP Ob_Start(); ?&gt;........这里是你的程序......2:这是什么错误Warning: session_start(): open(&#x2F;tmpsess_7d190aa36b4c5ec13a5c1649cc2da23f, O_RDWR) failed:....因为你没有指定 session 文件的存放路径。解决方法：(1)在 c 盘建立文件夹 tmp(2)打开 php.ini,找到 session.save_path,修改为 session.save_path&#x3D; &quot;c:&#x2F;tmp&quot;------------------------------------------**PHP cookie 的使用以及坑**--------------------------------------1.设置 cookie setcookie(‘uid’, 3, time()+3600, ‘/‘, $_SERVER[‘HTTP_HOST’]); // cookie 名字 cookie 值 过期时间 path 保存目录 作用域 12.设置 cookie 的过期 setcookie(‘uid’, 0, 0, ‘/‘, $_SERVER[‘HTTP_HOST’]); 123453.cookie 的坑 url 区分大小写如果不加第四个参数 可能会在 url 大小写下出现获取不到 cookie 所以一定要加上域名的作用域4.语法 setcookie(name,value,expire,path,domain,secure) 参数 描述 name 必需。规定 cookie 的名称。 value 必需。规定 cookie 的值。 expire 可选。规定 cookie 的有效期。 path 可选。规定 cookie 的服务器路径。 domain 可选。规定 cookie 的域名。 secure 可选。规定是否通过安全的 HTTPS 连接来传输 cookie。 ```","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"hexo 使用教程","slug":"hexo","date":"2020-04-20T07:16:36.000Z","updated":"2020-04-20T09:39:08.000Z","comments":true,"path":"2020/04/20/hexo/","link":"","permalink":"http://yoursite.com/2020/04/20/hexo/","excerpt":"","text":"搭建步骤获得个人网站域名GitHub创建个人仓库安装Git安装Node.js安装Hexo推送网站绑定域名更换主题初识MarkDown语法发布文章寻找图床个性化设置其他附录 1.首先安装 node和npm git 这些软件 以及注册github2.安装hexo12npm i hexo-cli -g 安装Hexohexo init blog 建立一个项目 3.连接Github与本地123456789101112131415161718git config --global user.name &quot;godweiyang&quot;git config --global user.email &quot;792321264@qq.com&quot;用户名和邮箱根据你注册github的信息自行修改。然后生成密钥SSH key：ssh-keygen -t rsa -C &quot;792321264@qq.com&quot;打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。cat ~&#x2F;.ssh&#x2F;id_rsa.pub将输出的内容复制到框中，点击确定保存。在终端输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。修改最后一行的配置：deploy: type: git repository: https:&#x2F;&#x2F;github.com&#x2F;godweiyang&#x2F;godweiyang.github.io branch: masterrepository修改为你自己的github项目地址。 4.hexo命令1234hexo new post &quot;article title&quot;，新建一篇文章。hexo generate 生成静态文件hexo server 运行hexo服务器hexo deploy 将Hexo上传到Github 5.建立标签分类生成”分类”hexo new page categories，来新建一个页面，并命名为categories。成功后会提示：INFO Created: ~/hexo/source/categories/index.md根据上面的路径找到index.md这个文件，打开后默认内容如下： 12title: categoriesdate: 2018-10-25 20:11:37 编辑新创建的页面，添加type: “categories”到内容中(注意，这些属性和属性值之间必须有一个空格)，主题将自动为这个页面显示所有分类，添加后是这样的： 123title: categoriesdate: 2018-10-25 20:11:37type: &quot;categories&quot; 保存并关闭文件。 给文章添加”categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: Python表示添加这篇文章到“Python”这个分类中。 注意：Hexo中一篇文章只能属于一个分类，也就是说如果在”Python”下方添加”-xxx”，Hexo不会产生两个分类，而是把分类嵌套，即该文章属于”Python“下的”-xxx“分类。 12title: Python中*args和**kwargs的用法总结categories: Python 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令(重新部署)。 在Hexo菜单上添加分类选项 menu: Python: /Python##6.遇到问题hexo d命令报错 ERROR Deployer not found: git 解决方案这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了： 1npm install hexo-deployer-git --save","categories":[{"name":"oneself","slug":"oneself","permalink":"http://yoursite.com/categories/oneself/"}],"tags":[]}],"categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"},{"name":"oneself","slug":"oneself","permalink":"http://yoursite.com/categories/oneself/"}],"tags":[]}