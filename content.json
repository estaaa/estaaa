{"meta":{"title":"道法自然","subtitle":"记录精彩的人生, 留下永恒的脚印","description":"php教程 js教程 php博客 linux教程","author":"道法自然","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-04-20T09:02:01.000Z","updated":"2020-04-20T09:05:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Etag缓存在PHP","slug":"etag","date":"2020-04-20T10:30:29.000Z","updated":"2020-04-20T10:43:02.000Z","comments":true,"path":"2020/04/20/etag/","link":"","permalink":"http://yoursite.com/2020/04/20/etag/","excerpt":"","text":"HTTP 提供了许多页面缓存的方案，其中属 Etag 和 Last-Modified 应用最广。本文会先介绍 Etag 的应用场景，然后说说他在 PHP 和 node 中的使用。 一、Etag 的使用客户端和浏览器之间的交互： +---------+ 1 +---------+ | |---------------->| | | | 2（200，OK） | | | || | | 户 | 4（304） | 务 | | || | | | 6（200，OK） | | | |","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"php异常、错误处理机制","slug":"catch","date":"2020-04-20T10:29:27.000Z","updated":"2020-04-20T10:33:10.000Z","comments":true,"path":"2020/04/20/catch/","link":"","permalink":"http://yoursite.com/2020/04/20/catch/","excerpt":"","text":"1.php 中 try catch 可以帮助我们捕获程序代码的异常了，这样我们可以很好的处理一些不必要的错误了，感兴趣的朋友可以一起来看看。 PHP 中 try{}catch{}语句概述 PHP5 添加了类似于其它语言的异常处理模块。在 PHP 代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。（注：一定要先抛才能获取） 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch。 使用多个 catch 可以捕获不同的类所产生的异常。 当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 当然，PHP 允许在 catch 代码块内再次抛出（throw）异常。 当一个异常被抛出时，其后（译者注：指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。 如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception … （未捕获异常）的提示信息。 先来看一下 PHP 内置异常类的基本属性和方法。（不包括具体实现） 12345678910111213try&#123;&#125;catch()&#123;throw new Exception();&#125;catch()&#123;&#x2F;&#x2F;这里可以捕获到前面一个块抛出的Exception&#96;&#125; 如果抛出了一个异常，try 语句中的脚本将会停止执行，然后马上转向执行 catch 语句中的脚本。 例子如下： 包含文件错误抛出异常 12345678910111213141516171819202122232425262728&lt;?php&#x2F;&#x2F; 错误的演示try &#123;require (&#39;test_try_catch.php&#39;);&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&#39;test_try_catch.php&#39;);&#125; else &#123;throw new Exception(&#39;file is not exists&#39;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&quot;test_try_catch.php&quot;);&#125; else &#123;throw new Exception(&quot;file is not exists&quot;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125; 2、通过 set_exception_handler 函数设置异常处理函数，在这种情况下，即使没有 try{}catch{}，throw 抛出的异常也能由 set_exception_handler 设置的函数自动捕捉 123456set_exception_handler(&#39;exceptionHandler&#39;); throw new Exception(&quot;kkkkkkkkkkkkkkkk&quot;); function exceptionHandler(Exception $exception)&#123; echo $exception-&gt;getMessage(); &#125; 在 PHP 开发的时候常常会用到 error_reporting(report_level)来调试自己的程序，下面列出了 report_level 可能值： | 值 | 常量 | 描述 || 1 | E_ERROR | 这是一个严重错误，不可恢复，如位置异常，内存不足等 || 2 | E_WARNING | 警告，最一般的错误，如函数的参数错误等 || 4 | E_PARSE | 解析错误，在解析 PHP 文件时产生，并强制 PHP 在执行前退出 || 8 | E_NOTICE | 通告表示可能在操作一些未知的变量等。在开发时可开启通告，以保证程序是”安全通告”的，瑞在正式系统中，应关闭通告 || 16 | E_CORE_ERROR | 这个内部错误是由于 PHP 加载扩展失败而导致的，并且会导致 PHP 停止运行并退出 || 32 | E_CORE_WARNING | PHP 启动时初始化过程中的警告(非致命性错) || 64 | E_COMPILE_ERROR | 编译错误是在编译时发生，这个错误将导致 PHP 运行退出 || 128 | E_COMPILE_WARNING | 编译警告用于告诉用户一些不推荐的语法信息 || 256 | E_USER_ERROR | 用户定义的错误将导致辞 PHP 退出，它对是来自 PHP 自身，而是来自脚本文件中。 || 512 | E_USER_WARNING | 脚本使用它来通知一个执行失败，同时 PHP 也会用 E_WARNING 通知 || 1024 | E_USER_NOTICE | 用户定义的通告用于在脚本中表示可能存在的错误 || 2048 | E_STRICT | 编码标准化警告(建议如何修改以向前兼容) || 4096 | E_RECOVERABLE_ERROR | 接近致命的运行时错误，若未被捕获则视同 E_ERROR || 8191 | E_ALL | 除 E_STRICT 外的所有错误(PHP6 中为 8191,即包含所有) | 例子： 任意数目的以上选项都可以用“或”来连接（用 OR 或 |），这样可以报告所有需要的各级别错误。例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别： 12345678910111213141516171819&lt;?php&#x2F;&#x2F;禁用错误报告error_reporting(0); &#x2F;&#x2F;报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE); &#x2F;&#x2F;报告所有错误error_reporting(E_ALL); error_reporting(7);&#x2F;*设置php错误检测级别E_ERROR - 致命性运行时错 (1)E_WARNING - 运行时警告（非致命性错）(2)E_PARSE - 编译时解析错误 (4)1+2+4 &#x3D; 7*&#x2F;?&gt; 如果设置了 error_reporting(E_NOTICE)，那么程序只会输出 E_NOTICE 等级的信息，一般我们使用的时候只需要设置 error_reporting(E_ALL&amp;!E_WARNING)就行了 上面我们看到有一种错误叫用户自定义的错误消息，这是什么呢？我们先看一个例子 123456set_error_handler(&#39;errorHandler&#39;); trigger_error(&quot;aaaaaaassssssssssss&quot;,E_USER_ERROR); function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_USER_ERROR)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; 输出结果： 1innnnnnnni:aaaaaaassssssssssss trigger_error()就是用来抛出用户自定义错误消息的函数，通过这个我们能抛出自定义的一些消息被当作错误来处理，比如严重的逻辑问题 上面的程序我们看到，当程序出错时，除了让 PHP 默认输出出错信息外，我们还能设置自己的错误处理函数，设置的方法就是set_error_handler(),下面来看个例子 12345678set_error_handler(&#39;errorHandler&#39;); echo &quot;dddddddddddd&lt;&#x2F;br&gt;&quot;; echo $cc;&#x2F;&#x2F;$cc没有定义，echo会出错 function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_NOTICE)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; &#125; 输出结果： 12ddddddddddddinnnnnnnni:Undefined variable: cc","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"iconv的使用方法(转换编码,截取字符串,统计长度)","slug":"iconv","date":"2020-04-20T10:27:54.000Z","updated":"2020-04-20T10:30:00.000Z","comments":true,"path":"2020/04/20/iconv/","link":"","permalink":"http://yoursite.com/2020/04/20/iconv/","excerpt":"","text":"1.php 中 try catch 可以帮助我们捕获程序代码的异常了，这样我们可以很好的处理一些不必要的错误了，感兴趣的朋友可以一起来看看。 PHP 中 try{}catch{}语句概述 PHP5 添加了类似于其它语言的异常处理模块。在 PHP 代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。（注：一定要先抛才能获取） 需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。 每一个 try 至少要有一个与之对应的 catch。 使用多个 catch 可以捕获不同的类所产生的异常。 当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。 当然，PHP 允许在 catch 代码块内再次抛出（throw）异常。 当一个异常被抛出时，其后（译者注：指抛出异常时所在的代码块）的代码将不会继续执行，而 PHP 就会尝试查找第一个能与之匹配的 catch。 如果一个异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出 Uncaught Exception … （未捕获异常）的提示信息。 先来看一下 PHP 内置异常类的基本属性和方法。（不包括具体实现） 12345678910111213try&#123;&#125;catch()&#123;throw new Exception();&#125;catch()&#123;&#x2F;&#x2F;这里可以捕获到前面一个块抛出的Exception&#96;&#125; 如果抛出了一个异常，try 语句中的脚本将会停止执行，然后马上转向执行 catch 语句中的脚本。 例子如下： 包含文件错误抛出异常 12345678910111213141516171819202122232425262728&lt;?php&#x2F;&#x2F; 错误的演示try &#123;require (&#39;test_try_catch.php&#39;);&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&#39;test_try_catch.php&#39;);&#125; else &#123;throw new Exception(&#39;file is not exists&#39;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125;&#x2F;&#x2F; 正确的抛出异常try &#123;if (file_exists(&#39;test_try_catch.php&#39;)) &#123;require (&quot;test_try_catch.php&quot;);&#125; else &#123;throw new Exception(&quot;file is not exists&quot;);&#125;&#125; catch (Exception $e) &#123;echo $e-&gt;getMessage();&#125; 2、通过 set_exception_handler 函数设置异常处理函数，在这种情况下，即使没有 try{}catch{}，throw 抛出的异常也能由 set_exception_handler 设置的函数自动捕捉 123456set_exception_handler(&#39;exceptionHandler&#39;); throw new Exception(&quot;kkkkkkkkkkkkkkkk&quot;); function exceptionHandler(Exception $exception)&#123; echo $exception-&gt;getMessage(); &#125; 在 PHP 开发的时候常常会用到 error_reporting(report_level)来调试自己的程序，下面列出了 report_level 可能值： | 值 | 常量 | 描述 || 1 | E_ERROR | 这是一个严重错误，不可恢复，如位置异常，内存不足等 || 2 | E_WARNING | 警告，最一般的错误，如函数的参数错误等 || 4 | E_PARSE | 解析错误，在解析 PHP 文件时产生，并强制 PHP 在执行前退出 || 8 | E_NOTICE | 通告表示可能在操作一些未知的变量等。在开发时可开启通告，以保证程序是”安全通告”的，瑞在正式系统中，应关闭通告 || 16 | E_CORE_ERROR | 这个内部错误是由于 PHP 加载扩展失败而导致的，并且会导致 PHP 停止运行并退出 || 32 | E_CORE_WARNING | PHP 启动时初始化过程中的警告(非致命性错) || 64 | E_COMPILE_ERROR | 编译错误是在编译时发生，这个错误将导致 PHP 运行退出 || 128 | E_COMPILE_WARNING | 编译警告用于告诉用户一些不推荐的语法信息 || 256 | E_USER_ERROR | 用户定义的错误将导致辞 PHP 退出，它对是来自 PHP 自身，而是来自脚本文件中。 || 512 | E_USER_WARNING | 脚本使用它来通知一个执行失败，同时 PHP 也会用 E_WARNING 通知 || 1024 | E_USER_NOTICE | 用户定义的通告用于在脚本中表示可能存在的错误 || 2048 | E_STRICT | 编码标准化警告(建议如何修改以向前兼容) || 4096 | E_RECOVERABLE_ERROR | 接近致命的运行时错误，若未被捕获则视同 E_ERROR || 8191 | E_ALL | 除 E_STRICT 外的所有错误(PHP6 中为 8191,即包含所有) | 例子： 任意数目的以上选项都可以用“或”来连接（用 OR 或 |），这样可以报告所有需要的各级别错误。例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别： 12345678910111213141516171819&lt;?php&#x2F;&#x2F;禁用错误报告error_reporting(0); &#x2F;&#x2F;报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE); &#x2F;&#x2F;报告所有错误error_reporting(E_ALL); error_reporting(7);&#x2F;*设置php错误检测级别E_ERROR - 致命性运行时错 (1)E_WARNING - 运行时警告（非致命性错）(2)E_PARSE - 编译时解析错误 (4)1+2+4 &#x3D; 7*&#x2F;?&gt; 如果设置了 error_reporting(E_NOTICE)，那么程序只会输出 E_NOTICE 等级的信息，一般我们使用的时候只需要设置 error_reporting(E_ALL&amp;!E_WARNING)就行了 上面我们看到有一种错误叫用户自定义的错误消息，这是什么呢？我们先看一个例子 123456set_error_handler(&#39;errorHandler&#39;); trigger_error(&quot;aaaaaaassssssssssss&quot;,E_USER_ERROR); function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_USER_ERROR)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; 输出结果： 1innnnnnnni:aaaaaaassssssssssss trigger_error()就是用来抛出用户自定义错误消息的函数，通过这个我们能抛出自定义的一些消息被当作错误来处理，比如严重的逻辑问题 上面的程序我们看到，当程序出错时，除了让 PHP 默认输出出错信息外，我们还能设置自己的错误处理函数，设置的方法就是set_error_handler(),下面来看个例子 12345678set_error_handler(&#39;errorHandler&#39;); echo &quot;dddddddddddd&lt;&#x2F;br&gt;&quot;; echo $cc;&#x2F;&#x2F;$cc没有定义，echo会出错 function errorHandler($errno,$errstr)&#123; if($errno&#x3D;&#x3D;E_NOTICE)&#123; echo &quot;innnnnnnni:&quot;,$errstr; &#125; &#125; 输出结果： 12ddddddddddddinnnnnnnni:Undefined variable: cc","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"百度语音接口简单使用","slug":"baidu","date":"2020-04-20T10:23:01.000Z","updated":"2020-04-20T10:23:55.000Z","comments":true,"path":"2020/04/20/baidu/","link":"","permalink":"http://yoursite.com/2020/04/20/baidu/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpheader(&quot;Content-type:text&#x2F;html;charset&#x3D;utf-8&quot;);define(&#39;AUDIO_FILE&#39;, &quot;.&#x2F;test2.pcm&quot;);&#x2F;&#x2F;put your params here$cuid &#x3D; &quot;&quot;;$apiKey &#x3D; &quot;&quot;;$secretKey &#x3D; &quot;&quot;;$auth_url &#x3D; &quot;https:&#x2F;&#x2F;openapi.baidu.com&#x2F;oauth&#x2F;2.0&#x2F;token?grant_type&#x3D;client_credentials&amp;client_id&#x3D;&quot;.$apiKey.&quot;&amp;client_secret&#x3D;&quot;.$secretKey;$ch &#x3D; curl_init();curl_setopt($ch, CURLOPT_URL, $auth_url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);$response &#x3D; curl_exec($ch);if(curl_errno($ch))&#123; print curl_error($ch);&#125;curl_close($ch);$response &#x3D; json_decode($response, true);$token &#x3D; $response[&#39;access_token&#39;];$url &#x3D; &quot;http:&#x2F;&#x2F;vop.baidu.com&#x2F;server_api?cuid&#x3D;&quot;.$cuid.&quot;&amp;token&#x3D;&quot;.$token;&#x2F;&#x2F;$url &#x3D; $url.&quot;&amp;lan&#x3D;zh&quot;;$audio &#x3D; file_get_contents(AUDIO_FILE);$content_len &#x3D; &quot;Content-Length: &quot;.strlen($audio);$header &#x3D; array ($content_len,&#39;Content-Type: audio&#x2F;pcm; rate&#x3D;8000&#39;,);$ch &#x3D; curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_HTTPHEADER, $header);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);curl_setopt($ch, CURLOPT_TIMEOUT, 30);curl_setopt($ch, CURLOPT_POSTFIELDS, $audio);$response &#x3D; curl_exec($ch);if(curl_errno($ch))&#123; print curl_error($ch);&#125;curl_close($ch);echo $response;$response &#x3D; json_decode($response, true);&#x2F;&#x2F;var_dump($response);?&gt; 测试的时候官方会提示一个 3300 的错误 是证书验证不通过 特在此记录一下 在第一个 curl 里面加上下面语句就 ok 了 有兴趣的可以试一下吧 123&#96;curl_setopt(&#96;&#96;$ch&#96;&#96;, CURLOPT_SSL_VERIFYPEER, FALSE);&#96;&#96;curl_setopt(&#96;&#96;$ch&#96;&#96;, CURLOPT_SSL_VERIFYHOST, FALSE);&#96;","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"session和cookie的区别","slug":"session","date":"2020-04-20T10:21:32.000Z","updated":"2020-04-20T10:26:26.000Z","comments":true,"path":"2020/04/20/session/","link":"","permalink":"http://yoursite.com/2020/04/20/session/","excerpt":"","text":"——————————————session 的使用————————————– session 中同一浏览器同一站点只能有一个 session_id,下面我们一起来看看关于 session 使用方法。如何使用 session，凡是与 session 有关的，之前必须调用函数 session_start();为 session 赋值很简单，如： 1234567&lt;?phpSession_start();$Name &#x3D; &quot;这是一个Session例子&quot;;Session_Register(&quot;Name&quot;);&#x2F;&#x2F;注意,不要写成：Session_Register(&quot;$Name&quot;);echo $_SESSION[&quot;Name&quot;];&#x2F;&#x2F;输出$_SESSION[&quot;Name&quot;]为&quot;这是一个Session例子&quot;?&gt; 取消 session 可以这样： 12345&lt;?phpsession_start();session_unset();session_destroy();?&gt; 读取 session PHP 内置的 $_SESSION 变量可以很方便的访问设置的 session 变量。 1234&lt;?phpsession_start();echo &quot;登记的用户名为：&quot;.$_SESSION[&quot;username&quot;]; &#x2F;&#x2F;输出 登记的用户名为：nostop?&gt; 检查变量是否被登记为会话变量 session_is_registered语法：boobean session_is_registered(string name);这个函数可检查当前的 session 之中是否已有指定的变量注册，参数 name 就是要检查的变量名。成功则返回逻辑值 true。 123456&lt;?php session_start(); if(!session_is_registered(&quot;gender&quot;))&#123; &#x2F;&#x2F;判断当前会话变量是否注册 session_register(&quot;gender&quot;); &#x2F;&#x2F;注册变量 &#125; $gender&#x3D;&quot;女&quot;; ?&gt; 1234存取当前会话名称 session_name语法：boolean session_name(string [name]);这个函数可取得或重新设置当前 session 的名称。若无参数 name 则表示获取当前 session 名称，加上参数则表示将 session 名称设为参数 name。 12345存取当前会话标识号 session_id语法：boolean session_id(string [id]);这个函数可取得或重新设置当前存放 session 的标识号。若无参数 id 则表示只获取当前 session 的标识号，加上参数则表示将 session 的标识号设成新指定的 id。设置 Session 的生存期 123session_set_cookie_params:设置 Session 的生存期的，该函数必须在 session_start() 函数调用之前调用。如果客户端使用 IE 6.0 ， session_set_cookie_params(); 函数设置 Cookie 会有些问题，所以我们还是手动调用 setcookie 函数来创建 cookie。 123设置 Session 文件的保存路径session_save_path() ：必须在 session_start() 函数调用之前调用 12 12注意：1:在调用 Session_Start()之前不能有任何输出。例如下面是错误的。 12345678910111213141516171819202122232425提示 1:凡是出现&quot;........headers already sent..........&quot;,就是 Session_Start()之前向浏览器输出信息。去掉输出就正常，（COOKIE 也会出现这种错误，错误原因一样）提示 2:如果你的 Session_Start()放在循环语句里，并且很难确定之前哪里向浏览器输出信息，可以用下面这种方法：1 行 &lt;?PHP Ob_Start(); ?&gt;........这里是你的程序......2:这是什么错误Warning: session_start(): open(&#x2F;tmpsess_7d190aa36b4c5ec13a5c1649cc2da23f, O_RDWR) failed:....因为你没有指定 session 文件的存放路径。解决方法：(1)在 c 盘建立文件夹 tmp(2)打开 php.ini,找到 session.save_path,修改为 session.save_path&#x3D; &quot;c:&#x2F;tmp&quot;------------------------------------------**PHP cookie 的使用以及坑**--------------------------------------1.设置 cookie setcookie(‘uid’, 3, time()+3600, ‘/‘, $_SERVER[‘HTTP_HOST’]); // cookie 名字 cookie 值 过期时间 path 保存目录 作用域 12.设置 cookie 的过期 setcookie(‘uid’, 0, 0, ‘/‘, $_SERVER[‘HTTP_HOST’]); 123453.cookie 的坑 url 区分大小写如果不加第四个参数 可能会在 url 大小写下出现获取不到 cookie 所以一定要加上域名的作用域4.语法 setcookie(name,value,expire,path,domain,secure) 参数 描述 name 必需。规定 cookie 的名称。 value 必需。规定 cookie 的值。 expire 可选。规定 cookie 的有效期。 path 可选。规定 cookie 的服务器路径。 domain 可选。规定 cookie 的域名。 secure 可选。规定是否通过安全的 HTTPS 连接来传输 cookie。 ```","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"hexo 使用教程","slug":"hexo","date":"2020-04-20T07:16:36.000Z","updated":"2020-04-20T09:39:08.000Z","comments":true,"path":"2020/04/20/hexo/","link":"","permalink":"http://yoursite.com/2020/04/20/hexo/","excerpt":"","text":"搭建步骤获得个人网站域名GitHub创建个人仓库安装Git安装Node.js安装Hexo推送网站绑定域名更换主题初识MarkDown语法发布文章寻找图床个性化设置其他附录 1.首先安装 node和npm git 这些软件 以及注册github2.安装hexo12npm i hexo-cli -g 安装Hexohexo init blog 建立一个项目 3.连接Github与本地123456789101112131415161718git config --global user.name &quot;godweiyang&quot;git config --global user.email &quot;792321264@qq.com&quot;用户名和邮箱根据你注册github的信息自行修改。然后生成密钥SSH key：ssh-keygen -t rsa -C &quot;792321264@qq.com&quot;打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。cat ~&#x2F;.ssh&#x2F;id_rsa.pub将输出的内容复制到框中，点击确定保存。在终端输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。修改最后一行的配置：deploy: type: git repository: https:&#x2F;&#x2F;github.com&#x2F;godweiyang&#x2F;godweiyang.github.io branch: masterrepository修改为你自己的github项目地址。 4.hexo命令1234hexo new post &quot;article title&quot;，新建一篇文章。hexo generate 生成静态文件hexo server 运行hexo服务器hexo deploy 将Hexo上传到Github 5.建立标签分类生成”分类”hexo new page categories，来新建一个页面，并命名为categories。成功后会提示：INFO Created: ~/hexo/source/categories/index.md根据上面的路径找到index.md这个文件，打开后默认内容如下： 12title: categoriesdate: 2018-10-25 20:11:37 编辑新创建的页面，添加type: “categories”到内容中(注意，这些属性和属性值之间必须有一个空格)，主题将自动为这个页面显示所有分类，添加后是这样的： 123title: categoriesdate: 2018-10-25 20:11:37type: &quot;categories&quot; 保存并关闭文件。 给文章添加”categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: Python表示添加这篇文章到“Python”这个分类中。 注意：Hexo中一篇文章只能属于一个分类，也就是说如果在”Python”下方添加”-xxx”，Hexo不会产生两个分类，而是把分类嵌套，即该文章属于”Python“下的”-xxx“分类。 12title: Python中*args和**kwargs的用法总结categories: Python 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令(重新部署)。 在Hexo菜单上添加分类选项 menu: Python: /Python##6.遇到问题hexo d命令报错 ERROR Deployer not found: git 解决方案这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了： 1npm install hexo-deployer-git --save","categories":[{"name":"oneself","slug":"oneself","permalink":"http://yoursite.com/categories/oneself/"}],"tags":[]}],"categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"},{"name":"oneself","slug":"oneself","permalink":"http://yoursite.com/categories/oneself/"}],"tags":[]}